{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar Prism = require('prismjs');\nrequire('prismjs/components/prism-clike');\nrequire('prismjs/components/prism-javascript');\nrequire('prismjs/components/prism-markup');\nrequire('prismjs/components/prism-markdown');\nrequire('prismjs/components/prism-c');\nrequire('prismjs/components/prism-css');\nrequire('prismjs/components/prism-objectivec');\nrequire('prismjs/components/prism-sql');\nrequire('prismjs/components/prism-python');\nrequire('prismjs/components/prism-rust');\nrequire('prismjs/components/prism-swift');\nrequire('prismjs/components/prism-typescript');\nrequire('prismjs/components/prism-java');\nrequire('prismjs/components/prism-cpp');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mapToPrismLanguage = language => {\n  // eslint-disable-next-line no-prototype-builtins\n  return language != null && Prism.languages.hasOwnProperty(language) ? language : undefined;\n};\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if (utils.isHTMLElement(child) && child.tagName === tagName) {\n      return true;\n    }\n    hasChildDOMNodeTag(child, tagName);\n  }\n  return false;\n}\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n/** @noInheritDoc */\n\nclass CodeNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'code';\n  }\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n  constructor(language, key) {\n    super(key);\n    this.__language = mapToPrismLanguage(language);\n  } // View\n\n  createDOM(config) {\n    const element = document.createElement('code');\n    utils.addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n    }\n    return false;\n  }\n  exportDOM() {\n    const element = document.createElement('pre');\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n    return {\n      element\n    };\n  }\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: node => ({\n        conversion: convertDivElement,\n        priority: 1\n      }),\n      pre: node => ({\n        conversion: convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node; // domNode is a <table> since we matched it by nodeName\n\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: convertTableElement,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n        if (isGitHubCodeCell(td)) {\n          return {\n            conversion: convertTableCellElement,\n            priority: 3\n          };\n        }\n        if (table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeNode(serializedNode.language);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      language: this.getLanguage(),\n      type: 'code',\n      version: 1\n    };\n  } // Mutation\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = lexical.$createParagraphNode();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    } // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const firstPoint = anchor.isBefore(focus) ? anchor : focus;\n    const firstSelectionNode = firstPoint.getNode();\n    if ($isCodeHighlightNode(firstSelectionNode) || lexical.$isTabNode(firstSelectionNode)) {\n      let node = getFirstCodeNodeOfLine(firstSelectionNode);\n      const insertNodes = []; // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        if (lexical.$isTabNode(node)) {\n          insertNodes.push(lexical.$createTabNode());\n          node = node.getNextSibling();\n        } else if ($isCodeHighlightNode(node)) {\n          let spaces = 0;\n          const text = node.getTextContent();\n          const textSize = node.getTextContentSize();\n          for (; spaces < textSize && text[spaces] === ' '; spaces++);\n          if (spaces !== 0) {\n            insertNodes.push($createCodeHighlightNode(' '.repeat(spaces)));\n          }\n          if (spaces !== textSize) {\n            break;\n          }\n          node = node.getNextSibling();\n        } else {\n          break;\n        }\n      }\n      if (insertNodes.length > 0) {\n        selection.insertNodes([lexical.$createLineBreakNode(), ...insertNodes]);\n        return insertNodes[insertNodes.length - 1];\n      }\n    }\n    return null;\n  }\n  canIndent() {\n    return false;\n  }\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = mapToPrismLanguage(language);\n  }\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n}\nfunction $createCodeNode(language) {\n  return lexical.$applyNodeReplacement(new CodeNode(language));\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\nfunction convertPreElement(domNode) {\n  let language;\n  if (utils.isHTMLElement(domNode)) {\n    language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);\n  }\n  return {\n    node: $createCodeNode(language)\n  };\n}\nfunction convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n  return {\n    after: childLexicalNodes => {\n      const domParent = domNode.parentNode;\n      if (domParent != null && domNode !== domParent.lastChild) {\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n      return childLexicalNodes;\n    },\n    node: isCode ? $createCodeNode() : null\n  };\n}\nfunction convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\nfunction convertTableCellElement(domNode) {\n  // domNode is a <td> since we matched it by nodeName\n  const cell = domNode;\n  return {\n    after: childLexicalNodes => {\n      if (cell.parentNode && cell.parentNode.nextSibling) {\n        // Append newline between code lines\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n      return childLexicalNodes;\n    },\n    node: null\n  };\n}\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n    parent = parent.parentElement;\n  }\n  return false;\n}\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(Prism.languages).filter(\n// Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism.languages[language] !== 'function').sort();\n/** @noInheritDoc */\n\nclass CodeHighlightNode extends lexical.TextNode {\n  /** @internal */\n  constructor(text, highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n  static getType() {\n    return 'code-highlight';\n  }\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    utils.addClassNamesToElement(element, className);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        utils.removeClassNamesFromElement(dom, prevClassName);\n      }\n      if (nextClassName) {\n        utils.addClassNamesToElement(dom, nextClassName);\n      }\n    }\n    return update;\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      highlightType: this.getHighlightType(),\n      type: 'code-highlight',\n      version: 1\n    };\n  } // Prevent formatting (bold, underline, etc)\n\n  setFormat(format) {\n    return this;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n}\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\nfunction $createCodeHighlightNode(text, highlightType) {\n  return lexical.$applyNodeReplacement(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction getFirstCodeNodeOfLine(anchor) {\n  let previousNode = anchor;\n  let node = anchor;\n  while ($isCodeHighlightNode(node) || lexical.$isTabNode(node)) {\n    previousNode = node;\n    node = node.getPreviousSibling();\n  }\n  return previousNode;\n}\nfunction getLastCodeNodeOfLine(anchor) {\n  let nextNode = anchor;\n  let node = anchor;\n  while ($isCodeHighlightNode(node) || lexical.$isTabNode(node)) {\n    nextNode = node;\n    node = node.getNextSibling();\n  }\n  return nextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PrismTokenizer = {\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n  tokenize(code, language) {\n    return Prism.tokenize(code, Prism.languages[language || ''] || Prism.languages[this.defaultLanguage]);\n  }\n};\nfunction getStartOfCodeInLine(anchor, offset) {\n  let last = null;\n  let lastNonBlank = null;\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent(); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    if (nodeOffset === 0) {\n      node = node.getPreviousSibling();\n      if (node === null) {\n        break;\n      }\n      if (!($isCodeHighlightNode(node) || lexical.$isTabNode(node) || lexical.$isLineBreakNode(node))) {\n        throw Error(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);\n      }\n      if (lexical.$isLineBreakNode(node)) {\n        last = {\n          node,\n          offset: 1\n        };\n        break;\n      }\n      nodeOffset = Math.max(0, node.getTextContentSize() - 1);\n      nodeTextContent = node.getTextContent();\n    } else {\n      nodeOffset--;\n    }\n    const character = nodeTextContent[nodeOffset];\n    if ($isCodeHighlightNode(node) && character !== ' ') {\n      lastNonBlank = {\n        node,\n        offset: nodeOffset\n      };\n    }\n  } // lastNonBlank !== null: anchor in the middle of code; move to line beginning\n\n  if (lastNonBlank !== null) {\n    return lastNonBlank;\n  } // Spaces, tabs or nothing ahead of anchor\n\n  let codeCharacterAtAnchorOffset = null;\n  if (offset < anchor.getTextContentSize()) {\n    if ($isCodeHighlightNode(anchor)) {\n      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];\n    }\n  } else {\n    const nextSibling = anchor.getNextSibling();\n    if ($isCodeHighlightNode(nextSibling)) {\n      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];\n    }\n  }\n  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== ' ') {\n    // Borderline whitespace and code, move to line beginning\n    return last;\n  } else {\n    const nextNonBlank = findNextNonBlankInLine(anchor, offset);\n    if (nextNonBlank !== null) {\n      return nextNonBlank;\n    } else {\n      return last;\n    }\n  }\n}\nfunction findNextNonBlankInLine(anchor, offset) {\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  let nodeTextContentSize = anchor.getTextContentSize(); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {\n      node = node.getNextSibling();\n      if (node === null || lexical.$isLineBreakNode(node)) {\n        return null;\n      }\n      if ($isCodeHighlightNode(node)) {\n        nodeOffset = 0;\n        nodeTextContent = node.getTextContent();\n        nodeTextContentSize = node.getTextContentSize();\n      }\n    }\n    if ($isCodeHighlightNode(node)) {\n      if (nodeTextContent[nodeOffset] !== ' ') {\n        return {\n          node,\n          offset: nodeOffset\n        };\n      }\n      nodeOffset++;\n    }\n  }\n}\nfunction getEndOfCodeInLine(anchor) {\n  const lastNode = getLastCodeNodeOfLine(anchor);\n  if (!!lexical.$isLineBreakNode(lastNode)) {\n    throw Error(`Unexpected lineBreakNode in getEndOfCodeInLine`);\n  }\n  return lastNode;\n}\nfunction textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace(lexical.$createTextNode(node.__text));\n  }\n}\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n  if (codeElement === null) {\n    return;\n  }\n  const children = node.getChildren();\n  const childrenLength = children.length; // @ts-ignore: internal field\n\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  } // @ts-ignore:: internal field\n\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n  for (let i = 0; i < childrenLength; i++) {\n    if (lexical.$isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n  codeElement.setAttribute('data-gutter', gutter);\n} // Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\nconst nodesCurrentlyHighlighting = new Set();\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n  nodesCurrentlyHighlighting.add(nodeKey); // When new code block inserted it might not have language selected\n\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  } // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual codehighlight node to be transformed again as it's already\n  // in its final state\n\n  editor.update(() => {\n    updateAndRetainSelection(nodeKey, () => {\n      const currentNode = lexical.$getNodeByKey(nodeKey);\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n      const code = currentNode.getTextContent();\n      const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);\n      const highlightNodes = getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\nfunction getHighlightNodes(tokens, type) {\n  const nodes = [];\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      const partials = token.split(/(\\n|\\t)/);\n      const partialsLength = partials.length;\n      for (let i = 0; i < partialsLength; i++) {\n        const part = partials[i];\n        if (part === '\\n' || part === '\\r\\n') {\n          nodes.push(lexical.$createLineBreakNode());\n        } else if (part === '\\t') {\n          nodes.push(lexical.$createTabNode());\n        } else if (part.length > 0) {\n          nodes.push($createCodeHighlightNode(part, type));\n        }\n      }\n    } else {\n      const {\n        content\n      } = token;\n      if (typeof content === 'string') {\n        nodes.push(...getHighlightNodes([content], token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...getHighlightNodes(content, token.type));\n      }\n    }\n  }\n  return nodes;\n} // Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\n\nfunction updateAndRetainSelection(nodeKey, updateFn) {\n  const node = lexical.$getNodeByKey(nodeKey);\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n  const selection = lexical.$getSelection(); // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n\n  if (!lexical.$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && lexical.$isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0; // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n  const hasChanges = updateFn();\n  if (!hasChanges) {\n    return;\n  } // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  } // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n\n  node.getChildren().some(_node => {\n    const isText = lexical.$isTextNode(_node);\n    if (isText || lexical.$isLineBreakNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n        return true;\n      }\n      textOffset -= textContentSize;\n    }\n    return false;\n  });\n} // Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\n\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n    leadingMatch++;\n  }\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code higlight nodes, tabs and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || lexical.$isTabNode(nodeA) && lexical.$isTabNode(nodeB) || lexical.$isLineBreakNode(nodeA) && lexical.$isLineBreakNode(nodeB);\n}\nfunction $isSelectionInCode(selection) {\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n  const anchorNode = selection.anchor.getNode();\n  const focusNode = selection.focus.getNode();\n  if (anchorNode.is(focusNode) && $isCodeNode(anchorNode)) {\n    return true;\n  }\n  const anchorParent = anchorNode.getParent();\n  return $isCodeNode(anchorParent) && anchorParent.is(focusNode.getParent());\n}\nfunction $getCodeLines(selection) {\n  const nodes = selection.getNodes();\n  const lines = [[]];\n  if (nodes.length === 1 && $isCodeNode(nodes[0])) {\n    return lines;\n  }\n  let lastLine = lines[0];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!($isCodeHighlightNode(node) || lexical.$isTabNode(node) || lexical.$isLineBreakNode(node))) {\n      throw Error(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);\n    }\n    if (lexical.$isLineBreakNode(node)) {\n      if (i !== 0 && lastLine.length > 0) {\n        lastLine = [];\n        lines.push(lastLine);\n      }\n    } else {\n      lastLine.push(node);\n    }\n  }\n  return lines;\n}\nfunction handleTab(shiftKey) {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return null;\n  }\n  const indentOrOutdent = !shiftKey ? lexical.INDENT_CONTENT_COMMAND : lexical.OUTDENT_CONTENT_COMMAND;\n  const tabOrOutdent = !shiftKey ? lexical.INSERT_TAB_COMMAND : lexical.OUTDENT_CONTENT_COMMAND; // 1. If multiple lines selected: indent/outdent\n\n  const codeLines = $getCodeLines(selection);\n  if (codeLines.length > 1) {\n    return indentOrOutdent;\n  } // 2. If entire line selected: indent/outdent\n\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || lexical.$isTabNode(firstNode) || lexical.$isLineBreakNode(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or TabNode`);\n  }\n  if ($isCodeNode(firstNode)) {\n    return indentOrOutdent;\n  }\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n  const lastOfLine = getLastCodeNodeOfLine(firstNode);\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  let selectionFirst;\n  let selectionLast;\n  if (focus.isBefore(anchor)) {\n    selectionFirst = focus;\n    selectionLast = anchor;\n  } else {\n    selectionFirst = anchor;\n    selectionLast = focus;\n  }\n  if (firstOfLine !== null && lastOfLine !== null && selectionFirst.key === firstOfLine.getKey() && selectionFirst.offset === 0 && selectionLast.key === lastOfLine.getKey() && selectionLast.offset === lastOfLine.getTextContentSize()) {\n    return indentOrOutdent;\n  } // 3. Else: tab/outdent\n\n  return tabOrOutdent;\n}\nfunction handleMultilineIndent(type) {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return false;\n  }\n  const codeLines = $getCodeLines(selection);\n  const codeLinesLength = codeLines.length; // Multiple lines selection\n\n  if (codeLines.length > 1) {\n    for (let i = 0; i < codeLinesLength; i++) {\n      const line = codeLines[i];\n      if (line.length > 0) {\n        let firstOfLine = line[0]; // First and last lines might not be complete\n\n        if (i === 0) {\n          firstOfLine = getFirstCodeNodeOfLine(firstOfLine);\n        }\n        if (firstOfLine !== null) {\n          if (type === lexical.INDENT_CONTENT_COMMAND) {\n            firstOfLine.insertBefore(lexical.$createTabNode());\n          } else if (lexical.$isTabNode(firstOfLine)) {\n            firstOfLine.remove();\n          }\n        }\n      }\n    }\n    return true;\n  } // Just one line\n\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || lexical.$isTabNode(firstNode) || lexical.$isLineBreakNode(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or CodeTabNode`);\n  }\n  if ($isCodeNode(firstNode)) {\n    // CodeNode is empty\n    if (type === lexical.INDENT_CONTENT_COMMAND) {\n      selection.insertNodes([lexical.$createTabNode()]);\n    }\n    return true;\n  }\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n  if (!(firstOfLine !== null)) {\n    throw Error(`Expected getFirstCodeNodeOfLine to return a valid Code Node`);\n  }\n  if (type === lexical.INDENT_CONTENT_COMMAND) {\n    if (lexical.$isLineBreakNode(firstOfLine)) {\n      firstOfLine.insertAfter(lexical.$createTabNode());\n    } else {\n      firstOfLine.insertBefore(lexical.$createTabNode());\n    }\n  } else if (lexical.$isTabNode(firstOfLine)) {\n    firstOfLine.remove();\n  }\n  return true;\n}\nfunction handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  } // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === lexical.KEY_ARROW_UP_COMMAND; // Ensure the selection is within the codeblock\n\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || lexical.$isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || lexical.$isTabNode(focusNode))) {\n    return false;\n  }\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // sibling thats can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  let start;\n  let end;\n  if (anchorNode.isBefore(focusNode)) {\n    start = getFirstCodeNodeOfLine(anchorNode);\n    end = getLastCodeNodeOfLine(focusNode);\n  } else {\n    start = getFirstCodeNodeOfLine(focusNode);\n    end = getLastCodeNodeOfLine(anchorNode);\n  }\n  if (start == null || end == null) {\n    return false;\n  }\n  const range = start.getNodesBetween(end);\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n    if (!$isCodeHighlightNode(node) && !lexical.$isTabNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  } // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n  if (!lexical.$isLineBreakNode(linebreak)) {\n    return true;\n  }\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n  if (sibling == null) {\n    return true;\n  }\n  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || lexical.$isTabNode(sibling) || lexical.$isLineBreakNode(sibling) ? arrowIsUp ? getFirstCodeNodeOfLine(sibling) : getLastCodeNodeOfLine(sibling) : null;\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n  if (type === lexical.KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\nfunction handleMoveTo(type, event) {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === lexical.MOVE_TO_START;\n  if (!($isCodeHighlightNode(anchorNode) || lexical.$isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || lexical.$isTabNode(focusNode))) {\n    return false;\n  }\n  if (isMoveToStart) {\n    const start = getStartOfCodeInLine(focusNode, focus.offset);\n    if (start !== null) {\n      const {\n        node,\n        offset\n      } = start;\n      if (lexical.$isLineBreakNode(node)) {\n        node.selectNext(0, 0);\n      } else {\n        selection.setTextNodeRange(node, offset, node, offset);\n      }\n    } else {\n      focusNode.getParentOrThrow().selectStart();\n    }\n  } else {\n    const node = getEndOfCodeInLine(focusNode);\n    node.select();\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n  return utils.mergeRegister(editor.registerMutationListener(CodeNode, mutations => {\n    editor.update(() => {\n      for (const [key, type] of mutations) {\n        if (type !== 'destroyed') {\n          const node = lexical.$getNodeByKey(key);\n          if (node !== null) {\n            updateCodeGutter(node, editor);\n          }\n        }\n      }\n    });\n  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(lexical.TextNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n    const command = handleTab(event.shiftKey);\n    if (command === null) {\n      return false;\n    }\n    event.preventDefault();\n    editor.dispatchCommand(command, undefined);\n    return true;\n  }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INSERT_TAB_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    lexical.$insertNodes([lexical.$createTabNode()]);\n    return true;\n  }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.INDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.OUTDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_UP_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_DOWN_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_END, payload => handleMoveTo(lexical.MOVE_TO_END, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_START, payload => handleMoveTo(lexical.MOVE_TO_START, payload), lexical.COMMAND_PRIORITY_LOW));\n}\nexports.$createCodeHighlightNode = $createCodeHighlightNode;\nexports.$createCodeNode = $createCodeNode;\nexports.$isCodeHighlightNode = $isCodeHighlightNode;\nexports.$isCodeNode = $isCodeNode;\nexports.CODE_LANGUAGE_FRIENDLY_NAME_MAP = CODE_LANGUAGE_FRIENDLY_NAME_MAP;\nexports.CODE_LANGUAGE_MAP = CODE_LANGUAGE_MAP;\nexports.CodeHighlightNode = CodeHighlightNode;\nexports.CodeNode = CodeNode;\nexports.DEFAULT_CODE_LANGUAGE = DEFAULT_CODE_LANGUAGE;\nexports.PrismTokenizer = PrismTokenizer;\nexports.getCodeLanguages = getCodeLanguages;\nexports.getDefaultCodeLanguage = getDefaultCodeLanguage;\nexports.getEndOfCodeInLine = getEndOfCodeInLine;\nexports.getFirstCodeNodeOfLine = getFirstCodeNodeOfLine;\nexports.getLanguageFriendlyName = getLanguageFriendlyName;\nexports.getLastCodeNodeOfLine = getLastCodeNodeOfLine;\nexports.getStartOfCodeInLine = getStartOfCodeInLine;\nexports.normalizeCodeLang = normalizeCodeLang;\nexports.registerCodeHighlighting = registerCodeHighlighting;","map":{"version":3,"names":["Prism","require","utils","lexical","mapToPrismLanguage","language","languages","hasOwnProperty","undefined","hasChildDOMNodeTag","node","tagName","child","childNodes","isHTMLElement","LANGUAGE_DATA_ATTRIBUTE","CodeNode","ElementNode","getType","clone","__language","__key","constructor","key","createDOM","config","element","document","createElement","addClassNamesToElement","theme","code","setAttribute","getLanguage","updateDOM","prevNode","dom","prevLanguage","removeAttribute","exportDOM","importDOM","isMultiLine","textContent","test","conversion","convertPreElement","priority","div","convertDivElement","pre","table","isGitHubCodeTable","convertTableElement","td","closest","isGitHubCodeCell","convertTableCellElement","convertCodeNoop","tr","importJSON","serializedNode","$createCodeNode","setFormat","format","setIndent","indent","setDirection","direction","exportJSON","type","version","insertNewAfter","selection","restoreSelection","children","getChildren","childrenLength","length","getTextContent","isCollapsed","anchor","offset","remove","newElement","$createParagraphNode","insertAfter","focus","firstPoint","isBefore","firstSelectionNode","getNode","$isCodeHighlightNode","$isTabNode","getFirstCodeNodeOfLine","insertNodes","push","$createTabNode","getNextSibling","spaces","text","textSize","getTextContentSize","$createCodeHighlightNode","repeat","$createLineBreakNode","canIndent","collapseAtStart","paragraph","forEach","append","replace","setLanguage","writable","getWritable","getLatest","$applyNodeReplacement","$isCodeNode","domNode","getAttribute","isCode","isCodeElement","isCodeChildElement","after","childLexicalNodes","domParent","parentNode","lastChild","cell","nextSibling","style","fontFamily","match","parent","parentElement","classList","contains","DEFAULT_CODE_LANGUAGE","CODE_LANGUAGE_FRIENDLY_NAME_MAP","c","clike","cpp","css","html","java","js","markdown","objc","plain","py","rust","sql","swift","typescript","xml","CODE_LANGUAGE_MAP","javascript","md","plaintext","python","ts","normalizeCodeLang","lang","getLanguageFriendlyName","_lang","getDefaultCodeLanguage","getCodeLanguages","Object","keys","filter","sort","CodeHighlightNode","TextNode","highlightType","__highlightType","__text","getHighlightType","self","className","getHighlightThemeClass","update","prevClassName","nextClassName","removeClassNamesFromElement","setDetail","detail","setMode","mode","setStyle","isParentRequired","createParentElementNode","codeHighlight","previousNode","getPreviousSibling","getLastCodeNodeOfLine","nextNode","PrismTokenizer","defaultLanguage","tokenize","getStartOfCodeInLine","last","lastNonBlank","nodeOffset","nodeTextContent","$isLineBreakNode","Error","Math","max","character","codeCharacterAtAnchorOffset","nextNonBlank","findNextNonBlankInLine","nodeTextContentSize","getEndOfCodeInLine","lastNode","textNodeTransform","editor","tokenizer","getParent","codeNodeTransform","$createTextNode","updateCodeGutter","codeElement","getElementByKey","getKey","__cachedChildrenLength","gutter","count","i","nodesCurrentlyHighlighting","Set","nodeKey","has","add","updateAndRetainSelection","currentNode","$getNodeByKey","isAttached","tokens","highlightNodes","getHighlightNodes","diffRange","getDiffRange","from","to","nodesForReplacement","splice","onUpdate","delete","skipTransforms","nodes","token","partials","split","partialsLength","part","content","Array","isArray","updateFn","$getSelection","$isRangeSelection","anchorOffset","isNewLineAnchor","getChildAtIndex","textOffset","anchorNode","getPreviousSiblings","reduce","_node","hasChanges","select","some","isText","$isTextNode","textContentSize","prevNodes","nextNodes","leadingMatch","isEqual","prevNodesLength","nextNodesLength","maxTrailingMatch","min","trailingMatch","slice","nodeA","nodeB","$isSelectionInCode","focusNode","is","anchorParent","$getCodeLines","getNodes","lines","lastLine","handleTab","shiftKey","indentOrOutdent","INDENT_CONTENT_COMMAND","OUTDENT_CONTENT_COMMAND","tabOrOutdent","INSERT_TAB_COMMAND","codeLines","selectionNodes","firstNode","firstOfLine","lastOfLine","selectionFirst","selectionLast","handleMultilineIndent","codeLinesLength","line","insertBefore","handleShiftLines","event","focusOffset","arrowIsUp","KEY_ARROW_UP_COMMAND","altKey","codeNode","getParentOrThrow","codeNodeSibling","selectPrevious","preventDefault","selectNext","start","end","range","getNodesBetween","stopPropagation","linebreak","sibling","maybeInsertionPoint","insertionPoint","setTextNodeRange","handleMoveTo","isMoveToStart","MOVE_TO_START","selectStart","registerCodeHighlighting","hasNodes","mergeRegister","registerMutationListener","mutations","registerNodeTransform","registerCommand","KEY_TAB_COMMAND","command","dispatchCommand","COMMAND_PRIORITY_LOW","$insertNodes","payload","KEY_ARROW_DOWN_COMMAND","MOVE_TO_END","exports"],"sources":["C:/Users/franc/Desktop/Progetto/Frontend/app_frontend/node_modules/@lexical/code/LexicalCode.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar Prism = require('prismjs');\nrequire('prismjs/components/prism-clike');\nrequire('prismjs/components/prism-javascript');\nrequire('prismjs/components/prism-markup');\nrequire('prismjs/components/prism-markdown');\nrequire('prismjs/components/prism-c');\nrequire('prismjs/components/prism-css');\nrequire('prismjs/components/prism-objectivec');\nrequire('prismjs/components/prism-sql');\nrequire('prismjs/components/prism-python');\nrequire('prismjs/components/prism-rust');\nrequire('prismjs/components/prism-swift');\nrequire('prismjs/components/prism-typescript');\nrequire('prismjs/components/prism-java');\nrequire('prismjs/components/prism-cpp');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mapToPrismLanguage = language => {\n  // eslint-disable-next-line no-prototype-builtins\n  return language != null && Prism.languages.hasOwnProperty(language) ? language : undefined;\n};\n\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if (utils.isHTMLElement(child) && child.tagName === tagName) {\n      return true;\n    }\n\n    hasChildDOMNodeTag(child, tagName);\n  }\n\n  return false;\n}\n\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n/** @noInheritDoc */\n\nclass CodeNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'code';\n  }\n\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n\n  constructor(language, key) {\n    super(key);\n    this.__language = mapToPrismLanguage(language);\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('code');\n    utils.addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n    }\n\n    return false;\n  }\n\n  exportDOM() {\n    const element = document.createElement('pre');\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: node => ({\n        conversion: convertDivElement,\n        priority: 1\n      }),\n      pre: node => ({\n        conversion: convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node; // domNode is a <table> since we matched it by nodeName\n\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: convertTableElement,\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n\n        if (isGitHubCodeCell(td)) {\n          return {\n            conversion: convertTableCellElement,\n            priority: 3\n          };\n        }\n\n        if (table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n\n        return null;\n      }\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createCodeNode(serializedNode.language);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      language: this.getLanguage(),\n      type: 'code',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = lexical.$createParagraphNode();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    } // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n\n\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const firstPoint = anchor.isBefore(focus) ? anchor : focus;\n    const firstSelectionNode = firstPoint.getNode();\n\n    if ($isCodeHighlightNode(firstSelectionNode) || lexical.$isTabNode(firstSelectionNode)) {\n      let node = getFirstCodeNodeOfLine(firstSelectionNode);\n      const insertNodes = []; // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        if (lexical.$isTabNode(node)) {\n          insertNodes.push(lexical.$createTabNode());\n          node = node.getNextSibling();\n        } else if ($isCodeHighlightNode(node)) {\n          let spaces = 0;\n          const text = node.getTextContent();\n          const textSize = node.getTextContentSize();\n\n          for (; spaces < textSize && text[spaces] === ' '; spaces++);\n\n          if (spaces !== 0) {\n            insertNodes.push($createCodeHighlightNode(' '.repeat(spaces)));\n          }\n\n          if (spaces !== textSize) {\n            break;\n          }\n\n          node = node.getNextSibling();\n        } else {\n          break;\n        }\n      }\n\n      if (insertNodes.length > 0) {\n        selection.insertNodes([lexical.$createLineBreakNode(), ...insertNodes]);\n        return insertNodes[insertNodes.length - 1];\n      }\n    }\n\n    return null;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = mapToPrismLanguage(language);\n  }\n\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n\n}\nfunction $createCodeNode(language) {\n  return lexical.$applyNodeReplacement(new CodeNode(language));\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\n\nfunction convertPreElement(domNode) {\n  let language;\n\n  if (utils.isHTMLElement(domNode)) {\n    language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);\n  }\n\n  return {\n    node: $createCodeNode(language)\n  };\n}\n\nfunction convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    after: childLexicalNodes => {\n      const domParent = domNode.parentNode;\n\n      if (domParent != null && domNode !== domParent.lastChild) {\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n\n      return childLexicalNodes;\n    },\n    node: isCode ? $createCodeNode() : null\n  };\n}\n\nfunction convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\n\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\n\nfunction convertTableCellElement(domNode) {\n  // domNode is a <td> since we matched it by nodeName\n  const cell = domNode;\n  return {\n    after: childLexicalNodes => {\n      if (cell.parentNode && cell.parentNode.nextSibling) {\n        // Append newline between code lines\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n\n      return childLexicalNodes;\n    },\n    node: null\n  };\n}\n\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\n\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n\n    parent = parent.parentElement;\n  }\n\n  return false;\n}\n\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\n\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(Prism.languages).filter( // Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism.languages[language] !== 'function').sort();\n/** @noInheritDoc */\n\nclass CodeHighlightNode extends lexical.TextNode {\n  /** @internal */\n  constructor(text, highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n\n  static getType() {\n    return 'code-highlight';\n  }\n\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    utils.addClassNamesToElement(element, className);\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        utils.removeClassNamesFromElement(dom, prevClassName);\n      }\n\n      if (nextClassName) {\n        utils.addClassNamesToElement(dom, nextClassName);\n      }\n    }\n\n    return update;\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      highlightType: this.getHighlightType(),\n      type: 'code-highlight',\n      version: 1\n    };\n  } // Prevent formatting (bold, underline, etc)\n\n\n  setFormat(format) {\n    return this;\n  }\n\n  isParentRequired() {\n    return true;\n  }\n\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n\n}\n\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\n\nfunction $createCodeHighlightNode(text, highlightType) {\n  return lexical.$applyNodeReplacement(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction getFirstCodeNodeOfLine(anchor) {\n  let previousNode = anchor;\n  let node = anchor;\n\n  while ($isCodeHighlightNode(node) || lexical.$isTabNode(node)) {\n    previousNode = node;\n    node = node.getPreviousSibling();\n  }\n\n  return previousNode;\n}\nfunction getLastCodeNodeOfLine(anchor) {\n  let nextNode = anchor;\n  let node = anchor;\n\n  while ($isCodeHighlightNode(node) || lexical.$isTabNode(node)) {\n    nextNode = node;\n    node = node.getNextSibling();\n  }\n\n  return nextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PrismTokenizer = {\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n\n  tokenize(code, language) {\n    return Prism.tokenize(code, Prism.languages[language || ''] || Prism.languages[this.defaultLanguage]);\n  }\n\n};\nfunction getStartOfCodeInLine(anchor, offset) {\n  let last = null;\n  let lastNonBlank = null;\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent(); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    if (nodeOffset === 0) {\n      node = node.getPreviousSibling();\n\n      if (node === null) {\n        break;\n      }\n\n      if (!($isCodeHighlightNode(node) || lexical.$isTabNode(node) || lexical.$isLineBreakNode(node))) {\n        throw Error(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);\n      }\n\n      if (lexical.$isLineBreakNode(node)) {\n        last = {\n          node,\n          offset: 1\n        };\n        break;\n      }\n\n      nodeOffset = Math.max(0, node.getTextContentSize() - 1);\n      nodeTextContent = node.getTextContent();\n    } else {\n      nodeOffset--;\n    }\n\n    const character = nodeTextContent[nodeOffset];\n\n    if ($isCodeHighlightNode(node) && character !== ' ') {\n      lastNonBlank = {\n        node,\n        offset: nodeOffset\n      };\n    }\n  } // lastNonBlank !== null: anchor in the middle of code; move to line beginning\n\n\n  if (lastNonBlank !== null) {\n    return lastNonBlank;\n  } // Spaces, tabs or nothing ahead of anchor\n\n\n  let codeCharacterAtAnchorOffset = null;\n\n  if (offset < anchor.getTextContentSize()) {\n    if ($isCodeHighlightNode(anchor)) {\n      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];\n    }\n  } else {\n    const nextSibling = anchor.getNextSibling();\n\n    if ($isCodeHighlightNode(nextSibling)) {\n      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];\n    }\n  }\n\n  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== ' ') {\n    // Borderline whitespace and code, move to line beginning\n    return last;\n  } else {\n    const nextNonBlank = findNextNonBlankInLine(anchor, offset);\n\n    if (nextNonBlank !== null) {\n      return nextNonBlank;\n    } else {\n      return last;\n    }\n  }\n}\n\nfunction findNextNonBlankInLine(anchor, offset) {\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  let nodeTextContentSize = anchor.getTextContentSize(); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {\n      node = node.getNextSibling();\n\n      if (node === null || lexical.$isLineBreakNode(node)) {\n        return null;\n      }\n\n      if ($isCodeHighlightNode(node)) {\n        nodeOffset = 0;\n        nodeTextContent = node.getTextContent();\n        nodeTextContentSize = node.getTextContentSize();\n      }\n    }\n\n    if ($isCodeHighlightNode(node)) {\n      if (nodeTextContent[nodeOffset] !== ' ') {\n        return {\n          node,\n          offset: nodeOffset\n        };\n      }\n\n      nodeOffset++;\n    }\n  }\n}\n\nfunction getEndOfCodeInLine(anchor) {\n  const lastNode = getLastCodeNodeOfLine(anchor);\n\n  if (!!lexical.$isLineBreakNode(lastNode)) {\n    throw Error(`Unexpected lineBreakNode in getEndOfCodeInLine`);\n  }\n\n  return lastNode;\n}\n\nfunction textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace(lexical.$createTextNode(node.__text));\n  }\n}\n\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n\n  if (codeElement === null) {\n    return;\n  }\n\n  const children = node.getChildren();\n  const childrenLength = children.length; // @ts-ignore: internal field\n\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  } // @ts-ignore:: internal field\n\n\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n\n  for (let i = 0; i < childrenLength; i++) {\n    if (lexical.$isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n\n  codeElement.setAttribute('data-gutter', gutter);\n} // Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\n\nconst nodesCurrentlyHighlighting = new Set();\n\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n\n  nodesCurrentlyHighlighting.add(nodeKey); // When new code block inserted it might not have language selected\n\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  } // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual codehighlight node to be transformed again as it's already\n  // in its final state\n\n\n  editor.update(() => {\n    updateAndRetainSelection(nodeKey, () => {\n      const currentNode = lexical.$getNodeByKey(nodeKey);\n\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n\n      const code = currentNode.getTextContent();\n      const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);\n      const highlightNodes = getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\n\nfunction getHighlightNodes(tokens, type) {\n  const nodes = [];\n\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      const partials = token.split(/(\\n|\\t)/);\n      const partialsLength = partials.length;\n\n      for (let i = 0; i < partialsLength; i++) {\n        const part = partials[i];\n\n        if (part === '\\n' || part === '\\r\\n') {\n          nodes.push(lexical.$createLineBreakNode());\n        } else if (part === '\\t') {\n          nodes.push(lexical.$createTabNode());\n        } else if (part.length > 0) {\n          nodes.push($createCodeHighlightNode(part, type));\n        }\n      }\n    } else {\n      const {\n        content\n      } = token;\n\n      if (typeof content === 'string') {\n        nodes.push(...getHighlightNodes([content], token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...getHighlightNodes(content, token.type));\n      }\n    }\n  }\n\n  return nodes;\n} // Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\n\n\nfunction updateAndRetainSelection(nodeKey, updateFn) {\n  const node = lexical.$getNodeByKey(nodeKey);\n\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n\n  const selection = lexical.$getSelection(); // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n\n  if (!lexical.$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && lexical.$isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0; // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n\n  const hasChanges = updateFn();\n\n  if (!hasChanges) {\n    return;\n  } // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n\n\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  } // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n\n\n  node.getChildren().some(_node => {\n    const isText = lexical.$isTextNode(_node);\n\n    if (isText || lexical.$isLineBreakNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n\n        return true;\n      }\n\n      textOffset -= textContentSize;\n    }\n\n    return false;\n  });\n} // Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\n\n\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n\n    leadingMatch++;\n  }\n\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\n\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code higlight nodes, tabs and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || lexical.$isTabNode(nodeA) && lexical.$isTabNode(nodeB) || lexical.$isLineBreakNode(nodeA) && lexical.$isLineBreakNode(nodeB);\n}\n\nfunction $isSelectionInCode(selection) {\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  const anchorNode = selection.anchor.getNode();\n  const focusNode = selection.focus.getNode();\n\n  if (anchorNode.is(focusNode) && $isCodeNode(anchorNode)) {\n    return true;\n  }\n\n  const anchorParent = anchorNode.getParent();\n  return $isCodeNode(anchorParent) && anchorParent.is(focusNode.getParent());\n}\n\nfunction $getCodeLines(selection) {\n  const nodes = selection.getNodes();\n  const lines = [[]];\n\n  if (nodes.length === 1 && $isCodeNode(nodes[0])) {\n    return lines;\n  }\n\n  let lastLine = lines[0];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (!($isCodeHighlightNode(node) || lexical.$isTabNode(node) || lexical.$isLineBreakNode(node))) {\n      throw Error(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);\n    }\n\n    if (lexical.$isLineBreakNode(node)) {\n      if (i !== 0 && lastLine.length > 0) {\n        lastLine = [];\n        lines.push(lastLine);\n      }\n    } else {\n      lastLine.push(node);\n    }\n  }\n\n  return lines;\n}\n\nfunction handleTab(shiftKey) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return null;\n  }\n\n  const indentOrOutdent = !shiftKey ? lexical.INDENT_CONTENT_COMMAND : lexical.OUTDENT_CONTENT_COMMAND;\n  const tabOrOutdent = !shiftKey ? lexical.INSERT_TAB_COMMAND : lexical.OUTDENT_CONTENT_COMMAND; // 1. If multiple lines selected: indent/outdent\n\n  const codeLines = $getCodeLines(selection);\n\n  if (codeLines.length > 1) {\n    return indentOrOutdent;\n  } // 2. If entire line selected: indent/outdent\n\n\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || lexical.$isTabNode(firstNode) || lexical.$isLineBreakNode(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or TabNode`);\n  }\n\n  if ($isCodeNode(firstNode)) {\n    return indentOrOutdent;\n  }\n\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n  const lastOfLine = getLastCodeNodeOfLine(firstNode);\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  let selectionFirst;\n  let selectionLast;\n\n  if (focus.isBefore(anchor)) {\n    selectionFirst = focus;\n    selectionLast = anchor;\n  } else {\n    selectionFirst = anchor;\n    selectionLast = focus;\n  }\n\n  if (firstOfLine !== null && lastOfLine !== null && selectionFirst.key === firstOfLine.getKey() && selectionFirst.offset === 0 && selectionLast.key === lastOfLine.getKey() && selectionLast.offset === lastOfLine.getTextContentSize()) {\n    return indentOrOutdent;\n  } // 3. Else: tab/outdent\n\n\n  return tabOrOutdent;\n}\n\nfunction handleMultilineIndent(type) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return false;\n  }\n\n  const codeLines = $getCodeLines(selection);\n  const codeLinesLength = codeLines.length; // Multiple lines selection\n\n  if (codeLines.length > 1) {\n    for (let i = 0; i < codeLinesLength; i++) {\n      const line = codeLines[i];\n\n      if (line.length > 0) {\n        let firstOfLine = line[0]; // First and last lines might not be complete\n\n        if (i === 0) {\n          firstOfLine = getFirstCodeNodeOfLine(firstOfLine);\n        }\n\n        if (firstOfLine !== null) {\n          if (type === lexical.INDENT_CONTENT_COMMAND) {\n            firstOfLine.insertBefore(lexical.$createTabNode());\n          } else if (lexical.$isTabNode(firstOfLine)) {\n            firstOfLine.remove();\n          }\n        }\n      }\n    }\n\n    return true;\n  } // Just one line\n\n\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || lexical.$isTabNode(firstNode) || lexical.$isLineBreakNode(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or CodeTabNode`);\n  }\n\n  if ($isCodeNode(firstNode)) {\n    // CodeNode is empty\n    if (type === lexical.INDENT_CONTENT_COMMAND) {\n      selection.insertNodes([lexical.$createTabNode()]);\n    }\n\n    return true;\n  }\n\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n\n  if (!(firstOfLine !== null)) {\n    throw Error(`Expected getFirstCodeNodeOfLine to return a valid Code Node`);\n  }\n\n  if (type === lexical.INDENT_CONTENT_COMMAND) {\n    if (lexical.$isLineBreakNode(firstOfLine)) {\n      firstOfLine.insertAfter(lexical.$createTabNode());\n    } else {\n      firstOfLine.insertBefore(lexical.$createTabNode());\n    }\n  } else if (lexical.$isTabNode(firstOfLine)) {\n    firstOfLine.remove();\n  }\n\n  return true;\n}\n\nfunction handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  } // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === lexical.KEY_ARROW_UP_COMMAND; // Ensure the selection is within the codeblock\n\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || lexical.$isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || lexical.$isTabNode(focusNode))) {\n    return false;\n  }\n\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // sibling thats can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  let start;\n  let end;\n\n  if (anchorNode.isBefore(focusNode)) {\n    start = getFirstCodeNodeOfLine(anchorNode);\n    end = getLastCodeNodeOfLine(focusNode);\n  } else {\n    start = getFirstCodeNodeOfLine(focusNode);\n    end = getLastCodeNodeOfLine(anchorNode);\n  }\n\n  if (start == null || end == null) {\n    return false;\n  }\n\n  const range = start.getNodesBetween(end);\n\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n\n    if (!$isCodeHighlightNode(node) && !lexical.$isTabNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  } // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n\n\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n\n  if (!lexical.$isLineBreakNode(linebreak)) {\n    return true;\n  }\n\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n\n  if (sibling == null) {\n    return true;\n  }\n\n  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || lexical.$isTabNode(sibling) || lexical.$isLineBreakNode(sibling) ? arrowIsUp ? getFirstCodeNodeOfLine(sibling) : getLastCodeNodeOfLine(sibling) : null;\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n\n  if (type === lexical.KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\n\nfunction handleMoveTo(type, event) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === lexical.MOVE_TO_START;\n\n  if (!($isCodeHighlightNode(anchorNode) || lexical.$isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || lexical.$isTabNode(focusNode))) {\n    return false;\n  }\n\n  if (isMoveToStart) {\n    const start = getStartOfCodeInLine(focusNode, focus.offset);\n\n    if (start !== null) {\n      const {\n        node,\n        offset\n      } = start;\n\n      if (lexical.$isLineBreakNode(node)) {\n        node.selectNext(0, 0);\n      } else {\n        selection.setTextNodeRange(node, offset, node, offset);\n      }\n    } else {\n      focusNode.getParentOrThrow().selectStart();\n    }\n  } else {\n    const node = getEndOfCodeInLine(focusNode);\n    node.select();\n  }\n\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\n\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n\n  return utils.mergeRegister(editor.registerMutationListener(CodeNode, mutations => {\n    editor.update(() => {\n      for (const [key, type] of mutations) {\n        if (type !== 'destroyed') {\n          const node = lexical.$getNodeByKey(key);\n\n          if (node !== null) {\n            updateCodeGutter(node, editor);\n          }\n        }\n      }\n    });\n  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(lexical.TextNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n    const command = handleTab(event.shiftKey);\n\n    if (command === null) {\n      return false;\n    }\n\n    event.preventDefault();\n    editor.dispatchCommand(command, undefined);\n    return true;\n  }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INSERT_TAB_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n\n    lexical.$insertNodes([lexical.$createTabNode()]);\n    return true;\n  }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.INDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.OUTDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_UP_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_DOWN_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_END, payload => handleMoveTo(lexical.MOVE_TO_END, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_START, payload => handleMoveTo(lexical.MOVE_TO_START, payload), lexical.COMMAND_PRIORITY_LOW));\n}\n\nexports.$createCodeHighlightNode = $createCodeHighlightNode;\nexports.$createCodeNode = $createCodeNode;\nexports.$isCodeHighlightNode = $isCodeHighlightNode;\nexports.$isCodeNode = $isCodeNode;\nexports.CODE_LANGUAGE_FRIENDLY_NAME_MAP = CODE_LANGUAGE_FRIENDLY_NAME_MAP;\nexports.CODE_LANGUAGE_MAP = CODE_LANGUAGE_MAP;\nexports.CodeHighlightNode = CodeHighlightNode;\nexports.CodeNode = CodeNode;\nexports.DEFAULT_CODE_LANGUAGE = DEFAULT_CODE_LANGUAGE;\nexports.PrismTokenizer = PrismTokenizer;\nexports.getCodeLanguages = getCodeLanguages;\nexports.getDefaultCodeLanguage = getDefaultCodeLanguage;\nexports.getEndOfCodeInLine = getEndOfCodeInLine;\nexports.getFirstCodeNodeOfLine = getFirstCodeNodeOfLine;\nexports.getLanguageFriendlyName = getLanguageFriendlyName;\nexports.getLastCodeNodeOfLine = getLastCodeNodeOfLine;\nexports.getStartOfCodeInLine = getStartOfCodeInLine;\nexports.normalizeCodeLang = normalizeCodeLang;\nexports.registerCodeHighlighting = registerCodeHighlighting;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}