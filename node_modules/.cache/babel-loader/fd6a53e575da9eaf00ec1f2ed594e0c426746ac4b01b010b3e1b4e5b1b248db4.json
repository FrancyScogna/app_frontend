{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/** @module @lexical/link */\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n/** @noInheritDoc */\n\nclass LinkNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url, attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.sanitizeUrl(this.__url);\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n    if (this.__title !== null) {\n      element.title = this.__title;\n    }\n    utils.addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateDOM(prevNode, anchor, config) {\n    const url = this.__url;\n    const target = this.__target;\n    const rel = this.__rel;\n    const title = this.__title;\n    if (url !== prevNode.__url) {\n      anchor.href = url;\n    }\n    if (target !== prevNode.__target) {\n      if (target) {\n        anchor.target = target;\n      } else {\n        anchor.removeAttribute('target');\n      }\n    }\n    if (rel !== prevNode.__rel) {\n      if (rel) {\n        anchor.rel = rel;\n      } else {\n        anchor.removeAttribute('rel');\n      }\n    }\n    if (title !== prevNode.__title) {\n      if (title) {\n        anchor.title = title;\n      } else {\n        anchor.removeAttribute('title');\n      }\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  sanitizeUrl(url) {\n    try {\n      const parsedUrl = new URL(url); // eslint-disable-next-line no-script-url\n\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      type: 'link',\n      url: this.getURL(),\n      version: 1\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createLinkNode(this.__url, {\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n}\nfunction convertAnchorElement(domNode) {\n  let node = null;\n  if (utils.isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '') {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes { target, rel, title }\n * @returns The LinkNode.\n */\n\nfunction $createLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new LinkNode(url, attributes));\n}\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\n\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  static importJSON(serializedNode) {\n    const node = $createAutoLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'autolink',\n      version: 1\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        rel: this._rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. { target, rel, title }\n * @returns The LinkNode.\n */\n\nfunction $createAutoLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\n\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = lexical.createCommand('TOGGLE_LINK_COMMAND');\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. { target, rel, title }\n */\n\nfunction toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parent.insertBefore(children[i]);\n        }\n        parent.remove();\n      }\n    });\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0]; // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n\n      const linkNode = $isLinkNode(firstNode) ? firstNode : $getLinkAncestor(firstNode);\n      if (linkNode !== null) {\n        linkNode.setURL(url);\n        if (target !== undefined) {\n          linkNode.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n    }\n    let prevParent = null;\n    let linkNode = null;\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if (parent === linkNode || parent === null || lexical.$isElementNode(node) && !node.isInline()) {\n        return;\n      }\n      if ($isLinkNode(parent)) {\n        linkNode = parent;\n        parent.setURL(url);\n        if (target !== undefined) {\n          parent.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n      if (!parent.is(prevParent)) {\n        prevParent = parent;\n        linkNode = $createLinkNode(url, {\n          rel,\n          target\n        });\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode);\n          } else {\n            parent.insertAfter(linkNode);\n          }\n        } else {\n          node.insertBefore(linkNode);\n        }\n      }\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return;\n        }\n        if (linkNode !== null) {\n          const children = node.getChildren();\n          for (let i = 0; i < children.length; i++) {\n            linkNode.append(children[i]);\n          }\n        }\n        node.remove();\n        return;\n      }\n      if (linkNode !== null) {\n        linkNode.append(node);\n      }\n    });\n  }\n}\nfunction $getLinkAncestor(node) {\n  return $getAncestor(node, $isLinkNode);\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && (parent = parent.getParent()) !== null && !predicate(parent));\n  return parent;\n}\nexports.$createAutoLinkNode = $createAutoLinkNode;\nexports.$createLinkNode = $createLinkNode;\nexports.$isAutoLinkNode = $isAutoLinkNode;\nexports.$isLinkNode = $isLinkNode;\nexports.AutoLinkNode = AutoLinkNode;\nexports.LinkNode = LinkNode;\nexports.TOGGLE_LINK_COMMAND = TOGGLE_LINK_COMMAND;\nexports.toggleLink = toggleLink;","map":{"version":3,"names":["utils","require","lexical","SUPPORTED_URL_PROTOCOLS","Set","LinkNode","ElementNode","getType","clone","node","__url","rel","__rel","target","__target","title","__title","__key","constructor","url","attributes","key","createDOM","config","element","document","createElement","href","sanitizeUrl","addClassNamesToElement","theme","link","updateDOM","prevNode","anchor","removeAttribute","importDOM","a","conversion","convertAnchorElement","priority","importJSON","serializedNode","$createLinkNode","setFormat","format","setIndent","indent","setDirection","direction","parsedUrl","URL","has","protocol","exportJSON","getRel","getTarget","getTitle","type","getURL","version","getLatest","setURL","writable","getWritable","setTarget","setRel","setTitle","insertNewAfter","selection","restoreSelection","getParentOrThrow","$isElementNode","linkNode","append","canInsertTextBefore","canInsertTextAfter","canBeEmpty","isInline","extractWithChild","child","destination","$isRangeSelection","anchorNode","getNode","focusNode","focus","isParentOf","getTextContent","length","domNode","isHTMLAnchorElement","content","textContent","getAttribute","$applyNodeReplacement","$isLinkNode","AutoLinkNode","$createAutoLinkNode","_rel","$isAutoLinkNode","TOGGLE_LINK_COMMAND","createCommand","toggleLink","undefined","$getSelection","nodes","extract","forEach","parent","getParent","children","getChildren","i","insertBefore","remove","firstNode","$getLinkAncestor","prevParent","is","getPreviousSibling","insertAfter","$getAncestor","predicate","exports"],"sources":["C:/Users/franc/Desktop/Progetto/Frontend/app_frontend/node_modules/@lexical/link/LexicalLink.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/** @module @lexical/link */\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n/** @noInheritDoc */\n\nclass LinkNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'link';\n  }\n\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n\n  constructor(url, attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.sanitizeUrl(this.__url);\n\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n\n    if (this.__title !== null) {\n      element.title = this.__title;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n\n  updateDOM(prevNode, anchor, config) {\n    const url = this.__url;\n    const target = this.__target;\n    const rel = this.__rel;\n    const title = this.__title;\n\n    if (url !== prevNode.__url) {\n      anchor.href = url;\n    }\n\n    if (target !== prevNode.__target) {\n      if (target) {\n        anchor.target = target;\n      } else {\n        anchor.removeAttribute('target');\n      }\n    }\n\n    if (rel !== prevNode.__rel) {\n      if (rel) {\n        anchor.rel = rel;\n      } else {\n        anchor.removeAttribute('rel');\n      }\n    }\n\n    if (title !== prevNode.__title) {\n      if (title) {\n        anchor.title = title;\n      } else {\n        anchor.removeAttribute('title');\n      }\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  sanitizeUrl(url) {\n    try {\n      const parsedUrl = new URL(url); // eslint-disable-next-line no-script-url\n\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch {\n      return url;\n    }\n\n    return url;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      type: 'link',\n      url: this.getURL(),\n      version: 1\n    };\n  }\n\n  getURL() {\n    return this.getLatest().__url;\n  }\n\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n\n  getTarget() {\n    return this.getLatest().__target;\n  }\n\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n  }\n\n  getRel() {\n    return this.getLatest().__rel;\n  }\n\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n  }\n\n  getTitle() {\n    return this.getLatest().__title;\n  }\n\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n  }\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createLinkNode(this.__url, {\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n\n    return null;\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  canInsertTextAfter() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  isInline() {\n    return true;\n  }\n\n  extractWithChild(child, selection, destination) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n\n}\n\nfunction convertAnchorElement(domNode) {\n  let node = null;\n\n  if (utils.isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n\n    if (content !== null && content !== '') {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n\n  return {\n    node\n  };\n}\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes { target, rel, title }\n * @returns The LinkNode.\n */\n\n\nfunction $createLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new LinkNode(url, attributes));\n}\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\n\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  static getType() {\n    return 'autolink';\n  }\n\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createAutoLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'autolink',\n      version: 1\n    };\n  }\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        rel: this._rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n\n    return null;\n  }\n\n}\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. { target, rel, title }\n * @returns The LinkNode.\n */\n\nfunction $createAutoLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\n\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = lexical.createCommand('TOGGLE_LINK_COMMAND');\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. { target, rel, title }\n */\n\nfunction toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n\n  const nodes = selection.extract();\n\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parent = node.getParent();\n\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren();\n\n        for (let i = 0; i < children.length; i++) {\n          parent.insertBefore(children[i]);\n        }\n\n        parent.remove();\n      }\n    });\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0]; // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n\n      const linkNode = $isLinkNode(firstNode) ? firstNode : $getLinkAncestor(firstNode);\n\n      if (linkNode !== null) {\n        linkNode.setURL(url);\n\n        if (target !== undefined) {\n          linkNode.setTarget(target);\n        }\n\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n\n        return;\n      }\n    }\n\n    let prevParent = null;\n    let linkNode = null;\n    nodes.forEach(node => {\n      const parent = node.getParent();\n\n      if (parent === linkNode || parent === null || lexical.$isElementNode(node) && !node.isInline()) {\n        return;\n      }\n\n      if ($isLinkNode(parent)) {\n        linkNode = parent;\n        parent.setURL(url);\n\n        if (target !== undefined) {\n          parent.setTarget(target);\n        }\n\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n\n        return;\n      }\n\n      if (!parent.is(prevParent)) {\n        prevParent = parent;\n        linkNode = $createLinkNode(url, {\n          rel,\n          target\n        });\n\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode);\n          } else {\n            parent.insertAfter(linkNode);\n          }\n        } else {\n          node.insertBefore(linkNode);\n        }\n      }\n\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return;\n        }\n\n        if (linkNode !== null) {\n          const children = node.getChildren();\n\n          for (let i = 0; i < children.length; i++) {\n            linkNode.append(children[i]);\n          }\n        }\n\n        node.remove();\n        return;\n      }\n\n      if (linkNode !== null) {\n        linkNode.append(node);\n      }\n    });\n  }\n}\n\nfunction $getLinkAncestor(node) {\n  return $getAncestor(node, $isLinkNode);\n}\n\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n\n  while (parent !== null && (parent = parent.getParent()) !== null && !predicate(parent));\n\n  return parent;\n}\n\nexports.$createAutoLinkNode = $createAutoLinkNode;\nexports.$createLinkNode = $createLinkNode;\nexports.$isAutoLinkNode = $isAutoLinkNode;\nexports.$isLinkNode = $isLinkNode;\nexports.AutoLinkNode = AutoLinkNode;\nexports.LinkNode = LinkNode;\nexports.TOGGLE_LINK_COMMAND = TOGGLE_LINK_COMMAND;\nexports.toggleLink = toggleLink;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}