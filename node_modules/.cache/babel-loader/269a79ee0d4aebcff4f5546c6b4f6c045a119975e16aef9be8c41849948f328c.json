{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n\n/** @noInheritDoc */\nclass TableCellNode extends lexical.DEPRECATED_GridCellNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    const cellNode = new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n    cellNode.__rowSpan = node.__rowSpan;\n    cellNode.__backgroundColor = node.__backgroundColor;\n    return cellNode;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const colSpan = serializedNode.colSpan || 1;\n    const rowSpan = serializedNode.rowSpan || 1;\n    const cellNode = $createTableCellNode(serializedNode.headerState, colSpan, serializedNode.width || undefined);\n    cellNode.__rowSpan = rowSpan;\n    cellNode.__backgroundColor = serializedNode.backgroundColor || null;\n    return cellNode;\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(colSpan, key);\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    utils.addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element) {\n      const element_ = element;\n      const maxWidth = 700;\n      const colCount = this.getParentOrThrow().getChildrenSize();\n      element_.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element_.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n      element_.style.width = `${this.getWidth() || Math.max(90, maxWidth / colCount)}px`;\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n      const backgroundColor = this.getBackgroundColor();\n      if (backgroundColor !== null) {\n        element_.style.backgroundColor = backgroundColor;\n      } else if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      headerState: this.__headerState,\n      type: 'tablecell',\n      width: this.getWidth()\n    };\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState) {\n    const self = this.getWritable();\n    self.__headerState = headerState;\n    return this.__headerState;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return this.__width;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    this.getWritable().__backgroundColor = newBackgroundColor;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  return {\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !lexical.$isElementNode(lexicalNode)) {\n        const paragraphNode = lexical.$createParagraphNode();\n        if (lexical.$isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\n  return lexical.$applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends lexical.DEPRECATED_GridRowNode {\n  /** @internal */\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'tablerow',\n      version: 1\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    utils.addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return lexical.$applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\nclass TableSelection {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.grid = {\n      cells: [],\n      columns: 0,\n      rows: 0\n    };\n    this.gridSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTableGrid();\n  }\n  getGrid() {\n    return this.grid;\n  }\n  removeListeners() {\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n  }\n  trackTableGrid() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n        this.grid = getTableGrid(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      this.grid = getTableGrid(tableElement);\n      observer.observe(tableElement, {\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n  clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.gridSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.enableHighlightStyle();\n    editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const grid = getTableGrid(tableElement);\n      $updateDOMForSelection(editor, grid, null);\n      lexical.$setSelection(null);\n      editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  enableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      utils.removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n  disableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      utils.addClassNamesToElement(tableElement, editor._config.theme.tableSelection);\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n  updateTableGridSelection(selection) {\n    if (selection != null && selection.gridKey === this.tableNodeKey) {\n      const editor = this.editor;\n      this.gridSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(editor, this.grid, this.gridSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    }\n  }\n  setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(editor._window); // Collapse the selection\n\n        if (domSelection) {\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\n        }\n      }\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n      this.focusX = cellX;\n      this.focusY = cellY;\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n        if (this.gridSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode)) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.gridSelection = this.gridSelection.clone() || lexical.DEPRECATED_$createGridSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.gridSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\n          lexical.$setSelection(this.gridSelection);\n          editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n          $updateDOMForSelection(editor, this.grid, this.gridSelection);\n        }\n      }\n    });\n  }\n  setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    this.editor.update(() => {\n      const anchorTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.gridSelection = lexical.DEPRECATED_$createGridSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = lexical.$getSelection();\n      if (!lexical.DEPRECATED_$isGridSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const formatSelection = lexical.$createRangeSelection();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      selection.getNodes().forEach(cellNode => {\n        if ($isTableCellNode(cellNode) && cellNode.getTextContentSize() !== 0) {\n          anchor.set(cellNode.getKey(), 0, 'element');\n          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n          formatSelection.formatText(type);\n        }\n      });\n      lexical.$setSelection(selection);\n      this.editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  clearText() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const selection = lexical.$getSelection();\n      if (!lexical.DEPRECATED_$isGridSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n      if (selectedNodes.length === this.grid.columns * this.grid.rows) {\n        tableNode.selectPrevious(); // Delete entire table\n\n        tableNode.remove();\n        const rootNode = lexical.$getRoot();\n        rootNode.selectStart();\n        return;\n      }\n      selectedNodes.forEach(cellNode => {\n        if (lexical.$isElementNode(cellNode)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          const textNode = lexical.$createTextNode();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(editor, this.grid, null);\n      lexical.$setSelection(null);\n      editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nfunction applyTableHandlers(tableNode, tableElement, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n  const tableSelection = new TableSelection(editor, tableNode.getKey());\n  const editorWindow = editor._window || window;\n  attachTableSelectionToTableElement(tableElement, tableSelection);\n  tableElement.addEventListener('mousedown', event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n      if (!editorWindow) {\n        return;\n      }\n      const anchorCell = getCellFromTarget(event.target);\n      if (anchorCell !== null) {\n        stopEvent(event);\n        tableSelection.setAnchorCellForSelection(anchorCell);\n      }\n      const onMouseUp = () => {\n        editorWindow.removeEventListener('mouseup', onMouseUp);\n        editorWindow.removeEventListener('mousemove', onMouseMove);\n      };\n      const onMouseMove = moveEvent => {\n        const focusCell = getCellFromTarget(moveEvent.target);\n        if (focusCell !== null && (tableSelection.anchorX !== focusCell.x || tableSelection.anchorY !== focusCell.y)) {\n          moveEvent.preventDefault();\n          tableSelection.setFocusCellForSelection(focusCell);\n        }\n      };\n      editorWindow.addEventListener('mouseup', onMouseUp);\n      editorWindow.addEventListener('mousemove', onMouseMove);\n    }, 0);\n  }); // Clear selection when clicking outside of dom.\n\n  const mouseDownCallback = event => {\n    if (event.button !== 0) {\n      return;\n    }\n    editor.update(() => {\n      const selection = lexical.$getSelection();\n      const target = event.target;\n      if (lexical.DEPRECATED_$isGridSelection(selection) && selection.gridKey === tableSelection.tableNodeKey && rootElement.contains(target)) {\n        tableSelection.clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('mousedown', mouseDownCallback);\n  tableSelection.listenersToRemove.add(() => editorWindow.removeEventListener('mousedown', mouseDownCallback));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => $handleArrowKey(editor, event, 'down', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => $handleArrowKey(editor, event, 'up', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => $handleArrowKey(editor, event, 'backward', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => $handleArrowKey(editor, event, 'forward', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      const focusCellNode = utils.$findMatchingParent(selection.focus.getNode(), $isTableCellNode);\n      if ($isTableCellNode(focusCellNode)) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = lexical.$getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.clearText();\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableSelection.clearText();\n        return true;\n      }\n      const nearestElementNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && utils.$findMatchingParent(nearestElementNode, n => lexical.$isElementNode(n) && $isTableCellNode(n.getParent()));\n      if (!lexical.$isElementNode(topLevelCellElementNode) || !lexical.$isElementNode(nearestElementNode)) {\n        return false;\n      }\n      if (command === lexical.DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n      if (command === lexical.DELETE_CHARACTER_COMMAND || command === lexical.DELETE_WORD_COMMAND) {\n        if (selection.isCollapsed() && selection.anchor.offset === 0) {\n          if (nearestElementNode !== topLevelCellElementNode) {\n            const children = nearestElementNode.getChildren();\n            const newParagraphNode = lexical.$createParagraphNode();\n            children.forEach(child => newParagraphNode.append(child));\n            nearestElementNode.replace(newParagraphNode);\n            nearestElementNode.getWritable().__parent = tableCellNode.getKey();\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  };\n  [lexical.DELETE_WORD_COMMAND, lexical.DELETE_LINE_COMMAND, lexical.DELETE_CHARACTER_COMMAND].forEach(command => {\n    tableSelection.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), lexical.COMMAND_PRIORITY_CRITICAL));\n  });\n  const deleteCellHandler = event => {\n    const selection = lexical.$getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      event.preventDefault();\n      event.stopPropagation();\n      tableSelection.clearText();\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  };\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, deleteCellHandler, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_DELETE_COMMAND, deleteCellHandler, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.formatCells(payload);\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.clearHighlight();\n      return false;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n      const selection = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null) {\n        return false;\n      }\n      stopEvent(event);\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n      selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL));\n  }\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, lexical.COMMAND_PRIORITY_HIGH));\n  function getCellFromCellNode(tableCellNode) {\n    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n    return tableNode.getCellFromCordsOrThrow(currentCords.x, currentCords.y, tableSelection.grid);\n  }\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.SELECTION_CHANGE_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    const prevSelection = lexical.$getPreviousSelection();\n    if (lexical.$isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode(); // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = anchorCellNode && tableNode.is($findTableNode(anchorCellNode));\n      const isFocusInside = focusCellNode && tableNode.is($findTableNode(focusCellNode));\n      const isPartialyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartialyWithinTable) {\n        const newSelection = selection.clone();\n        newSelection.focus.set(tableNode.getKey(), isBackward ? 0 : tableNode.getChildrenSize(), 'element');\n        lexical.$setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableSelection);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into grid selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableSelection.setAnchorCellForSelection(getCellFromCellNode(anchorCellNode));\n          tableSelection.setFocusCellForSelection(getCellFromCellNode(focusCellNode), true);\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && (lexical.DEPRECATED_$isGridSelection(selection) || lexical.DEPRECATED_$isGridSelection(prevSelection)) && tableSelection.gridSelection && !tableSelection.gridSelection.is(prevSelection)) {\n      if (lexical.DEPRECATED_$isGridSelection(selection) && selection.gridKey === tableSelection.tableNodeKey) {\n        tableSelection.updateTableGridSelection(selection);\n      } else if (!lexical.DEPRECATED_$isGridSelection(selection) && lexical.DEPRECATED_$isGridSelection(prevSelection) && prevSelection.gridKey === tableSelection.tableNodeKey) {\n        tableSelection.updateTableGridSelection(null);\n      }\n      return false;\n    }\n    if (tableSelection.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableSelection);\n    } else if (!tableSelection.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableSelection);\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  return tableSelection;\n}\nfunction attachTableSelectionToTableElement(tableElement, tableSelection) {\n  tableElement[LEXICAL_ELEMENT_KEY] = tableSelection;\n}\nfunction getTableSelectionFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY];\n}\nfunction getCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getTableGrid(tableElement) {\n  const cells = [];\n  const grid = {\n    cells,\n    columns: 0,\n    rows: 0\n  };\n  let currentNode = tableElement.firstChild;\n  let x = 0;\n  let y = 0;\n  cells.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      }; // @ts-expect-error: internal field\n\n      currentNode._cell = cell;\n      let row = cells[y];\n      if (row === undefined) {\n        row = cells[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, grid, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachGridCell(grid, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachGridCell(grid, cb) {\n  const {\n    cells\n  } = grid;\n  for (let y = 0; y < cells.length; y++) {\n    const row = cells[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachGridCell(tableSelection.grid, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.enableHighlightStyle();\n  $forEachGridCell(tableSelection.grid, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nconst selectGridNodeInDirection = (tableSelection, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableSelection.grid.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableSelection.grid), isForward);\n      } else {\n        if (y !== (isForward ? tableSelection.grid.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableSelection.grid.columns - 1, y + (isForward ? 1 : -1), tableSelection.grid), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableSelection.grid), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableSelection.grid.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableSelection.grid), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nconst adjustFocusNodeInDirection = (tableSelection, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableSelection.grid.columns - 1 : 0)) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableSelection.grid));\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x, y - 1, tableSelection.grid));\n        return true;\n      } else {\n        return false;\n      }\n    case 'down':\n      if (y !== tableSelection.grid.rows - 1) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x, y + 1, tableSelection.grid));\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n};\nfunction $isSelectionInTable(selection, tableNode) {\n  if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nconst BROWSER_BLUE_RGB = '172,206,247';\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const node = lexical.$getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\n  } else {\n    element.style.setProperty('background-image', `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`);\n  }\n  element.style.setProperty('caret-color', 'transparent');\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = lexical.$getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.removeProperty('background-color');\n  }\n  element.style.removeProperty('background-image');\n  element.style.removeProperty('caret-color');\n}\nfunction $findCellNode(node) {\n  const cellNode = utils.$findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = utils.$findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableSelection) {\n  const selection = lexical.$getSelection();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    return false;\n  }\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed()) {\n    // Horizontal move between cels seem to work well without interruption\n    // so just exit early, and handle vertical moves\n    if (direction === 'backward' || direction === 'forward') {\n      return false;\n    }\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = utils.$findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = utils.$findMatchingParent(focus.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n    let edgeSelectionRect;\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = window.getSelection();\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n    if (edgeChild == null) {\n      return false;\n    }\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n    if (edgeChildDOM == null) {\n      return false;\n    }\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableSelection.grid);\n      if (event.shiftKey) {\n        const cell = tableNode.getCellFromCordsOrThrow(cords.x, cords.y, tableSelection.grid);\n        tableSelection.setAnchorCellForSelection(cell);\n        tableSelection.setFocusCellForSelection(cell, true);\n      } else {\n        return selectGridNodeInDirection(tableSelection, tableNode, cords.x, cords.y, direction);\n      }\n      return true;\n    }\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = utils.$findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = utils.$findMatchingParent(focus.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode)) {\n      return false;\n    }\n    stopEvent(event);\n    if (event.shiftKey) {\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, tableSelection.grid);\n      return adjustFocusNodeInDirection(tableSelection, tableNode, cords.x, cords.y, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableNode extends lexical.DEPRECATED_GridNode {\n  /** @internal */\n  static getType() {\n    return 'table';\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(_serializedNode) {\n    return $createTableNode();\n  }\n  constructor(key) {\n    super(key);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'table',\n      version: 1\n    };\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    utils.addClassNamesToElement(tableElement, config.theme.table);\n    return tableElement;\n  }\n  updateDOM() {\n    return false;\n  }\n  exportDOM(editor) {\n    return {\n      ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n          if (utils.isHTMLElement(tableElement)) {\n            tBody.append(...tableElement.children);\n          }\n          const firstRow = this.getFirstChildOrThrow();\n          if (!$isTableRowNode(firstRow)) {\n            throw new Error('Expected to find row node.');\n          }\n          const colCount = firstRow.getChildrenSize();\n          for (let i = 0; i < colCount; i++) {\n            const col = document.createElement('col');\n            colGroup.append(col);\n          }\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  } // TODO 0.10 deprecate\n\n  canExtractContents() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, grid) {\n    const {\n      rows,\n      cells\n    } = grid;\n    for (let y = 0; y < rows; y++) {\n      const row = cells[y];\n      if (row == null) {\n        continue;\n      }\n      const x = row.findIndex(cell => {\n        if (!cell) return;\n        const {\n          elem\n        } = cell;\n        const cellNode = lexical.$getNearestNodeFromDOMNode(elem);\n        return cellNode === tableCellNode;\n      });\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getCellFromCords(x, y, grid) {\n    const {\n      cells\n    } = grid;\n    const row = cells[y];\n    if (row == null) {\n      return null;\n    }\n    const cell = row[x];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getCellFromCordsOrThrow(x, y, grid) {\n    const cell = this.getCellFromCords(x, y, grid);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, grid) {\n    const cell = this.getCellFromCords(x, y, grid);\n    if (cell == null) {\n      return null;\n    }\n    const node = lexical.$getNearestNodeFromDOMNode(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, grid) {\n    const node = this.getCellNodeFromCords(x, y, grid);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $getElementGridForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n  return getTableGrid(tableElement);\n}\nfunction convertTableElement(_domNode) {\n  return {\n    node: $createTableNode()\n  };\n}\nfunction $createTableNode() {\n  return lexical.$applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) headerState |= TableCellHeaderStates.ROW;\n        if (iColumn === 0 && includeHeaders.columns) headerState |= TableCellHeaderStates.COLUMN;\n      } else if (includeHeaders) {\n        if (iRow === 0) headerState |= TableCellHeaderStates.ROW;\n        if (iColumn === 0) headerState |= TableCellHeaderStates.COLUMN;\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = lexical.$createParagraphNode();\n      paragraphNode.append(lexical.$createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, grid) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, grid);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, grid),\n    below: tableNode.getCellNodeFromCords(x, y + 1, grid),\n    left: tableNode.getCellNodeFromCords(x - 1, y, grid),\n    right: tableNode.getCellNodeFromCords(x + 1, y, grid)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, grid) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, grid);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append(lexical.$createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = lexical.$getSelection();\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const focus = selection.focus.getNode();\n  const [focusCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, focusCellMap] = lexical.DEPRECATED_$computeGridMap(grid, focusCell, focusCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  if (insertAfter) {\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n    const focusEndRowMap = gridMap[focusEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\n        newRow.append($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\n    if (!lexical.DEPRECATED_$isGridRowNode(focusEndRowNode)) {\n      throw Error(`focusEndRow is not a GridRowNode`);\n    }\n    focusEndRowNode.insertAfter(newRow);\n  } else {\n    const focusStartRowMap = gridMap[focusStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusStartRowMap[i];\n      if (startRow === focusStartRow) {\n        newRow.append($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\n    if (!lexical.DEPRECATED_$isGridRowNode(focusStartRowNode)) {\n      throw Error(`focusEndRow is not a GridRowNode`);\n    }\n    focusStartRowNode.insertBefore(newRow);\n  }\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, grid) {\n  const tableRows = tableNode.getChildren();\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, grid);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append(lexical.$createParagraphNode());\n        if (shouldInsertAfter) {\n          targetCell.insertAfter(newTableCell);\n        } else {\n          targetCell.insertBefore(newTableCell);\n        }\n      }\n    }\n  }\n  return tableNode;\n}\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = lexical.$getSelection();\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const [focusCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = lexical.DEPRECATED_$computeGridMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!lexical.DEPRECATED_$isGridRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn() {\n    const cell = $createTableCellNode(TableCellHeaderStates.NO_STATUS).append(lexical.$createParagraphNode());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!lexical.DEPRECATED_$isGridRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn());\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn());\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn());\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = lexical.$getSelection();\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const [focusCell] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = lexical.DEPRECATED_$computeGridMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      } // Rows overflowing top have to be trimmed\n\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\n      } // Rows overflowing bottom have to be trimmed and moved to the next row\n\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n        if (column === 0) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          const {\n            cell: previousCell\n          } = nextRow[column - 1];\n          previousCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!lexical.DEPRECATED_$isGridRowNode(rowNode)) {\n      throw Error(`Expected GridNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = lexical.$getSelection();\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const [focusCell] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = lexical.DEPRECATED_$computeGridMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn; // Overflowing left\n\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusRowMap[focusStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (!(firstDescendant !== null)) {\n    throw Error(`Unexpected empty cell`);\n  }\n  firstDescendant.getParentOrThrow().selectStart();\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $unmergeCell() {\n  const selection = lexical.$getSelection();\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    const [map, cellMap] = lexical.DEPRECATED_$computeGridMap(grid, cell, cell);\n    const {\n      startColumn,\n      startRow\n    } = cellMap;\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!lexical.DEPRECATED_$isGridRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = 0; j < colSpan; j++) {\n          $insertFirst(currentRowNode, $createTableCellNode(TableCellHeaderStates.NO_STATUS));\n        }\n      } else {\n        for (let j = 0; j < colSpan; j++) {\n          insertAfterCell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\n\n/** @module @lexical/table */\nconst INSERT_TABLE_COMMAND = lexical.createCommand('INSERT_TABLE_COMMAND');\nexports.$createTableCellNode = $createTableCellNode;\nexports.$createTableNode = $createTableNode;\nexports.$createTableNodeWithDimensions = $createTableNodeWithDimensions;\nexports.$createTableRowNode = $createTableRowNode;\nexports.$deleteTableColumn = $deleteTableColumn;\nexports.$deleteTableColumn__EXPERIMENTAL = $deleteTableColumn__EXPERIMENTAL;\nexports.$deleteTableRow__EXPERIMENTAL = $deleteTableRow__EXPERIMENTAL;\nexports.$getElementGridForTableNode = $getElementGridForTableNode;\nexports.$getTableCellNodeFromLexicalNode = $getTableCellNodeFromLexicalNode;\nexports.$getTableColumnIndexFromTableCellNode = $getTableColumnIndexFromTableCellNode;\nexports.$getTableNodeFromLexicalNodeOrThrow = $getTableNodeFromLexicalNodeOrThrow;\nexports.$getTableRowIndexFromTableCellNode = $getTableRowIndexFromTableCellNode;\nexports.$getTableRowNodeFromTableCellNodeOrThrow = $getTableRowNodeFromTableCellNodeOrThrow;\nexports.$insertTableColumn = $insertTableColumn;\nexports.$insertTableColumn__EXPERIMENTAL = $insertTableColumn__EXPERIMENTAL;\nexports.$insertTableRow = $insertTableRow;\nexports.$insertTableRow__EXPERIMENTAL = $insertTableRow__EXPERIMENTAL;\nexports.$isTableCellNode = $isTableCellNode;\nexports.$isTableNode = $isTableNode;\nexports.$isTableRowNode = $isTableRowNode;\nexports.$removeTableRowAtIndex = $removeTableRowAtIndex;\nexports.$unmergeCell = $unmergeCell;\nexports.INSERT_TABLE_COMMAND = INSERT_TABLE_COMMAND;\nexports.TableCellHeaderStates = TableCellHeaderStates;\nexports.TableCellNode = TableCellNode;\nexports.TableNode = TableNode;\nexports.TableRowNode = TableRowNode;\nexports.TableSelection = TableSelection;\nexports.applyTableHandlers = applyTableHandlers;\nexports.getCellFromTarget = getCellFromTarget;\nexports.getTableSelectionFromTableElement = getTableSelectionFromTableElement;","map":{"version":3,"names":["lexical","require","utils","PIXEL_VALUE_REG_EXP","TableCellHeaderStates","BOTH","COLUMN","NO_STATUS","ROW","TableCellNode","DEPRECATED_GridCellNode","getType","clone","node","cellNode","__headerState","__colSpan","__width","__key","__rowSpan","__backgroundColor","importDOM","td","conversion","convertTableCellNodeElement","priority","th","importJSON","serializedNode","colSpan","rowSpan","$createTableCellNode","headerState","width","undefined","backgroundColor","constructor","key","createDOM","config","element","document","createElement","getTag","style","addClassNamesToElement","theme","tableCell","hasHeader","tableCellHeader","exportDOM","editor","element_","maxWidth","colCount","getParentOrThrow","getChildrenSize","border","getWidth","Math","max","verticalAlign","textAlign","getBackgroundColor","exportJSON","type","setHeaderStyles","self","getWritable","getHeaderStyles","getLatest","setWidth","setBackgroundColor","newBackgroundColor","toggleHeaderStyle","headerStateToToggle","hasHeaderState","updateDOM","prevNode","isShadowRoot","collapseAtStart","canBeEmpty","canIndent","domNode","domNode_","nodeName","toLowerCase","test","parseFloat","tableCellNode","forChild","lexicalNode","parentLexicalNode","$isTableCellNode","$isElementNode","paragraphNode","$createParagraphNode","$isLineBreakNode","getTextContent","append","$applyNodeReplacement","TableRowNode","DEPRECATED_GridRowNode","__height","tr","convertTableRowElement","$createTableRowNode","height","version","tableRow","setHeight","getHeight","$isTableRowNode","CAN_USE_DOM","window","getDOMSelection","targetWindow","getSelection","TableSelection","tableNodeKey","isHighlightingCells","anchorX","anchorY","focusX","focusY","listenersToRemove","Set","grid","cells","columns","rows","gridSelection","anchorCellNodeKey","focusCellNodeKey","anchorCell","focusCell","hasHijackedSelectionStyles","trackTableGrid","getGrid","removeListeners","Array","from","forEach","removeListener","observer","MutationObserver","records","update","gridNeedsRedraw","i","length","record","target","tableElement","getElementByKey","Error","getTableGrid","observe","childList","subtree","clearHighlight","enableHighlightStyle","tableNode","$getNodeByKey","$isTableNode","$updateDOMForSelection","$setSelection","dispatchCommand","SELECTION_CHANGE_COMMAND","removeClassNamesFromElement","_config","tableSelection","classList","remove","disableHighlightStyle","updateTableGridSelection","selection","gridKey","setFocusCellForSelection","cell","ignoreStart","cellX","x","cellY","y","domSelection","_window","setBaseAndExtent","elem","focusTableCellNode","$getNearestNodeFromDOMNode","focusNodeKey","getKey","DEPRECATED_$createGridSelection","set","setAnchorCellForSelection","anchorTableCellNode","anchorNodeKey","formatCells","$getSelection","DEPRECATED_$isGridSelection","formatSelection","$createRangeSelection","anchor","focus","getNodes","getTextContentSize","formatText","clearText","selectedNodes","filter","selectPrevious","rootNode","$getRoot","selectStart","textNode","$createTextNode","getChildren","child","LEXICAL_ELEMENT_KEY","applyTableHandlers","hasTabHandler","rootElement","getRootElement","editorWindow","attachTableSelectionToTableElement","addEventListener","event","setTimeout","button","getCellFromTarget","stopEvent","onMouseUp","removeEventListener","onMouseMove","moveEvent","preventDefault","mouseDownCallback","contains","add","registerCommand","KEY_ARROW_DOWN_COMMAND","$handleArrowKey","COMMAND_PRIORITY_HIGH","KEY_ARROW_UP_COMMAND","KEY_ARROW_LEFT_COMMAND","KEY_ARROW_RIGHT_COMMAND","KEY_ESCAPE_COMMAND","focusCellNode","$findMatchingParent","getNode","selectEnd","deleteTextHandler","command","$isSelectionInTable","$isRangeSelection","n","anchorNode","focusNode","isAnchorInside","isParentOf","isFocusInside","selectionContainsPartialTable","nearestElementNode","topLevelCellElementNode","getParent","DELETE_LINE_COMMAND","getPreviousSibling","DELETE_CHARACTER_COMMAND","DELETE_WORD_COMMAND","isCollapsed","offset","children","newParagraphNode","replace","__parent","COMMAND_PRIORITY_CRITICAL","deleteCellHandler","stopPropagation","KEY_BACKSPACE_COMMAND","KEY_DELETE_COMMAND","FORMAT_TEXT_COMMAND","payload","CONTROLLED_TEXT_INSERTION_COMMAND","KEY_TAB_COMMAND","$findCellNode","currentCords","getCordsFromCellNode","selectGridNodeInDirection","shiftKey","FOCUS_COMMAND","isSelected","getCellFromCellNode","getCellFromCordsOrThrow","prevSelection","$getPreviousSelection","anchorCellNode","is","$findTableNode","isPartialyWithinTable","isWithinTable","isBackward","newSelection","$addHighlightStyleToTable","$removeHighlightStyleToTable","getTableSelectionFromTableElement","currentNode","_cell","parentNode","firstChild","nodeMame","hasBackgroundColor","highlighted","row","sibling","nextSibling","parent","parentSibling","selectedCellNodes","$forEachGridCell","has","$addHighlightToDOM","$removeHighlightFromDOM","getAttribute","removeAttribute","cb","direction","isForward","selectTableCellNode","getCellNodeFromCordsOrThrow","selectNext","adjustFocusNodeInDirection","fromStart","BROWSER_BLUE_RGB","setProperty","removeProperty","anchorCellDom","anchorDOM","edgeSelectionRect","getBoundingClientRect","rangeCount","range","getRangeAt","edgeChild","getFirstChild","getLastChild","edgeChildDOM","edgeRect","isExiting","top","bottom","cords","stopImmediatePropagation","TableNode","DEPRECATED_GridNode","table","_node","convertTableElement","_serializedNode","$createTableNode","after","newElement","cloneNode","colGroup","tBody","isHTMLElement","firstRow","getFirstChildOrThrow","col","replaceChildren","canExtractContents","findIndex","getCellFromCords","getCellNodeFromCords","canSelectBefore","$getElementGridForTableNode","_domNode","$createTableNodeWithDimensions","rowCount","columnCount","includeHeaders","iRow","tableRowNode","iColumn","$getTableCellNodeFromLexicalNode","startingNode","$getTableRowNodeFromTableCellNodeOrThrow","$getTableNodeFromLexicalNodeOrThrow","$getTableRowIndexFromTableCellNode","$getTableColumnIndexFromTableCellNode","$getTableCellSiblingsFromTableCellNode","above","below","left","right","$removeTableRowAtIndex","indexToDelete","tableRows","targetRowNode","$insertTableRow","targetIndex","shouldInsertAfter","r","tableRowCells","tableColumnCount","newTableRowNode","c","tableCellFromTargetRow","insertAfter","insertBefore","$insertTableRow__EXPERIMENTAL","DEPRECATED_$getNodeTriplet","gridMap","focusCellMap","DEPRECATED_$computeGridMap","startRow","focusStartRow","focusEndRow","focusEndRowMap","newRow","setRowSpan","focusEndRowNode","getChildAtIndex","DEPRECATED_$isGridRowNode","focusStartRowMap","focusStartRowNode","$insertTableColumn","currentTableRowNode","tableRowChildren","targetCell","newTableCell","$insertTableColumn__EXPERIMENTAL","anchorCellMap","startColumn","min","insertAfterColumn","gridFirstChild","firstInsertedCell","$createTableCellNodeForInsertTableColumn","loopRow","rowLoop","currentRow","getNextSibling","rowMap","$insertFirst","currentCell","currentStartColumn","currentStartRow","insertAfterCell","insertAfterCellRowStart","prevCellIndex","cell_","startRow_","setColSpan","$moveSelectionToCell","$deleteTableColumn","$deleteTableRow__EXPERIMENTAL","anchorStartRow","nextRow","nextRowNode","column","cellStartRow","cellStartColumn","previousCell","rowNode","String","previousRow","$deleteTableColumn__EXPERIMENTAL","anchorStartColumn","focusStartColumn","endColumn","selectedColumnCount","overflowLeft","inSelectedArea","focusRowMap","nextColumn","firstDescendant","getFirstDescendant","$unmergeCell","map","cellMap","currentRowNode","currentRowMap","currentCellMap","j","INSERT_TABLE_COMMAND","createCommand","exports"],"sources":["C:/Users/franc/Desktop/Progetto/Frontend/app_frontend/node_modules/@lexical/table/LexicalTable.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n\n/** @noInheritDoc */\nclass TableCellNode extends lexical.DEPRECATED_GridCellNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'tablecell';\n  }\n\n  static clone(node) {\n    const cellNode = new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n    cellNode.__rowSpan = node.__rowSpan;\n    cellNode.__backgroundColor = node.__backgroundColor;\n    return cellNode;\n  }\n\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const colSpan = serializedNode.colSpan || 1;\n    const rowSpan = serializedNode.rowSpan || 1;\n    const cellNode = $createTableCellNode(serializedNode.headerState, colSpan, serializedNode.width || undefined);\n    cellNode.__rowSpan = rowSpan;\n    cellNode.__backgroundColor = serializedNode.backgroundColor || null;\n    return cellNode;\n  }\n\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(colSpan, key);\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element) {\n      const element_ = element;\n      const maxWidth = 700;\n      const colCount = this.getParentOrThrow().getChildrenSize();\n      element_.style.border = '1px solid black';\n\n      if (this.__colSpan > 1) {\n        element_.colSpan = this.__colSpan;\n      }\n\n      if (this.__rowSpan > 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n\n      element_.style.width = `${this.getWidth() || Math.max(90, maxWidth / colCount)}px`;\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n      const backgroundColor = this.getBackgroundColor();\n\n      if (backgroundColor !== null) {\n        element_.style.backgroundColor = backgroundColor;\n      } else if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      headerState: this.__headerState,\n      type: 'tablecell',\n      width: this.getWidth()\n    };\n  }\n\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n\n  setHeaderStyles(headerState) {\n    const self = this.getWritable();\n    self.__headerState = headerState;\n    return this.__headerState;\n  }\n\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return this.__width;\n  }\n\n  getWidth() {\n    return this.getLatest().__width;\n  }\n\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n\n  setBackgroundColor(newBackgroundColor) {\n    this.getWritable().__backgroundColor = newBackgroundColor;\n  }\n\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n\n    return self;\n  }\n\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n\n  isShadowRoot() {\n    return true;\n  }\n\n  collapseAtStart() {\n    return true;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n}\nfunction convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n\n  return {\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !lexical.$isElementNode(lexicalNode)) {\n        const paragraphNode = lexical.$createParagraphNode();\n\n        if (lexical.$isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\n  return lexical.$applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends lexical.DEPRECATED_GridRowNode {\n  /** @internal */\n  static getType() {\n    return 'tablerow';\n  }\n\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    return $createTableRowNode(serializedNode.height);\n  }\n\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'tablerow',\n      version: 1\n    };\n  }\n\n  createDOM(config) {\n    const element = document.createElement('tr');\n\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n\n  isShadowRoot() {\n    return true;\n  }\n\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n\n  getHeight() {\n    return this.getLatest().__height;\n  }\n\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n}\nfunction convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n\n  return {\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return lexical.$applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n\nclass TableSelection {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.grid = {\n      cells: [],\n      columns: 0,\n      rows: 0\n    };\n    this.gridSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTableGrid();\n  }\n\n  getGrid() {\n    return this.grid;\n  }\n\n  removeListeners() {\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n  }\n\n  trackTableGrid() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n\n          if (nodeName === 'TABLE' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n\n        if (!gridNeedsRedraw) {\n          return;\n        }\n\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n\n        this.grid = getTableGrid(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      this.grid = getTableGrid(tableElement);\n      observer.observe(tableElement, {\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n\n  clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.gridSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.enableHighlightStyle();\n    editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      const grid = getTableGrid(tableElement);\n      $updateDOMForSelection(editor, grid, null);\n      lexical.$setSelection(null);\n      editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n  enableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      utils.removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n\n  disableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      utils.addClassNamesToElement(tableElement, editor._config.theme.tableSelection);\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n\n  updateTableGridSelection(selection) {\n    if (selection != null && selection.gridKey === this.tableNodeKey) {\n      const editor = this.editor;\n      this.gridSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(editor, this.grid, this.gridSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    }\n  }\n\n  setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(editor._window); // Collapse the selection\n\n        if (domSelection) {\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\n        }\n      }\n\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n\n      this.focusX = cellX;\n      this.focusY = cellY;\n\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n        if (this.gridSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode)) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.gridSelection = this.gridSelection.clone() || lexical.DEPRECATED_$createGridSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.gridSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\n          lexical.$setSelection(this.gridSelection);\n          editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n          $updateDOMForSelection(editor, this.grid, this.gridSelection);\n        }\n      }\n    });\n  }\n\n  setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    this.editor.update(() => {\n      const anchorTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.gridSelection = lexical.DEPRECATED_$createGridSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.DEPRECATED_$isGridSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n\n      const formatSelection = lexical.$createRangeSelection();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      selection.getNodes().forEach(cellNode => {\n        if ($isTableCellNode(cellNode) && cellNode.getTextContentSize() !== 0) {\n          anchor.set(cellNode.getKey(), 0, 'element');\n          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n          formatSelection.formatText(type);\n        }\n      });\n      lexical.$setSelection(selection);\n      this.editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n  clearText() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const selection = lexical.$getSelection();\n\n      if (!lexical.DEPRECATED_$isGridSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n\n      if (selectedNodes.length === this.grid.columns * this.grid.rows) {\n        tableNode.selectPrevious(); // Delete entire table\n\n        tableNode.remove();\n        const rootNode = lexical.$getRoot();\n        rootNode.selectStart();\n        return;\n      }\n\n      selectedNodes.forEach(cellNode => {\n        if (lexical.$isElementNode(cellNode)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          const textNode = lexical.$createTextNode();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(editor, this.grid, null);\n      lexical.$setSelection(null);\n      editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nfunction applyTableHandlers(tableNode, tableElement, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n\n  const tableSelection = new TableSelection(editor, tableNode.getKey());\n  const editorWindow = editor._window || window;\n  attachTableSelectionToTableElement(tableElement, tableSelection);\n  tableElement.addEventListener('mousedown', event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n\n      if (!editorWindow) {\n        return;\n      }\n\n      const anchorCell = getCellFromTarget(event.target);\n\n      if (anchorCell !== null) {\n        stopEvent(event);\n        tableSelection.setAnchorCellForSelection(anchorCell);\n      }\n\n      const onMouseUp = () => {\n        editorWindow.removeEventListener('mouseup', onMouseUp);\n        editorWindow.removeEventListener('mousemove', onMouseMove);\n      };\n\n      const onMouseMove = moveEvent => {\n        const focusCell = getCellFromTarget(moveEvent.target);\n\n        if (focusCell !== null && (tableSelection.anchorX !== focusCell.x || tableSelection.anchorY !== focusCell.y)) {\n          moveEvent.preventDefault();\n          tableSelection.setFocusCellForSelection(focusCell);\n        }\n      };\n\n      editorWindow.addEventListener('mouseup', onMouseUp);\n      editorWindow.addEventListener('mousemove', onMouseMove);\n    }, 0);\n  }); // Clear selection when clicking outside of dom.\n\n  const mouseDownCallback = event => {\n    if (event.button !== 0) {\n      return;\n    }\n\n    editor.update(() => {\n      const selection = lexical.$getSelection();\n      const target = event.target;\n\n      if (lexical.DEPRECATED_$isGridSelection(selection) && selection.gridKey === tableSelection.tableNodeKey && rootElement.contains(target)) {\n        tableSelection.clearHighlight();\n      }\n    });\n  };\n\n  editorWindow.addEventListener('mousedown', mouseDownCallback);\n  tableSelection.listenersToRemove.add(() => editorWindow.removeEventListener('mousedown', mouseDownCallback));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => $handleArrowKey(editor, event, 'down', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => $handleArrowKey(editor, event, 'up', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => $handleArrowKey(editor, event, 'backward', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => $handleArrowKey(editor, event, 'forward', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      const focusCellNode = utils.$findMatchingParent(selection.focus.getNode(), $isTableCellNode);\n\n      if ($isTableCellNode(focusCellNode)) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_HIGH));\n\n  const deleteTextHandler = command => () => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.clearText();\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n\n      if (selectionContainsPartialTable) {\n        tableSelection.clearText();\n        return true;\n      }\n\n      const nearestElementNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && utils.$findMatchingParent(nearestElementNode, n => lexical.$isElementNode(n) && $isTableCellNode(n.getParent()));\n\n      if (!lexical.$isElementNode(topLevelCellElementNode) || !lexical.$isElementNode(nearestElementNode)) {\n        return false;\n      }\n\n      if (command === lexical.DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n\n      if (command === lexical.DELETE_CHARACTER_COMMAND || command === lexical.DELETE_WORD_COMMAND) {\n        if (selection.isCollapsed() && selection.anchor.offset === 0) {\n          if (nearestElementNode !== topLevelCellElementNode) {\n            const children = nearestElementNode.getChildren();\n            const newParagraphNode = lexical.$createParagraphNode();\n            children.forEach(child => newParagraphNode.append(child));\n            nearestElementNode.replace(newParagraphNode);\n            nearestElementNode.getWritable().__parent = tableCellNode.getKey();\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  [lexical.DELETE_WORD_COMMAND, lexical.DELETE_LINE_COMMAND, lexical.DELETE_CHARACTER_COMMAND].forEach(command => {\n    tableSelection.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), lexical.COMMAND_PRIORITY_CRITICAL));\n  });\n\n  const deleteCellHandler = event => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      event.preventDefault();\n      event.stopPropagation();\n      tableSelection.clearText();\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  };\n\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, deleteCellHandler, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_DELETE_COMMAND, deleteCellHandler, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.formatCells(payload);\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.clearHighlight();\n      return false;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n\n  if (hasTabHandler) {\n    tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n\n      if (tableCellNode === null) {\n        return false;\n      }\n\n      stopEvent(event);\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n      selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL));\n  }\n\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, lexical.COMMAND_PRIORITY_HIGH));\n\n  function getCellFromCellNode(tableCellNode) {\n    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n    return tableNode.getCellFromCordsOrThrow(currentCords.x, currentCords.y, tableSelection.grid);\n  }\n\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.SELECTION_CHANGE_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    const prevSelection = lexical.$getPreviousSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode(); // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = anchorCellNode && tableNode.is($findTableNode(anchorCellNode));\n      const isFocusInside = focusCellNode && tableNode.is($findTableNode(focusCellNode));\n      const isPartialyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n\n      if (isPartialyWithinTable) {\n        const newSelection = selection.clone();\n        newSelection.focus.set(tableNode.getKey(), isBackward ? 0 : tableNode.getChildrenSize(), 'element');\n        lexical.$setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableSelection);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into grid selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableSelection.setAnchorCellForSelection(getCellFromCellNode(anchorCellNode));\n          tableSelection.setFocusCellForSelection(getCellFromCellNode(focusCellNode), true);\n        }\n      }\n    }\n\n    if (selection && !selection.is(prevSelection) && (lexical.DEPRECATED_$isGridSelection(selection) || lexical.DEPRECATED_$isGridSelection(prevSelection)) && tableSelection.gridSelection && !tableSelection.gridSelection.is(prevSelection)) {\n      if (lexical.DEPRECATED_$isGridSelection(selection) && selection.gridKey === tableSelection.tableNodeKey) {\n        tableSelection.updateTableGridSelection(selection);\n      } else if (!lexical.DEPRECATED_$isGridSelection(selection) && lexical.DEPRECATED_$isGridSelection(prevSelection) && prevSelection.gridKey === tableSelection.tableNodeKey) {\n        tableSelection.updateTableGridSelection(null);\n      }\n\n      return false;\n    }\n\n    if (tableSelection.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableSelection);\n    } else if (!tableSelection.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableSelection);\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  return tableSelection;\n}\nfunction attachTableSelectionToTableElement(tableElement, tableSelection) {\n  tableElement[LEXICAL_ELEMENT_KEY] = tableSelection;\n}\nfunction getTableSelectionFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY];\n}\nfunction getCellFromTarget(node) {\n  let currentNode = node;\n\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n\n      if (cell === undefined) {\n        return null;\n      }\n\n      return cell;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\nfunction getTableGrid(tableElement) {\n  const cells = [];\n  const grid = {\n    cells,\n    columns: 0,\n    rows: 0\n  };\n  let currentNode = tableElement.firstChild;\n  let x = 0;\n  let y = 0;\n  cells.length = 0;\n\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      }; // @ts-expect-error: internal field\n\n      currentNode._cell = cell;\n      let row = cells[y];\n\n      if (row === undefined) {\n        row = cells[y] = [];\n      }\n\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n\n    const sibling = currentNode.nextSibling;\n\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n\n    const parent = currentNode.parentNode;\n\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n\n      if (parentSibling == null) {\n        break;\n      }\n\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, grid, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachGridCell(grid, (cell, lexicalNode) => {\n    const elem = cell.elem;\n\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachGridCell(grid, cb) {\n  const {\n    cells\n  } = grid;\n\n  for (let y = 0; y < cells.length; y++) {\n    const row = cells[y];\n\n    if (!row) {\n      continue;\n    }\n\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n\n      if (!cell) {\n        continue;\n      }\n\n      const lexicalNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachGridCell(tableSelection.grid, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.enableHighlightStyle();\n  $forEachGridCell(tableSelection.grid, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\n\nconst selectGridNodeInDirection = (tableSelection, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableSelection.grid.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableSelection.grid), isForward);\n      } else {\n        if (y !== (isForward ? tableSelection.grid.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableSelection.grid.columns - 1, y + (isForward ? 1 : -1), tableSelection.grid), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n\n      return true;\n\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableSelection.grid), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n\n      return true;\n\n    case 'down':\n      if (y !== tableSelection.grid.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableSelection.grid), true);\n      } else {\n        tableNode.selectNext();\n      }\n\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nconst adjustFocusNodeInDirection = (tableSelection, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableSelection.grid.columns - 1 : 0)) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableSelection.grid));\n      }\n\n      return true;\n\n    case 'up':\n      if (y !== 0) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x, y - 1, tableSelection.grid));\n        return true;\n      } else {\n        return false;\n      }\n\n    case 'down':\n      if (y !== tableSelection.grid.rows - 1) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x, y + 1, tableSelection.grid));\n        return true;\n      } else {\n        return false;\n      }\n\n    default:\n      return false;\n  }\n};\n\nfunction $isSelectionInTable(selection, tableNode) {\n  if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n\n  return false;\n}\n\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\n\nconst BROWSER_BLUE_RGB = '172,206,247';\n\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const node = lexical.$getNearestNodeFromDOMNode(element);\n\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n\n  const backgroundColor = node.getBackgroundColor();\n\n  if (backgroundColor === null) {\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\n  } else {\n    element.style.setProperty('background-image', `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`);\n  }\n\n  element.style.setProperty('caret-color', 'transparent');\n}\n\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = lexical.$getNearestNodeFromDOMNode(element);\n\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n\n  const backgroundColor = node.getBackgroundColor();\n\n  if (backgroundColor === null) {\n    element.style.removeProperty('background-color');\n  }\n\n  element.style.removeProperty('background-image');\n  element.style.removeProperty('caret-color');\n}\n\nfunction $findCellNode(node) {\n  const cellNode = utils.$findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\n\nfunction $findTableNode(node) {\n  const tableNode = utils.$findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\n\nfunction $handleArrowKey(editor, event, direction, tableNode, tableSelection) {\n  const selection = lexical.$getSelection();\n\n  if (!$isSelectionInTable(selection, tableNode)) {\n    return false;\n  }\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed()) {\n    // Horizontal move between cels seem to work well without interruption\n    // so just exit early, and handle vertical moves\n    if (direction === 'backward' || direction === 'forward') {\n      return false;\n    }\n\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = utils.$findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = utils.$findMatchingParent(focus.getNode(), $isTableCellNode);\n\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n\n    let edgeSelectionRect;\n\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = window.getSelection();\n\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n\n    if (edgeChild == null) {\n      return false;\n    }\n\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n\n    if (edgeChildDOM == null) {\n      return false;\n    }\n\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableSelection.grid);\n\n      if (event.shiftKey) {\n        const cell = tableNode.getCellFromCordsOrThrow(cords.x, cords.y, tableSelection.grid);\n        tableSelection.setAnchorCellForSelection(cell);\n        tableSelection.setFocusCellForSelection(cell, true);\n      } else {\n        return selectGridNodeInDirection(tableSelection, tableNode, cords.x, cords.y, direction);\n      }\n\n      return true;\n    }\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = utils.$findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = utils.$findMatchingParent(focus.getNode(), $isTableCellNode);\n\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode)) {\n      return false;\n    }\n\n    stopEvent(event);\n\n    if (event.shiftKey) {\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, tableSelection.grid);\n      return adjustFocusNodeInDirection(tableSelection, tableNode, cords.x, cords.y, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableNode extends lexical.DEPRECATED_GridNode {\n  /** @internal */\n  static getType() {\n    return 'table';\n  }\n\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: convertTableElement,\n        priority: 1\n      })\n    };\n  }\n\n  static importJSON(_serializedNode) {\n    return $createTableNode();\n  }\n\n  constructor(key) {\n    super(key);\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'table',\n      version: 1\n    };\n  }\n\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    utils.addClassNamesToElement(tableElement, config.theme.table);\n    return tableElement;\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  exportDOM(editor) {\n    return { ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n\n          if (utils.isHTMLElement(tableElement)) {\n            tBody.append(...tableElement.children);\n          }\n\n          const firstRow = this.getFirstChildOrThrow();\n\n          if (!$isTableRowNode(firstRow)) {\n            throw new Error('Expected to find row node.');\n          }\n\n          const colCount = firstRow.getChildrenSize();\n\n          for (let i = 0; i < colCount; i++) {\n            const col = document.createElement('col');\n            colGroup.append(col);\n          }\n\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  } // TODO 0.10 deprecate\n\n\n  canExtractContents() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  isShadowRoot() {\n    return true;\n  }\n\n  getCordsFromCellNode(tableCellNode, grid) {\n    const {\n      rows,\n      cells\n    } = grid;\n\n    for (let y = 0; y < rows; y++) {\n      const row = cells[y];\n\n      if (row == null) {\n        continue;\n      }\n\n      const x = row.findIndex(cell => {\n        if (!cell) return;\n        const {\n          elem\n        } = cell;\n        const cellNode = lexical.$getNearestNodeFromDOMNode(elem);\n        return cellNode === tableCellNode;\n      });\n\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n\n    throw new Error('Cell not found in table.');\n  }\n\n  getCellFromCords(x, y, grid) {\n    const {\n      cells\n    } = grid;\n    const row = cells[y];\n\n    if (row == null) {\n      return null;\n    }\n\n    const cell = row[x];\n\n    if (cell == null) {\n      return null;\n    }\n\n    return cell;\n  }\n\n  getCellFromCordsOrThrow(x, y, grid) {\n    const cell = this.getCellFromCords(x, y, grid);\n\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n\n    return cell;\n  }\n\n  getCellNodeFromCords(x, y, grid) {\n    const cell = this.getCellFromCords(x, y, grid);\n\n    if (cell == null) {\n      return null;\n    }\n\n    const node = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n\n    return null;\n  }\n\n  getCellNodeFromCordsOrThrow(x, y, grid) {\n    const node = this.getCellNodeFromCords(x, y, grid);\n\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n\n    return node;\n  }\n\n  canSelectBefore() {\n    return true;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n}\nfunction $getElementGridForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n\n  return getTableGrid(tableElement);\n}\nfunction convertTableElement(_domNode) {\n  return {\n    node: $createTableNode()\n  };\n}\nfunction $createTableNode() {\n  return lexical.$applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) headerState |= TableCellHeaderStates.ROW;\n        if (iColumn === 0 && includeHeaders.columns) headerState |= TableCellHeaderStates.COLUMN;\n      } else if (includeHeaders) {\n        if (iRow === 0) headerState |= TableCellHeaderStates.ROW;\n        if (iColumn === 0) headerState |= TableCellHeaderStates.COLUMN;\n      }\n\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = lexical.$createParagraphNode();\n      paragraphNode.append(lexical.$createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n\n    tableNode.append(tableRowNode);\n  }\n\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableCellNode(n));\n\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableRowNode(n));\n\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableNode(n));\n\n  if ($isTableNode(node)) {\n    return node;\n  }\n\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, grid) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, grid);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, grid),\n    below: tableNode.getCellNodeFromCords(x, y + 1, grid),\n    left: tableNode.getCellNodeFromCords(x - 1, y, grid),\n    right: tableNode.getCellNodeFromCords(x + 1, y, grid)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, grid) {\n  const tableRows = tableNode.getChildren();\n\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n\n  const targetRowNode = tableRows[targetIndex];\n\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, grid);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append(lexical.$createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n\n  return tableNode;\n}\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const focus = selection.focus.getNode();\n  const [focusCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, focusCellMap] = lexical.DEPRECATED_$computeGridMap(grid, focusCell, focusCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n\n  if (insertAfter) {\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n    const focusEndRowMap = gridMap[focusEndRow];\n    const newRow = $createTableRowNode();\n\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusEndRowMap[i];\n\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\n        newRow.append($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\n\n    if (!lexical.DEPRECATED_$isGridRowNode(focusEndRowNode)) {\n      throw Error(`focusEndRow is not a GridRowNode`);\n    }\n\n    focusEndRowNode.insertAfter(newRow);\n  } else {\n    const focusStartRowMap = gridMap[focusStartRow];\n    const newRow = $createTableRowNode();\n\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusStartRowMap[i];\n\n      if (startRow === focusStartRow) {\n        newRow.append($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\n\n    if (!lexical.DEPRECATED_$isGridRowNode(focusStartRowNode)) {\n      throw Error(`focusEndRow is not a GridRowNode`);\n    }\n\n    focusStartRowNode.insertBefore(newRow);\n  }\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, grid) {\n  const tableRows = tableNode.getChildren();\n\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n\n        const targetCell = tableRowChildren[targetIndex];\n\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, grid);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append(lexical.$createParagraphNode());\n\n        if (shouldInsertAfter) {\n          targetCell.insertAfter(newTableCell);\n        } else {\n          targetCell.insertBefore(newTableCell);\n        }\n      }\n    }\n  }\n\n  return tableNode;\n}\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const [focusCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = lexical.DEPRECATED_$computeGridMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n\n  if (!lexical.DEPRECATED_$isGridRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n\n  let firstInsertedCell = null;\n\n  function $createTableCellNodeForInsertTableColumn() {\n    const cell = $createTableCellNode(TableCellHeaderStates.NO_STATUS).append(lexical.$createParagraphNode());\n\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n\n    return cell;\n  }\n\n  let loopRow = gridFirstChild;\n\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n\n      if (!lexical.DEPRECATED_$isGridRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n\n      loopRow = currentRow;\n    }\n\n    const rowMap = gridMap[i];\n\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn());\n      continue;\n    }\n\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn());\n          continue rowLoop;\n        }\n      }\n\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn());\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const [focusCell] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = lexical.DEPRECATED_$computeGridMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      } // Rows overflowing top have to be trimmed\n\n\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\n      } // Rows overflowing bottom have to be trimmed and moved to the next row\n\n\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n\n        if (column === 0) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          const {\n            cell: previousCell\n          } = nextRow[column - 1];\n          previousCell.insertAfter(cell);\n        }\n      }\n    }\n\n    const rowNode = grid.getChildAtIndex(row);\n\n    if (!lexical.DEPRECATED_$isGridRowNode(rowNode)) {\n      throw Error(`Expected GridNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n\n    rowNode.remove();\n  }\n\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const [focusCell] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = lexical.DEPRECATED_$computeGridMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n\n  const rowCount = gridMap.length;\n\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn; // Overflowing left\n\n          cell.setColSpan(cell.__colSpan - // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = focusRowMap[focusStartColumn + focusCell.__colSpan];\n\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusRowMap[focusStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n}\n\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n\n  if (!(firstDescendant !== null)) {\n    throw Error(`Unexpected empty cell`);\n  }\n\n  firstDescendant.getParentOrThrow().selectStart();\n}\n\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\nfunction $unmergeCell() {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n    }\n\n    cell.setColSpan(1);\n  }\n\n  if (rowSpan > 1) {\n    const [map, cellMap] = lexical.DEPRECATED_$computeGridMap(grid, cell, cell);\n    const {\n      startColumn,\n      startRow\n    } = cellMap;\n    let currentRowNode;\n\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n\n      if (!lexical.DEPRECATED_$isGridRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n\n      let insertAfterCell = null;\n\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n\n      if (insertAfterCell === null) {\n        for (let j = 0; j < colSpan; j++) {\n          $insertFirst(currentRowNode, $createTableCellNode(TableCellHeaderStates.NO_STATUS));\n        }\n      } else {\n        for (let j = 0; j < colSpan; j++) {\n          insertAfterCell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n        }\n      }\n    }\n\n    cell.setRowSpan(1);\n  }\n}\n\n/** @module @lexical/table */\nconst INSERT_TABLE_COMMAND = lexical.createCommand('INSERT_TABLE_COMMAND');\n\nexports.$createTableCellNode = $createTableCellNode;\nexports.$createTableNode = $createTableNode;\nexports.$createTableNodeWithDimensions = $createTableNodeWithDimensions;\nexports.$createTableRowNode = $createTableRowNode;\nexports.$deleteTableColumn = $deleteTableColumn;\nexports.$deleteTableColumn__EXPERIMENTAL = $deleteTableColumn__EXPERIMENTAL;\nexports.$deleteTableRow__EXPERIMENTAL = $deleteTableRow__EXPERIMENTAL;\nexports.$getElementGridForTableNode = $getElementGridForTableNode;\nexports.$getTableCellNodeFromLexicalNode = $getTableCellNodeFromLexicalNode;\nexports.$getTableColumnIndexFromTableCellNode = $getTableColumnIndexFromTableCellNode;\nexports.$getTableNodeFromLexicalNodeOrThrow = $getTableNodeFromLexicalNodeOrThrow;\nexports.$getTableRowIndexFromTableCellNode = $getTableRowIndexFromTableCellNode;\nexports.$getTableRowNodeFromTableCellNodeOrThrow = $getTableRowNodeFromTableCellNodeOrThrow;\nexports.$insertTableColumn = $insertTableColumn;\nexports.$insertTableColumn__EXPERIMENTAL = $insertTableColumn__EXPERIMENTAL;\nexports.$insertTableRow = $insertTableRow;\nexports.$insertTableRow__EXPERIMENTAL = $insertTableRow__EXPERIMENTAL;\nexports.$isTableCellNode = $isTableCellNode;\nexports.$isTableNode = $isTableNode;\nexports.$isTableRowNode = $isTableRowNode;\nexports.$removeTableRowAtIndex = $removeTableRowAtIndex;\nexports.$unmergeCell = $unmergeCell;\nexports.INSERT_TABLE_COMMAND = INSERT_TABLE_COMMAND;\nexports.TableCellHeaderStates = TableCellHeaderStates;\nexports.TableCellNode = TableCellNode;\nexports.TableNode = TableNode;\nexports.TableRowNode = TableRowNode;\nexports.TableSelection = TableSelection;\nexports.applyTableHandlers = applyTableHandlers;\nexports.getCellFromTarget = getCellFromTarget;\nexports.getTableSelectionFromTableElement = getTableSelectionFromTableElement;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}