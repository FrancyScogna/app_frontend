{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar clipboard = require('@lexical/clipboard');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    }; // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/** @module @lexical/rich-text */\nconst DRAG_DROP_PASTE = lexical.createCommand('DRAG_DROP_PASTE_FILE');\n\n/** @noInheritDoc */\nclass QuoteNode extends lexical.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  } // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    utils.addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && utils.isHTMLElement(element)) {\n      if (this.isEmpty()) element.append(document.createElement('br'));\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'quote'\n    };\n  } // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return lexical.$applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n\n/** @noInheritDoc */\nclass HeadingNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  } // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      utils.addClassNamesToElement(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && utils.isHTMLElement(element)) {\n      if (this.isEmpty()) element.append(document.createElement('br'));\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  } // Mutation\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const newElement = anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n    if (element.style !== null) {\n      node.setFormat(element.style.textAlign);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n  }\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag) {\n  return lexical.$applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;\n    if (clipboardData != null && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n      clipboard.$insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\nasync function onCutForRichText(event, editor) {\n  await clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection)) {\n      selection.removeText();\n    } else if (lexical.$isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n} // Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain ocassions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\n\nfunction eventFiles(event) {\n  let dataTransfer = null;\n  if (event instanceof DragEvent) {\n    dataTransfer = event.dataTransfer;\n  } else if (event instanceof ClipboardEvent) {\n    dataTransfer = event.clipboardData;\n  }\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\nfunction handleIndentAndOutdent(indentOrOutdent) {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n  return alreadyHandled.size > 0;\n}\nfunction $isTargetWithinDecorator(target) {\n  const node = lexical.$getNearestNodeFromDOMNode(target);\n  return lexical.$isDecoratorNode(node);\n}\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === lexical.$getRoot().getChildrenSize();\n}\nfunction registerRichText(editor) {\n  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = lexical.$getSelection();\n    if (typeof eventOrText === 'string') {\n      if (lexical.$isRangeSelection(selection)) {\n        selection.insertText(eventOrText);\n      } else if (lexical.DEPRECATED_$isGridSelection(selection)) ;\n    } else {\n      if (!lexical.$isRangeSelection(selection) && !lexical.DEPRECATED_$isGridSelection(selection)) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        clipboard.$insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if (lexical.$isRangeSelection(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection) && !lexical.$isNodeSelection(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = utils.$findMatchingParent(node, parentNode => lexical.$isElementNode(parentNode) && !parentNode.isInline());\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_TAB_COMMAND, () => {\n    lexical.$insertNodes([lexical.$createTabNode()]);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {\n    return handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {\n    return handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      if (indent > 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, true);\n      if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, false);\n      if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection$1)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection$1) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (selection.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, undefined);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = lexical.$getNearestNodeFromDOMNode(domNode);\n        if (node !== null) {\n          const selection = lexical.$createRangeSelection();\n          if (lexical.$isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n          const normalizedSelection = lexical.$normalizeSelection__EXPERIMENTAL(selection);\n          lexical.$setSelection(normalizedSelection);\n        }\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n      event.preventDefault();\n      return true;\n    }\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection)) {\n      return true;\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n    if (eventRange !== null) {\n      const node = lexical.$getNearestNodeFromDOMNode(eventRange.node);\n      if (lexical.$isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.SELECT_ALL_COMMAND, () => {\n    lexical.$selectAll();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, event => {\n    clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    } // if inputs then paste within the input ignore creating a new node on paste event\n\n    if (lexical.isSelectionCapturedInDecoratorInput(event.target)) {\n      return false;\n    }\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\nexports.$createHeadingNode = $createHeadingNode;\nexports.$createQuoteNode = $createQuoteNode;\nexports.$isHeadingNode = $isHeadingNode;\nexports.$isQuoteNode = $isQuoteNode;\nexports.DRAG_DROP_PASTE = DRAG_DROP_PASTE;\nexports.HeadingNode = HeadingNode;\nexports.QuoteNode = QuoteNode;\nexports.eventFiles = eventFiles;\nexports.registerRichText = registerRichText;","map":{"version":3,"names":["clipboard","require","selection","utils","lexical","caretFromPoint","x","y","document","caretRangeFromPoint","range","node","startContainer","offset","startOffset","caretPositionFromPoint","offsetNode","CAN_USE_DOM","window","createElement","documentMode","test","navigator","platform","userAgent","CAN_USE_BEFORE_INPUT","InputEvent","IS_SAFARI","IS_IOS","MSStream","IS_CHROME","IS_APPLE_WEBKIT","DRAG_DROP_PASTE","createCommand","QuoteNode","ElementNode","getType","clone","__key","constructor","key","createDOM","config","element","addClassNamesToElement","theme","quote","updateDOM","prevNode","dom","importDOM","blockquote","conversion","convertBlockquoteElement","priority","exportDOM","editor","isHTMLElement","isEmpty","append","formatType","getFormatType","style","textAlign","direction","getDirection","dir","importJSON","serializedNode","$createQuoteNode","setFormat","format","setIndent","indent","setDirection","exportJSON","type","insertNewAfter","_","restoreSelection","newBlock","$createParagraphNode","insertAfter","collapseAtStart","paragraph","children","getChildren","forEach","child","replace","$applyNodeReplacement","$isQuoteNode","HeadingNode","__tag","tag","getTag","classNames","heading","undefined","className","h1","convertHeadingElement","h2","h3","h4","h5","h6","p","firstChild","isGoogleDocsTitle","span","domNode","$createHeadingNode","version","anchorOffet","anchor","newElement","getTextContentSize","extractWithChild","nodeName","toLowerCase","fontSize","headingTag","$isHeadingNode","onPasteForRichText","event","preventDefault","update","$getSelection","clipboardData","KeyboardEvent","$isRangeSelection","DEPRECATED_$isGridSelection","$insertDataTransferForRichText","onCutForRichText","copyToClipboard","objectKlassEquals","ClipboardEvent","removeText","$isNodeSelection","getNodes","remove","eventFiles","dataTransfer","DragEvent","types","hasFiles","includes","hasContent","Array","from","files","handleIndentAndOutdent","indentOrOutdent","alreadyHandled","Set","nodes","i","length","getKey","has","parentBlock","$getNearestBlockElementAncestorOrThrow","parentKey","canIndent","add","size","$isTargetWithinDecorator","target","$getNearestNodeFromDOMNode","$isDecoratorNode","$isSelectionAtEndOfRoot","focus","$getRoot","getChildrenSize","registerRichText","removeListener","mergeRegister","registerCommand","CLICK_COMMAND","payload","clear","DELETE_CHARACTER_COMMAND","isBackward","deleteCharacter","COMMAND_PRIORITY_EDITOR","DELETE_WORD_COMMAND","deleteWord","DELETE_LINE_COMMAND","deleteLine","CONTROLLED_TEXT_INSERTION_COMMAND","eventOrText","insertText","data","REMOVE_TEXT_COMMAND","FORMAT_TEXT_COMMAND","formatText","FORMAT_ELEMENT_COMMAND","$findMatchingParent","parentNode","$isElementNode","isInline","INSERT_LINE_BREAK_COMMAND","selectStart","insertLineBreak","INSERT_PARAGRAPH_COMMAND","insertParagraph","INSERT_TAB_COMMAND","$insertNodes","$createTabNode","INDENT_CONTENT_COMMAND","block","getIndent","OUTDENT_CONTENT_COMMAND","KEY_ARROW_UP_COMMAND","selectPrevious","possibleNode","$getAdjacentNode","shiftKey","isIsolated","KEY_ARROW_DOWN_COMMAND","selectNext","KEY_ARROW_LEFT_COMMAND","selection$1","$shouldOverrideDefaultCharacterSelection","isHoldingShift","$moveCharacter","KEY_ARROW_RIGHT_COMMAND","KEY_BACKSPACE_COMMAND","anchorNode","getNode","isCollapsed","$isRootNode","dispatchCommand","KEY_DELETE_COMMAND","KEY_ENTER_COMMAND","KEY_ESCAPE_COMMAND","blur","DROP_COMMAND","clientX","clientY","eventRange","domOffset","$createRangeSelection","$isTextNode","set","getParentOrThrow","getIndexWithinParent","normalizedSelection","$normalizeSelection__EXPERIMENTAL","$setSelection","DRAGSTART_COMMAND","isFileTransfer","DRAGOVER_COMMAND","SELECT_ALL_COMMAND","$selectAll","COPY_COMMAND","CUT_COMMAND","PASTE_COMMAND","hasTextContent","isSelectionCapturedInDecoratorInput","exports"],"sources":["C:/Users/franc/Desktop/Progetto/Frontend/app_frontend/node_modules/@lexical/rich-text/LexicalRichText.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar clipboard = require('@lexical/clipboard');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n\n    if (range === null) {\n      return null;\n    }\n\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    }; // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n\n    if (range === null) {\n      return null;\n    }\n\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/** @module @lexical/rich-text */\nconst DRAG_DROP_PASTE = lexical.createCommand('DRAG_DROP_PASTE_FILE');\n\n/** @noInheritDoc */\nclass QuoteNode extends lexical.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    utils.addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element && utils.isHTMLElement(element)) {\n      if (this.isEmpty()) element.append(document.createElement('br'));\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'quote'\n    };\n  } // Mutation\n\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n}\nfunction $createQuoteNode() {\n  return lexical.$applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n\n/** @noInheritDoc */\nclass HeadingNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'heading';\n  }\n\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n\n  getTag() {\n    return this.__tag;\n  } // View\n\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      utils.addClassNamesToElement(element, className);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n\n        return null;\n      }\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element && utils.isHTMLElement(element)) {\n      if (this.isEmpty()) element.append(document.createElement('br'));\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const newElement = anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n\n  extractWithChild() {\n    return true;\n  }\n\n}\n\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n\n  return false;\n}\n\nfunction convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n\n    if (element.style !== null) {\n      node.setFormat(element.style.textAlign);\n    }\n  }\n\n  return {\n    node\n  };\n}\n\nfunction convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n  }\n\n  return {\n    node\n  };\n}\n\nfunction $createHeadingNode(headingTag) {\n  return lexical.$applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\n\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;\n\n    if (clipboardData != null && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n      clipboard.$insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\n\nasync function onCutForRichText(event, editor) {\n  await clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      selection.removeText();\n    } else if (lexical.$isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n} // Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain ocassions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\n\n\nfunction eventFiles(event) {\n  let dataTransfer = null;\n\n  if (event instanceof DragEvent) {\n    dataTransfer = event.dataTransfer;\n  } else if (event instanceof ClipboardEvent) {\n    dataTransfer = event.clipboardData;\n  }\n\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\n\nfunction handleIndentAndOutdent(indentOrOutdent) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n\n    const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);\n    const parentKey = parentBlock.getKey();\n\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n\n  return alreadyHandled.size > 0;\n}\n\nfunction $isTargetWithinDecorator(target) {\n  const node = lexical.$getNearestNodeFromDOMNode(target);\n  return lexical.$isDecoratorNode(node);\n}\n\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === lexical.$getRoot().getChildrenSize();\n}\n\nfunction registerRichText(editor) {\n  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n\n    return false;\n  }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = lexical.$getSelection();\n\n    if (typeof eventOrText === 'string') {\n      if (lexical.$isRangeSelection(selection)) {\n        selection.insertText(eventOrText);\n      } else if (lexical.DEPRECATED_$isGridSelection(selection)) ;\n    } else {\n      if (!lexical.$isRangeSelection(selection) && !lexical.DEPRECATED_$isGridSelection(selection)) {\n        return false;\n      }\n\n      const dataTransfer = eventOrText.dataTransfer;\n\n      if (dataTransfer != null) {\n        clipboard.$insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if (lexical.$isRangeSelection(selection)) {\n        const data = eventOrText.data;\n\n        if (data) {\n          selection.insertText(data);\n        }\n\n        return true;\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.removeText();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.formatText(format);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection) && !lexical.$isNodeSelection(selection)) {\n      return false;\n    }\n\n    const nodes = selection.getNodes();\n\n    for (const node of nodes) {\n      const element = utils.$findMatchingParent(node, parentNode => lexical.$isElementNode(parentNode) && !parentNode.isInline());\n\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertParagraph();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_TAB_COMMAND, () => {\n    lexical.$insertNodes([lexical.$createTabNode()]);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {\n    return handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {\n    return handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n\n      if (indent > 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, true);\n\n      if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, false);\n\n      if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection$1)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, true);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection$1) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    const isHoldingShift = event.shiftKey;\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, false);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n\n    if (selection.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);\n\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n\n      event.preventDefault();\n\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, undefined);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    editor.blur();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = lexical.$getNearestNodeFromDOMNode(domNode);\n\n        if (node !== null) {\n          const selection = lexical.$createRangeSelection();\n\n          if (lexical.$isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n\n          const normalizedSelection = lexical.$normalizeSelection__EXPERIMENTAL(selection);\n          lexical.$setSelection(normalizedSelection);\n        }\n\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n\n      event.preventDefault();\n      return true;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n\n    if (eventRange !== null) {\n      const node = lexical.$getNearestNodeFromDOMNode(eventRange.node);\n\n      if (lexical.$isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.SELECT_ALL_COMMAND, () => {\n    lexical.$selectAll();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, event => {\n    clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    } // if inputs then paste within the input ignore creating a new node on paste event\n\n\n    if (lexical.isSelectionCapturedInDecoratorInput(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexports.$createHeadingNode = $createHeadingNode;\nexports.$createQuoteNode = $createQuoteNode;\nexports.$isHeadingNode = $isHeadingNode;\nexports.$isQuoteNode = $isQuoteNode;\nexports.DRAG_DROP_PASTE = DRAG_DROP_PASTE;\nexports.HeadingNode = HeadingNode;\nexports.QuoteNode = QuoteNode;\nexports.eventFiles = eventFiles;\nexports.registerRichText = registerRichText;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,IAAIA,SAAS,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC7C,IAAIC,SAAS,GAAGD,OAAO,CAAC,oBAAoB,CAAC;AAC7C,IAAIE,KAAK,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AACrC,IAAIG,OAAO,GAAGH,OAAO,CAAC,SAAS,CAAC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,cAAcA,CAACC,CAAC,EAAEC,CAAC,EAAE;EAC5B,IAAI,OAAOC,QAAQ,CAACC,mBAAmB,KAAK,WAAW,EAAE;IACvD,MAAMC,KAAK,GAAGF,QAAQ,CAACC,mBAAmB,CAACH,CAAC,EAAEC,CAAC,CAAC;IAEhD,IAAIG,KAAK,KAAK,IAAI,EAAE;MAClB,OAAO,IAAI;IACb;IAEA,OAAO;MACLC,IAAI,EAAED,KAAK,CAACE,cAAc;MAC1BC,MAAM,EAAEH,KAAK,CAACI;IAChB,CAAC,CAAC,CAAC;EACL,CAAC,MAAM,IAAIN,QAAQ,CAACO,sBAAsB,KAAK,WAAW,EAAE;IAC1D;IACA,MAAML,KAAK,GAAGF,QAAQ,CAACO,sBAAsB,CAACT,CAAC,EAAEC,CAAC,CAAC;IAEnD,IAAIG,KAAK,KAAK,IAAI,EAAE;MAClB,OAAO,IAAI;IACb;IAEA,OAAO;MACLC,IAAI,EAAED,KAAK,CAACM,UAAU;MACtBH,MAAM,EAAEH,KAAK,CAACG;IAChB,CAAC;EACH,CAAC,MAAM;IACL;IACA,OAAO,IAAI;EACb;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMI,WAAW,GAAG,OAAOC,MAAM,KAAK,WAAW,IAAI,OAAOA,MAAM,CAACV,QAAQ,KAAK,WAAW,IAAI,OAAOU,MAAM,CAACV,QAAQ,CAACW,aAAa,KAAK,WAAW;;AAEnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,YAAY,GAAGH,WAAW,IAAI,cAAc,IAAIT,QAAQ,GAAGA,QAAQ,CAACY,YAAY,GAAG,IAAI;AAC7FH,WAAW,IAAI,sBAAsB,CAACI,IAAI,CAACC,SAAS,CAACC,QAAQ,CAAC;AAC9DN,WAAW,IAAI,kCAAkC,CAACI,IAAI,CAACC,SAAS,CAACE,SAAS,CAAC;AAC3E,MAAMC,oBAAoB,GAAGR,WAAW,IAAI,YAAY,IAAIC,MAAM,IAAI,CAACE,YAAY,GAAG,iBAAiB,IAAI,IAAIF,MAAM,CAACQ,UAAU,CAAC,OAAO,CAAC,GAAG,KAAK;AACjJ,MAAMC,SAAS,GAAGV,WAAW,IAAI,yBAAyB,CAACI,IAAI,CAACC,SAAS,CAACE,SAAS,CAAC;AACpF,MAAMI,MAAM,GAAGX,WAAW,IAAI,kBAAkB,CAACI,IAAI,CAACC,SAAS,CAACE,SAAS,CAAC,IAAI,CAACN,MAAM,CAACW,QAAQ,CAAC,CAAC;AAChG;;AAEA,MAAMC,SAAS,GAAGb,WAAW,IAAI,kBAAkB,CAACI,IAAI,CAACC,SAAS,CAACE,SAAS,CAAC,CAAC,CAAC;;AAE/E,MAAMO,eAAe,GAAGd,WAAW,IAAI,qBAAqB,CAACI,IAAI,CAACC,SAAS,CAACE,SAAS,CAAC,IAAI,CAACM,SAAS;;AAEpG;AACA,MAAME,eAAe,GAAG5B,OAAO,CAAC6B,aAAa,CAAC,sBAAsB,CAAC;;AAErE;AACA,MAAMC,SAAS,SAAS9B,OAAO,CAAC+B,WAAW,CAAC;EAC1C,OAAOC,OAAOA,CAAA,EAAG;IACf,OAAO,OAAO;EAChB;EAEA,OAAOC,KAAKA,CAAC1B,IAAI,EAAE;IACjB,OAAO,IAAIuB,SAAS,CAACvB,IAAI,CAAC2B,KAAK,CAAC;EAClC;EAEAC,WAAWA,CAACC,GAAG,EAAE;IACf,KAAK,CAACA,GAAG,CAAC;EACZ,CAAC,CAAC;;EAGFC,SAASA,CAACC,MAAM,EAAE;IAChB,MAAMC,OAAO,GAAGnC,QAAQ,CAACW,aAAa,CAAC,YAAY,CAAC;IACpDhB,KAAK,CAACyC,sBAAsB,CAACD,OAAO,EAAED,MAAM,CAACG,KAAK,CAACC,KAAK,CAAC;IACzD,OAAOH,OAAO;EAChB;EAEAI,SAASA,CAACC,QAAQ,EAAEC,GAAG,EAAE;IACvB,OAAO,KAAK;EACd;EAEA,OAAOC,SAASA,CAAA,EAAG;IACjB,OAAO;MACLC,UAAU,EAAExC,IAAI,KAAK;QACnByC,UAAU,EAAEC,wBAAwB;QACpCC,QAAQ,EAAE;MACZ,CAAC;IACH,CAAC;EACH;EAEAC,SAASA,CAACC,MAAM,EAAE;IAChB,MAAM;MACJb;IACF,CAAC,GAAG,KAAK,CAACY,SAAS,CAACC,MAAM,CAAC;IAE3B,IAAIb,OAAO,IAAIxC,KAAK,CAACsD,aAAa,CAACd,OAAO,CAAC,EAAE;MAC3C,IAAI,IAAI,CAACe,OAAO,CAAC,CAAC,EAAEf,OAAO,CAACgB,MAAM,CAACnD,QAAQ,CAACW,aAAa,CAAC,IAAI,CAAC,CAAC;MAChE,MAAMyC,UAAU,GAAG,IAAI,CAACC,aAAa,CAAC,CAAC;MACvClB,OAAO,CAACmB,KAAK,CAACC,SAAS,GAAGH,UAAU;MACpC,MAAMI,SAAS,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;MAErC,IAAID,SAAS,EAAE;QACbrB,OAAO,CAACuB,GAAG,GAAGF,SAAS;MACzB;IACF;IAEA,OAAO;MACLrB;IACF,CAAC;EACH;EAEA,OAAOwB,UAAUA,CAACC,cAAc,EAAE;IAChC,MAAMzD,IAAI,GAAG0D,gBAAgB,CAAC,CAAC;IAC/B1D,IAAI,CAAC2D,SAAS,CAACF,cAAc,CAACG,MAAM,CAAC;IACrC5D,IAAI,CAAC6D,SAAS,CAACJ,cAAc,CAACK,MAAM,CAAC;IACrC9D,IAAI,CAAC+D,YAAY,CAACN,cAAc,CAACJ,SAAS,CAAC;IAC3C,OAAOrD,IAAI;EACb;EAEAgE,UAAUA,CAAA,EAAG;IACX,OAAO;MAAE,GAAG,KAAK,CAACA,UAAU,CAAC,CAAC;MAC5BC,IAAI,EAAE;IACR,CAAC;EACH,CAAC,CAAC;;EAGFC,cAAcA,CAACC,CAAC,EAAEC,gBAAgB,EAAE;IAClC,MAAMC,QAAQ,GAAG5E,OAAO,CAAC6E,oBAAoB,CAAC,CAAC;IAC/C,MAAMjB,SAAS,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IACrCe,QAAQ,CAACN,YAAY,CAACV,SAAS,CAAC;IAChC,IAAI,CAACkB,WAAW,CAACF,QAAQ,EAAED,gBAAgB,CAAC;IAC5C,OAAOC,QAAQ;EACjB;EAEAG,eAAeA,CAAA,EAAG;IAChB,MAAMC,SAAS,GAAGhF,OAAO,CAAC6E,oBAAoB,CAAC,CAAC;IAChD,MAAMI,QAAQ,GAAG,IAAI,CAACC,WAAW,CAAC,CAAC;IACnCD,QAAQ,CAACE,OAAO,CAACC,KAAK,IAAIJ,SAAS,CAACzB,MAAM,CAAC6B,KAAK,CAAC,CAAC;IAClD,IAAI,CAACC,OAAO,CAACL,SAAS,CAAC;IACvB,OAAO,IAAI;EACb;AAEF;AACA,SAASf,gBAAgBA,CAAA,EAAG;EAC1B,OAAOjE,OAAO,CAACsF,qBAAqB,CAAC,IAAIxD,SAAS,CAAC,CAAC,CAAC;AACvD;AACA,SAASyD,YAAYA,CAAChF,IAAI,EAAE;EAC1B,OAAOA,IAAI,YAAYuB,SAAS;AAClC;;AAEA;AACA,MAAM0D,WAAW,SAASxF,OAAO,CAAC+B,WAAW,CAAC;EAC5C;EACA,OAAOC,OAAOA,CAAA,EAAG;IACf,OAAO,SAAS;EAClB;EAEA,OAAOC,KAAKA,CAAC1B,IAAI,EAAE;IACjB,OAAO,IAAIiF,WAAW,CAACjF,IAAI,CAACkF,KAAK,EAAElF,IAAI,CAAC2B,KAAK,CAAC;EAChD;EAEAC,WAAWA,CAACuD,GAAG,EAAEtD,GAAG,EAAE;IACpB,KAAK,CAACA,GAAG,CAAC;IACV,IAAI,CAACqD,KAAK,GAAGC,GAAG;EAClB;EAEAC,MAAMA,CAAA,EAAG;IACP,OAAO,IAAI,CAACF,KAAK;EACnB,CAAC,CAAC;;EAGFpD,SAASA,CAACC,MAAM,EAAE;IAChB,MAAMoD,GAAG,GAAG,IAAI,CAACD,KAAK;IACtB,MAAMlD,OAAO,GAAGnC,QAAQ,CAACW,aAAa,CAAC2E,GAAG,CAAC;IAC3C,MAAMjD,KAAK,GAAGH,MAAM,CAACG,KAAK;IAC1B,MAAMmD,UAAU,GAAGnD,KAAK,CAACoD,OAAO;IAEhC,IAAID,UAAU,KAAKE,SAAS,EAAE;MAC5B,MAAMC,SAAS,GAAGH,UAAU,CAACF,GAAG,CAAC;MACjC3F,KAAK,CAACyC,sBAAsB,CAACD,OAAO,EAAEwD,SAAS,CAAC;IAClD;IAEA,OAAOxD,OAAO;EAChB;EAEAI,SAASA,CAACC,QAAQ,EAAEC,GAAG,EAAE;IACvB,OAAO,KAAK;EACd;EAEA,OAAOC,SAASA,CAAA,EAAG;IACjB,OAAO;MACLkD,EAAE,EAAEzF,IAAI,KAAK;QACXyC,UAAU,EAAEiD,qBAAqB;QACjC/C,QAAQ,EAAE;MACZ,CAAC,CAAC;MACFgD,EAAE,EAAE3F,IAAI,KAAK;QACXyC,UAAU,EAAEiD,qBAAqB;QACjC/C,QAAQ,EAAE;MACZ,CAAC,CAAC;MACFiD,EAAE,EAAE5F,IAAI,KAAK;QACXyC,UAAU,EAAEiD,qBAAqB;QACjC/C,QAAQ,EAAE;MACZ,CAAC,CAAC;MACFkD,EAAE,EAAE7F,IAAI,KAAK;QACXyC,UAAU,EAAEiD,qBAAqB;QACjC/C,QAAQ,EAAE;MACZ,CAAC,CAAC;MACFmD,EAAE,EAAE9F,IAAI,KAAK;QACXyC,UAAU,EAAEiD,qBAAqB;QACjC/C,QAAQ,EAAE;MACZ,CAAC,CAAC;MACFoD,EAAE,EAAE/F,IAAI,KAAK;QACXyC,UAAU,EAAEiD,qBAAqB;QACjC/C,QAAQ,EAAE;MACZ,CAAC,CAAC;MACFqD,CAAC,EAAEhG,IAAI,IAAI;QACT;QACA,MAAMyE,SAAS,GAAGzE,IAAI;QACtB,MAAMiG,UAAU,GAAGxB,SAAS,CAACwB,UAAU;QAEvC,IAAIA,UAAU,KAAK,IAAI,IAAIC,iBAAiB,CAACD,UAAU,CAAC,EAAE;UACxD,OAAO;YACLxD,UAAU,EAAEA,CAAA,MAAO;cACjBzC,IAAI,EAAE;YACR,CAAC,CAAC;YACF2C,QAAQ,EAAE;UACZ,CAAC;QACH;QAEA,OAAO,IAAI;MACb,CAAC;MACDwD,IAAI,EAAEnG,IAAI,IAAI;QACZ,IAAIkG,iBAAiB,CAAClG,IAAI,CAAC,EAAE;UAC3B,OAAO;YACLyC,UAAU,EAAE2D,OAAO,IAAI;cACrB,OAAO;gBACLpG,IAAI,EAAEqG,kBAAkB,CAAC,IAAI;cAC/B,CAAC;YACH,CAAC;YACD1D,QAAQ,EAAE;UACZ,CAAC;QACH;QAEA,OAAO,IAAI;MACb;IACF,CAAC;EACH;EAEAC,SAASA,CAACC,MAAM,EAAE;IAChB,MAAM;MACJb;IACF,CAAC,GAAG,KAAK,CAACY,SAAS,CAACC,MAAM,CAAC;IAE3B,IAAIb,OAAO,IAAIxC,KAAK,CAACsD,aAAa,CAACd,OAAO,CAAC,EAAE;MAC3C,IAAI,IAAI,CAACe,OAAO,CAAC,CAAC,EAAEf,OAAO,CAACgB,MAAM,CAACnD,QAAQ,CAACW,aAAa,CAAC,IAAI,CAAC,CAAC;MAChE,MAAMyC,UAAU,GAAG,IAAI,CAACC,aAAa,CAAC,CAAC;MACvClB,OAAO,CAACmB,KAAK,CAACC,SAAS,GAAGH,UAAU;MACpC,MAAMI,SAAS,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;MAErC,IAAID,SAAS,EAAE;QACbrB,OAAO,CAACuB,GAAG,GAAGF,SAAS;MACzB;IACF;IAEA,OAAO;MACLrB;IACF,CAAC;EACH;EAEA,OAAOwB,UAAUA,CAACC,cAAc,EAAE;IAChC,MAAMzD,IAAI,GAAGqG,kBAAkB,CAAC5C,cAAc,CAAC0B,GAAG,CAAC;IACnDnF,IAAI,CAAC2D,SAAS,CAACF,cAAc,CAACG,MAAM,CAAC;IACrC5D,IAAI,CAAC6D,SAAS,CAACJ,cAAc,CAACK,MAAM,CAAC;IACrC9D,IAAI,CAAC+D,YAAY,CAACN,cAAc,CAACJ,SAAS,CAAC;IAC3C,OAAOrD,IAAI;EACb;EAEAgE,UAAUA,CAAA,EAAG;IACX,OAAO;MAAE,GAAG,KAAK,CAACA,UAAU,CAAC,CAAC;MAC5BmB,GAAG,EAAE,IAAI,CAACC,MAAM,CAAC,CAAC;MAClBnB,IAAI,EAAE,SAAS;MACfqC,OAAO,EAAE;IACX,CAAC;EACH,CAAC,CAAC;;EAGFpC,cAAcA,CAAC3E,SAAS,EAAE6E,gBAAgB,GAAG,IAAI,EAAE;IACjD,MAAMmC,WAAW,GAAGhH,SAAS,GAAGA,SAAS,CAACiH,MAAM,CAACtG,MAAM,GAAG,CAAC;IAC3D,MAAMuG,UAAU,GAAGF,WAAW,GAAG,CAAC,IAAIA,WAAW,GAAG,IAAI,CAACG,kBAAkB,CAAC,CAAC,GAAGL,kBAAkB,CAAC,IAAI,CAACjB,MAAM,CAAC,CAAC,CAAC,GAAG3F,OAAO,CAAC6E,oBAAoB,CAAC,CAAC;IAClJ,MAAMjB,SAAS,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IACrCmD,UAAU,CAAC1C,YAAY,CAACV,SAAS,CAAC;IAClC,IAAI,CAACkB,WAAW,CAACkC,UAAU,EAAErC,gBAAgB,CAAC;IAC9C,OAAOqC,UAAU;EACnB;EAEAjC,eAAeA,CAAA,EAAG;IAChB,MAAMiC,UAAU,GAAG,CAAC,IAAI,CAAC1D,OAAO,CAAC,CAAC,GAAGsD,kBAAkB,CAAC,IAAI,CAACjB,MAAM,CAAC,CAAC,CAAC,GAAG3F,OAAO,CAAC6E,oBAAoB,CAAC,CAAC;IACvG,MAAMI,QAAQ,GAAG,IAAI,CAACC,WAAW,CAAC,CAAC;IACnCD,QAAQ,CAACE,OAAO,CAACC,KAAK,IAAI4B,UAAU,CAACzD,MAAM,CAAC6B,KAAK,CAAC,CAAC;IACnD,IAAI,CAACC,OAAO,CAAC2B,UAAU,CAAC;IACxB,OAAO,IAAI;EACb;EAEAE,gBAAgBA,CAAA,EAAG;IACjB,OAAO,IAAI;EACb;AAEF;AAEA,SAAST,iBAAiBA,CAACE,OAAO,EAAE;EAClC,IAAIA,OAAO,CAACQ,QAAQ,CAACC,WAAW,CAAC,CAAC,KAAK,MAAM,EAAE;IAC7C,OAAOT,OAAO,CAACjD,KAAK,CAAC2D,QAAQ,KAAK,MAAM;EAC1C;EAEA,OAAO,KAAK;AACd;AAEA,SAASpB,qBAAqBA,CAAC1D,OAAO,EAAE;EACtC,MAAM4E,QAAQ,GAAG5E,OAAO,CAAC4E,QAAQ,CAACC,WAAW,CAAC,CAAC;EAC/C,IAAI7G,IAAI,GAAG,IAAI;EAEf,IAAI4G,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,IAAI,EAAE;IAC9H5G,IAAI,GAAGqG,kBAAkB,CAACO,QAAQ,CAAC;IAEnC,IAAI5E,OAAO,CAACmB,KAAK,KAAK,IAAI,EAAE;MAC1BnD,IAAI,CAAC2D,SAAS,CAAC3B,OAAO,CAACmB,KAAK,CAACC,SAAS,CAAC;IACzC;EACF;EAEA,OAAO;IACLpD;EACF,CAAC;AACH;AAEA,SAAS0C,wBAAwBA,CAACV,OAAO,EAAE;EACzC,MAAMhC,IAAI,GAAG0D,gBAAgB,CAAC,CAAC;EAE/B,IAAI1B,OAAO,CAACmB,KAAK,KAAK,IAAI,EAAE;IAC1BnD,IAAI,CAAC2D,SAAS,CAAC3B,OAAO,CAACmB,KAAK,CAACC,SAAS,CAAC;EACzC;EAEA,OAAO;IACLpD;EACF,CAAC;AACH;AAEA,SAASqG,kBAAkBA,CAACU,UAAU,EAAE;EACtC,OAAOtH,OAAO,CAACsF,qBAAqB,CAAC,IAAIE,WAAW,CAAC8B,UAAU,CAAC,CAAC;AACnE;AACA,SAASC,cAAcA,CAAChH,IAAI,EAAE;EAC5B,OAAOA,IAAI,YAAYiF,WAAW;AACpC;AAEA,SAASgC,kBAAkBA,CAACC,KAAK,EAAErE,MAAM,EAAE;EACzCqE,KAAK,CAACC,cAAc,CAAC,CAAC;EACtBtE,MAAM,CAACuE,MAAM,CAAC,MAAM;IAClB,MAAM7H,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IACzC,MAAMC,aAAa,GAAGJ,KAAK,YAAYnG,UAAU,IAAImG,KAAK,YAAYK,aAAa,GAAG,IAAI,GAAGL,KAAK,CAACI,aAAa;IAEhH,IAAIA,aAAa,IAAI,IAAI,KAAK7H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,IAAIE,OAAO,CAACgI,2BAA2B,CAAClI,SAAS,CAAC,CAAC,EAAE;MACrHF,SAAS,CAACqI,8BAA8B,CAACJ,aAAa,EAAE/H,SAAS,EAAEsD,MAAM,CAAC;IAC5E;EACF,CAAC,EAAE;IACDsC,GAAG,EAAE;EACP,CAAC,CAAC;AACJ;AAEA,eAAewC,gBAAgBA,CAACT,KAAK,EAAErE,MAAM,EAAE;EAC7C,MAAMxD,SAAS,CAACuI,eAAe,CAAC/E,MAAM,EAAErD,KAAK,CAACqI,iBAAiB,CAACX,KAAK,EAAEY,cAAc,CAAC,GAAGZ,KAAK,GAAG,IAAI,CAAC;EACtGrE,MAAM,CAACuE,MAAM,CAAC,MAAM;IAClB,MAAM7H,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MACxCA,SAAS,CAACwI,UAAU,CAAC,CAAC;IACxB,CAAC,MAAM,IAAItI,OAAO,CAACuI,gBAAgB,CAACzI,SAAS,CAAC,EAAE;MAC9CA,SAAS,CAAC0I,QAAQ,CAAC,CAAC,CAACrD,OAAO,CAAC5E,IAAI,IAAIA,IAAI,CAACkI,MAAM,CAAC,CAAC,CAAC;IACrD;EACF,CAAC,CAAC;AACJ,CAAC,CAAC;AACF;AACA;;AAGA,SAASC,UAAUA,CAACjB,KAAK,EAAE;EACzB,IAAIkB,YAAY,GAAG,IAAI;EAEvB,IAAIlB,KAAK,YAAYmB,SAAS,EAAE;IAC9BD,YAAY,GAAGlB,KAAK,CAACkB,YAAY;EACnC,CAAC,MAAM,IAAIlB,KAAK,YAAYY,cAAc,EAAE;IAC1CM,YAAY,GAAGlB,KAAK,CAACI,aAAa;EACpC;EAEA,IAAIc,YAAY,KAAK,IAAI,EAAE;IACzB,OAAO,CAAC,KAAK,EAAE,EAAE,EAAE,KAAK,CAAC;EAC3B;EAEA,MAAME,KAAK,GAAGF,YAAY,CAACE,KAAK;EAChC,MAAMC,QAAQ,GAAGD,KAAK,CAACE,QAAQ,CAAC,OAAO,CAAC;EACxC,MAAMC,UAAU,GAAGH,KAAK,CAACE,QAAQ,CAAC,WAAW,CAAC,IAAIF,KAAK,CAACE,QAAQ,CAAC,YAAY,CAAC;EAC9E,OAAO,CAACD,QAAQ,EAAEG,KAAK,CAACC,IAAI,CAACP,YAAY,CAACQ,KAAK,CAAC,EAAEH,UAAU,CAAC;AAC/D;AAEA,SAASI,sBAAsBA,CAACC,eAAe,EAAE;EAC/C,MAAMvJ,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;EAEzC,IAAI,CAAC5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;IACzC,OAAO,KAAK;EACd;EAEA,MAAMwJ,cAAc,GAAG,IAAIC,GAAG,CAAC,CAAC;EAChC,MAAMC,KAAK,GAAG1J,SAAS,CAAC0I,QAAQ,CAAC,CAAC;EAElC,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,KAAK,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,MAAMlJ,IAAI,GAAGiJ,KAAK,CAACC,CAAC,CAAC;IACrB,MAAMrH,GAAG,GAAG7B,IAAI,CAACoJ,MAAM,CAAC,CAAC;IAEzB,IAAIL,cAAc,CAACM,GAAG,CAACxH,GAAG,CAAC,EAAE;MAC3B;IACF;IAEA,MAAMyH,WAAW,GAAG9J,KAAK,CAAC+J,sCAAsC,CAACvJ,IAAI,CAAC;IACtE,MAAMwJ,SAAS,GAAGF,WAAW,CAACF,MAAM,CAAC,CAAC;IAEtC,IAAIE,WAAW,CAACG,SAAS,CAAC,CAAC,IAAI,CAACV,cAAc,CAACM,GAAG,CAACG,SAAS,CAAC,EAAE;MAC7DT,cAAc,CAACW,GAAG,CAACF,SAAS,CAAC;MAC7BV,eAAe,CAACQ,WAAW,CAAC;IAC9B;EACF;EAEA,OAAOP,cAAc,CAACY,IAAI,GAAG,CAAC;AAChC;AAEA,SAASC,wBAAwBA,CAACC,MAAM,EAAE;EACxC,MAAM7J,IAAI,GAAGP,OAAO,CAACqK,0BAA0B,CAACD,MAAM,CAAC;EACvD,OAAOpK,OAAO,CAACsK,gBAAgB,CAAC/J,IAAI,CAAC;AACvC;AAEA,SAASgK,uBAAuBA,CAACzK,SAAS,EAAE;EAC1C,MAAM0K,KAAK,GAAG1K,SAAS,CAAC0K,KAAK;EAC7B,OAAOA,KAAK,CAACpI,GAAG,KAAK,MAAM,IAAIoI,KAAK,CAAC/J,MAAM,KAAKT,OAAO,CAACyK,QAAQ,CAAC,CAAC,CAACC,eAAe,CAAC,CAAC;AACtF;AAEA,SAASC,gBAAgBA,CAACvH,MAAM,EAAE;EAChC,MAAMwH,cAAc,GAAG7K,KAAK,CAAC8K,aAAa,CAACzH,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAAC+K,aAAa,EAAEC,OAAO,IAAI;IAClG,MAAMlL,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI5H,OAAO,CAACuI,gBAAgB,CAACzI,SAAS,CAAC,EAAE;MACvCA,SAAS,CAACmL,KAAK,CAAC,CAAC;MACjB,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd,CAAC,EAAE,CAAC,CAAC,EAAE7H,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACkL,wBAAwB,EAAEC,UAAU,IAAI;IAC5E,MAAMrL,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI,CAAC5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MACzC,OAAO,KAAK;IACd;IAEAA,SAAS,CAACsL,eAAe,CAACD,UAAU,CAAC;IACrC,OAAO,IAAI;EACb,CAAC,EAAEnL,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACsL,mBAAmB,EAAEH,UAAU,IAAI;IACrG,MAAMrL,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI,CAAC5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MACzC,OAAO,KAAK;IACd;IAEAA,SAAS,CAACyL,UAAU,CAACJ,UAAU,CAAC;IAChC,OAAO,IAAI;EACb,CAAC,EAAEnL,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACwL,mBAAmB,EAAEL,UAAU,IAAI;IACrG,MAAMrL,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI,CAAC5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MACzC,OAAO,KAAK;IACd;IAEAA,SAAS,CAAC2L,UAAU,CAACN,UAAU,CAAC;IAChC,OAAO,IAAI;EACb,CAAC,EAAEnL,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAAC0L,iCAAiC,EAAEC,WAAW,IAAI;IACpH,MAAM7L,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI,OAAO+D,WAAW,KAAK,QAAQ,EAAE;MACnC,IAAI3L,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;QACxCA,SAAS,CAAC8L,UAAU,CAACD,WAAW,CAAC;MACnC,CAAC,MAAM,IAAI3L,OAAO,CAACgI,2BAA2B,CAAClI,SAAS,CAAC,EAAE;IAC7D,CAAC,MAAM;MACL,IAAI,CAACE,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,IAAI,CAACE,OAAO,CAACgI,2BAA2B,CAAClI,SAAS,CAAC,EAAE;QAC5F,OAAO,KAAK;MACd;MAEA,MAAM6I,YAAY,GAAGgD,WAAW,CAAChD,YAAY;MAE7C,IAAIA,YAAY,IAAI,IAAI,EAAE;QACxB/I,SAAS,CAACqI,8BAA8B,CAACU,YAAY,EAAE7I,SAAS,EAAEsD,MAAM,CAAC;MAC3E,CAAC,MAAM,IAAIpD,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;QAC/C,MAAM+L,IAAI,GAAGF,WAAW,CAACE,IAAI;QAE7B,IAAIA,IAAI,EAAE;UACR/L,SAAS,CAAC8L,UAAU,CAACC,IAAI,CAAC;QAC5B;QAEA,OAAO,IAAI;MACb;IACF;IAEA,OAAO,IAAI;EACb,CAAC,EAAE7L,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAAC8L,mBAAmB,EAAE,MAAM;IAC7F,MAAMhM,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI,CAAC5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MACzC,OAAO,KAAK;IACd;IAEAA,SAAS,CAACwI,UAAU,CAAC,CAAC;IACtB,OAAO,IAAI;EACb,CAAC,EAAEtI,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAAC+L,mBAAmB,EAAE5H,MAAM,IAAI;IACjG,MAAMrE,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI,CAAC5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MACzC,OAAO,KAAK;IACd;IAEAA,SAAS,CAACkM,UAAU,CAAC7H,MAAM,CAAC;IAC5B,OAAO,IAAI;EACb,CAAC,EAAEnE,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACiM,sBAAsB,EAAE9H,MAAM,IAAI;IACpG,MAAMrE,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI,CAAC5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,IAAI,CAACE,OAAO,CAACuI,gBAAgB,CAACzI,SAAS,CAAC,EAAE;MACjF,OAAO,KAAK;IACd;IAEA,MAAM0J,KAAK,GAAG1J,SAAS,CAAC0I,QAAQ,CAAC,CAAC;IAElC,KAAK,MAAMjI,IAAI,IAAIiJ,KAAK,EAAE;MACxB,MAAMjH,OAAO,GAAGxC,KAAK,CAACmM,mBAAmB,CAAC3L,IAAI,EAAE4L,UAAU,IAAInM,OAAO,CAACoM,cAAc,CAACD,UAAU,CAAC,IAAI,CAACA,UAAU,CAACE,QAAQ,CAAC,CAAC,CAAC;MAE3H,IAAI9J,OAAO,KAAK,IAAI,EAAE;QACpBA,OAAO,CAAC2B,SAAS,CAACC,MAAM,CAAC;MAC3B;IACF;IAEA,OAAO,IAAI;EACb,CAAC,EAAEnE,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACsM,yBAAyB,EAAEC,WAAW,IAAI;IAC5G,MAAMzM,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI,CAAC5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MACzC,OAAO,KAAK;IACd;IAEAA,SAAS,CAAC0M,eAAe,CAACD,WAAW,CAAC;IACtC,OAAO,IAAI;EACb,CAAC,EAAEvM,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACyM,wBAAwB,EAAE,MAAM;IAClG,MAAM3M,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI,CAAC5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MACzC,OAAO,KAAK;IACd;IAEAA,SAAS,CAAC4M,eAAe,CAAC,CAAC;IAC3B,OAAO,IAAI;EACb,CAAC,EAAE1M,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAAC2M,kBAAkB,EAAE,MAAM;IAC5F3M,OAAO,CAAC4M,YAAY,CAAC,CAAC5M,OAAO,CAAC6M,cAAc,CAAC,CAAC,CAAC,CAAC;IAChD,OAAO,IAAI;EACb,CAAC,EAAE7M,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAAC8M,sBAAsB,EAAE,MAAM;IAChG,OAAO1D,sBAAsB,CAAC2D,KAAK,IAAI;MACrC,MAAM1I,MAAM,GAAG0I,KAAK,CAACC,SAAS,CAAC,CAAC;MAChCD,KAAK,CAAC3I,SAAS,CAACC,MAAM,GAAG,CAAC,CAAC;IAC7B,CAAC,CAAC;EACJ,CAAC,EAAErE,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACiN,uBAAuB,EAAE,MAAM;IACjG,OAAO7D,sBAAsB,CAAC2D,KAAK,IAAI;MACrC,MAAM1I,MAAM,GAAG0I,KAAK,CAACC,SAAS,CAAC,CAAC;MAEhC,IAAI3I,MAAM,GAAG,CAAC,EAAE;QACd0I,KAAK,CAAC3I,SAAS,CAACC,MAAM,GAAG,CAAC,CAAC;MAC7B;IACF,CAAC,CAAC;EACJ,CAAC,EAAErE,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACkN,oBAAoB,EAAEzF,KAAK,IAAI;IACjG,MAAM3H,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI5H,OAAO,CAACuI,gBAAgB,CAACzI,SAAS,CAAC,IAAI,CAACqK,wBAAwB,CAAC1C,KAAK,CAAC2C,MAAM,CAAC,EAAE;MAClF;MACA;MACA,MAAMZ,KAAK,GAAG1J,SAAS,CAAC0I,QAAQ,CAAC,CAAC;MAElC,IAAIgB,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;QACpBF,KAAK,CAAC,CAAC,CAAC,CAAC2D,cAAc,CAAC,CAAC;QACzB,OAAO,IAAI;MACb;IACF,CAAC,MAAM,IAAInN,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MAC/C,MAAMsN,YAAY,GAAGpN,OAAO,CAACqN,gBAAgB,CAACvN,SAAS,CAAC0K,KAAK,EAAE,IAAI,CAAC;MAEpE,IAAI,CAAC/C,KAAK,CAAC6F,QAAQ,IAAItN,OAAO,CAACsK,gBAAgB,CAAC8C,YAAY,CAAC,IAAI,CAACA,YAAY,CAACG,UAAU,CAAC,CAAC,IAAI,CAACH,YAAY,CAACf,QAAQ,CAAC,CAAC,EAAE;QACvHe,YAAY,CAACD,cAAc,CAAC,CAAC;QAC7B1F,KAAK,CAACC,cAAc,CAAC,CAAC;QACtB,OAAO,IAAI;MACb;IACF;IAEA,OAAO,KAAK;EACd,CAAC,EAAE1H,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACwN,sBAAsB,EAAE/F,KAAK,IAAI;IACnG,MAAM3H,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI5H,OAAO,CAACuI,gBAAgB,CAACzI,SAAS,CAAC,EAAE;MACvC;MACA;MACA,MAAM0J,KAAK,GAAG1J,SAAS,CAAC0I,QAAQ,CAAC,CAAC;MAElC,IAAIgB,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;QACpBF,KAAK,CAAC,CAAC,CAAC,CAACiE,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC;QACzB,OAAO,IAAI;MACb;IACF,CAAC,MAAM,IAAIzN,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MAC/C,IAAIyK,uBAAuB,CAACzK,SAAS,CAAC,EAAE;QACtC2H,KAAK,CAACC,cAAc,CAAC,CAAC;QACtB,OAAO,IAAI;MACb;MAEA,MAAM0F,YAAY,GAAGpN,OAAO,CAACqN,gBAAgB,CAACvN,SAAS,CAAC0K,KAAK,EAAE,KAAK,CAAC;MAErE,IAAI,CAAC/C,KAAK,CAAC6F,QAAQ,IAAItN,OAAO,CAACsK,gBAAgB,CAAC8C,YAAY,CAAC,IAAI,CAACA,YAAY,CAACG,UAAU,CAAC,CAAC,IAAI,CAACH,YAAY,CAACf,QAAQ,CAAC,CAAC,EAAE;QACvHe,YAAY,CAACK,UAAU,CAAC,CAAC;QACzBhG,KAAK,CAACC,cAAc,CAAC,CAAC;QACtB,OAAO,IAAI;MACb;IACF;IAEA,OAAO,KAAK;EACd,CAAC,EAAE1H,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAAC0N,sBAAsB,EAAEjG,KAAK,IAAI;IACnG,MAAMkG,WAAW,GAAG3N,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAE3C,IAAI5H,OAAO,CAACuI,gBAAgB,CAACoF,WAAW,CAAC,EAAE;MACzC;MACA;MACA,MAAMnE,KAAK,GAAGmE,WAAW,CAACnF,QAAQ,CAAC,CAAC;MAEpC,IAAIgB,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;QACpBjC,KAAK,CAACC,cAAc,CAAC,CAAC;QACtB8B,KAAK,CAAC,CAAC,CAAC,CAAC2D,cAAc,CAAC,CAAC;QACzB,OAAO,IAAI;MACb;IACF;IAEA,IAAI,CAACnN,OAAO,CAAC+H,iBAAiB,CAAC4F,WAAW,CAAC,EAAE;MAC3C,OAAO,KAAK;IACd;IAEA,IAAI7N,SAAS,CAAC8N,wCAAwC,CAACD,WAAW,EAAE,IAAI,CAAC,EAAE;MACzE,MAAME,cAAc,GAAGpG,KAAK,CAAC6F,QAAQ;MACrC7F,KAAK,CAACC,cAAc,CAAC,CAAC;MACtB5H,SAAS,CAACgO,cAAc,CAACH,WAAW,EAAEE,cAAc,EAAE,IAAI,CAAC;MAC3D,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd,CAAC,EAAE7N,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAAC+N,uBAAuB,EAAEtG,KAAK,IAAI;IACpG,MAAMkG,WAAW,GAAG3N,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAE3C,IAAI5H,OAAO,CAACuI,gBAAgB,CAACoF,WAAW,CAAC,IAAI,CAACxD,wBAAwB,CAAC1C,KAAK,CAAC2C,MAAM,CAAC,EAAE;MACpF;MACA;MACA,MAAMZ,KAAK,GAAGmE,WAAW,CAACnF,QAAQ,CAAC,CAAC;MAEpC,IAAIgB,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;QACpBjC,KAAK,CAACC,cAAc,CAAC,CAAC;QACtB8B,KAAK,CAAC,CAAC,CAAC,CAACiE,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC;QACzB,OAAO,IAAI;MACb;IACF;IAEA,IAAI,CAACzN,OAAO,CAAC+H,iBAAiB,CAAC4F,WAAW,CAAC,EAAE;MAC3C,OAAO,KAAK;IACd;IAEA,MAAME,cAAc,GAAGpG,KAAK,CAAC6F,QAAQ;IAErC,IAAIxN,SAAS,CAAC8N,wCAAwC,CAACD,WAAW,EAAE,KAAK,CAAC,EAAE;MAC1ElG,KAAK,CAACC,cAAc,CAAC,CAAC;MACtB5H,SAAS,CAACgO,cAAc,CAACH,WAAW,EAAEE,cAAc,EAAE,KAAK,CAAC;MAC5D,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd,CAAC,EAAE7N,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACgO,qBAAqB,EAAEvG,KAAK,IAAI;IAClG,IAAI0C,wBAAwB,CAAC1C,KAAK,CAAC2C,MAAM,CAAC,EAAE;MAC1C,OAAO,KAAK;IACd;IAEA,MAAMtK,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI,CAAC5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MACzC,OAAO,KAAK;IACd;IAEA2H,KAAK,CAACC,cAAc,CAAC,CAAC;IACtB,MAAM;MACJX;IACF,CAAC,GAAGjH,SAAS;IACb,MAAMmO,UAAU,GAAGlH,MAAM,CAACmH,OAAO,CAAC,CAAC;IAEnC,IAAIpO,SAAS,CAACqO,WAAW,CAAC,CAAC,IAAIpH,MAAM,CAACtG,MAAM,KAAK,CAAC,IAAI,CAACT,OAAO,CAACoO,WAAW,CAACH,UAAU,CAAC,EAAE;MACtF,MAAM1L,OAAO,GAAGxC,KAAK,CAAC+J,sCAAsC,CAACmE,UAAU,CAAC;MAExE,IAAI1L,OAAO,CAACyK,SAAS,CAAC,CAAC,GAAG,CAAC,EAAE;QAC3B,OAAO5J,MAAM,CAACiL,eAAe,CAACrO,OAAO,CAACiN,uBAAuB,EAAEnH,SAAS,CAAC;MAC3E;IACF;IAEA,OAAO1C,MAAM,CAACiL,eAAe,CAACrO,OAAO,CAACkL,wBAAwB,EAAE,IAAI,CAAC;EACvE,CAAC,EAAElL,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACsO,kBAAkB,EAAE7G,KAAK,IAAI;IAC/F,IAAI0C,wBAAwB,CAAC1C,KAAK,CAAC2C,MAAM,CAAC,EAAE;MAC1C,OAAO,KAAK;IACd;IAEA,MAAMtK,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI,CAAC5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MACzC,OAAO,KAAK;IACd;IAEA2H,KAAK,CAACC,cAAc,CAAC,CAAC;IACtB,OAAOtE,MAAM,CAACiL,eAAe,CAACrO,OAAO,CAACkL,wBAAwB,EAAE,KAAK,CAAC;EACxE,CAAC,EAAElL,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACuO,iBAAiB,EAAE9G,KAAK,IAAI;IAC9F,MAAM3H,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI,CAAC5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MACzC,OAAO,KAAK;IACd;IAEA,IAAI2H,KAAK,KAAK,IAAI,EAAE;MAClB;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAI,CAACjG,MAAM,IAAID,SAAS,IAAII,eAAe,KAAKN,oBAAoB,EAAE;QACpE,OAAO,KAAK;MACd;MAEAoG,KAAK,CAACC,cAAc,CAAC,CAAC;MAEtB,IAAID,KAAK,CAAC6F,QAAQ,EAAE;QAClB,OAAOlK,MAAM,CAACiL,eAAe,CAACrO,OAAO,CAACsM,yBAAyB,EAAE,KAAK,CAAC;MACzE;IACF;IAEA,OAAOlJ,MAAM,CAACiL,eAAe,CAACrO,OAAO,CAACyM,wBAAwB,EAAE3G,SAAS,CAAC;EAC5E,CAAC,EAAE9F,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACwO,kBAAkB,EAAE,MAAM;IAC5F,MAAM1O,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI,CAAC5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MACzC,OAAO,KAAK;IACd;IAEAsD,MAAM,CAACqL,IAAI,CAAC,CAAC;IACb,OAAO,IAAI;EACb,CAAC,EAAEzO,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAAC0O,YAAY,EAAEjH,KAAK,IAAI;IACzF,MAAM,GAAG0B,KAAK,CAAC,GAAGT,UAAU,CAACjB,KAAK,CAAC;IAEnC,IAAI0B,KAAK,CAACO,MAAM,GAAG,CAAC,EAAE;MACpB,MAAMxJ,CAAC,GAAGuH,KAAK,CAACkH,OAAO;MACvB,MAAMxO,CAAC,GAAGsH,KAAK,CAACmH,OAAO;MACvB,MAAMC,UAAU,GAAG5O,cAAc,CAACC,CAAC,EAAEC,CAAC,CAAC;MAEvC,IAAI0O,UAAU,KAAK,IAAI,EAAE;QACvB,MAAM;UACJpO,MAAM,EAAEqO,SAAS;UACjBvO,IAAI,EAAEoG;QACR,CAAC,GAAGkI,UAAU;QACd,MAAMtO,IAAI,GAAGP,OAAO,CAACqK,0BAA0B,CAAC1D,OAAO,CAAC;QAExD,IAAIpG,IAAI,KAAK,IAAI,EAAE;UACjB,MAAMT,SAAS,GAAGE,OAAO,CAAC+O,qBAAqB,CAAC,CAAC;UAEjD,IAAI/O,OAAO,CAACgP,WAAW,CAACzO,IAAI,CAAC,EAAE;YAC7BT,SAAS,CAACiH,MAAM,CAACkI,GAAG,CAAC1O,IAAI,CAACoJ,MAAM,CAAC,CAAC,EAAEmF,SAAS,EAAE,MAAM,CAAC;YACtDhP,SAAS,CAAC0K,KAAK,CAACyE,GAAG,CAAC1O,IAAI,CAACoJ,MAAM,CAAC,CAAC,EAAEmF,SAAS,EAAE,MAAM,CAAC;UACvD,CAAC,MAAM;YACL,MAAM/E,SAAS,GAAGxJ,IAAI,CAAC2O,gBAAgB,CAAC,CAAC,CAACvF,MAAM,CAAC,CAAC;YAClD,MAAMlJ,MAAM,GAAGF,IAAI,CAAC4O,oBAAoB,CAAC,CAAC,GAAG,CAAC;YAC9CrP,SAAS,CAACiH,MAAM,CAACkI,GAAG,CAAClF,SAAS,EAAEtJ,MAAM,EAAE,SAAS,CAAC;YAClDX,SAAS,CAAC0K,KAAK,CAACyE,GAAG,CAAClF,SAAS,EAAEtJ,MAAM,EAAE,SAAS,CAAC;UACnD;UAEA,MAAM2O,mBAAmB,GAAGpP,OAAO,CAACqP,iCAAiC,CAACvP,SAAS,CAAC;UAChFE,OAAO,CAACsP,aAAa,CAACF,mBAAmB,CAAC;QAC5C;QAEAhM,MAAM,CAACiL,eAAe,CAACzM,eAAe,EAAEuH,KAAK,CAAC;MAChD;MAEA1B,KAAK,CAACC,cAAc,CAAC,CAAC;MACtB,OAAO,IAAI;IACb;IAEA,MAAM5H,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MACxC,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd,CAAC,EAAEE,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACuP,iBAAiB,EAAE9H,KAAK,IAAI;IAC9F,MAAM,CAAC+H,cAAc,CAAC,GAAG9G,UAAU,CAACjB,KAAK,CAAC;IAC1C,MAAM3H,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI4H,cAAc,IAAI,CAACxP,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MAC3D,OAAO,KAAK;IACd;IAEA,OAAO,IAAI;EACb,CAAC,EAAEE,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAACyP,gBAAgB,EAAEhI,KAAK,IAAI;IAC7F,MAAM,CAAC+H,cAAc,CAAC,GAAG9G,UAAU,CAACjB,KAAK,CAAC;IAC1C,MAAM3H,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI4H,cAAc,IAAI,CAACxP,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,EAAE;MAC3D,OAAO,KAAK;IACd;IAEA,MAAMI,CAAC,GAAGuH,KAAK,CAACkH,OAAO;IACvB,MAAMxO,CAAC,GAAGsH,KAAK,CAACmH,OAAO;IACvB,MAAMC,UAAU,GAAG5O,cAAc,CAACC,CAAC,EAAEC,CAAC,CAAC;IAEvC,IAAI0O,UAAU,KAAK,IAAI,EAAE;MACvB,MAAMtO,IAAI,GAAGP,OAAO,CAACqK,0BAA0B,CAACwE,UAAU,CAACtO,IAAI,CAAC;MAEhE,IAAIP,OAAO,CAACsK,gBAAgB,CAAC/J,IAAI,CAAC,EAAE;QAClC;QACA;QACAkH,KAAK,CAACC,cAAc,CAAC,CAAC;MACxB;IACF;IAEA,OAAO,IAAI;EACb,CAAC,EAAE1H,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAAC0P,kBAAkB,EAAE,MAAM;IAC5F1P,OAAO,CAAC2P,UAAU,CAAC,CAAC;IACpB,OAAO,IAAI;EACb,CAAC,EAAE3P,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAAC4P,YAAY,EAAEnI,KAAK,IAAI;IACzF7H,SAAS,CAACuI,eAAe,CAAC/E,MAAM,EAAErD,KAAK,CAACqI,iBAAiB,CAACX,KAAK,EAAEY,cAAc,CAAC,GAAGZ,KAAK,GAAG,IAAI,CAAC;IAChG,OAAO,IAAI;EACb,CAAC,EAAEzH,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAAC6P,WAAW,EAAEpI,KAAK,IAAI;IACxFS,gBAAgB,CAACT,KAAK,EAAErE,MAAM,CAAC;IAC/B,OAAO,IAAI;EACb,CAAC,EAAEpD,OAAO,CAACqL,uBAAuB,CAAC,EAAEjI,MAAM,CAAC0H,eAAe,CAAC9K,OAAO,CAAC8P,aAAa,EAAErI,KAAK,IAAI;IAC1F,MAAM,GAAG0B,KAAK,EAAE4G,cAAc,CAAC,GAAGrH,UAAU,CAACjB,KAAK,CAAC;IAEnD,IAAI0B,KAAK,CAACO,MAAM,GAAG,CAAC,IAAI,CAACqG,cAAc,EAAE;MACvC3M,MAAM,CAACiL,eAAe,CAACzM,eAAe,EAAEuH,KAAK,CAAC;MAC9C,OAAO,IAAI;IACb,CAAC,CAAC;;IAGF,IAAInJ,OAAO,CAACgQ,mCAAmC,CAACvI,KAAK,CAAC2C,MAAM,CAAC,EAAE;MAC7D,OAAO,KAAK;IACd;IAEA,MAAMtK,SAAS,GAAGE,OAAO,CAAC4H,aAAa,CAAC,CAAC;IAEzC,IAAI5H,OAAO,CAAC+H,iBAAiB,CAACjI,SAAS,CAAC,IAAIE,OAAO,CAACgI,2BAA2B,CAAClI,SAAS,CAAC,EAAE;MAC1F0H,kBAAkB,CAACC,KAAK,EAAErE,MAAM,CAAC;MACjC,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd,CAAC,EAAEpD,OAAO,CAACqL,uBAAuB,CAAC,CAAC;EACpC,OAAOT,cAAc;AACvB;AAEAqF,OAAO,CAACrJ,kBAAkB,GAAGA,kBAAkB;AAC/CqJ,OAAO,CAAChM,gBAAgB,GAAGA,gBAAgB;AAC3CgM,OAAO,CAAC1I,cAAc,GAAGA,cAAc;AACvC0I,OAAO,CAAC1K,YAAY,GAAGA,YAAY;AACnC0K,OAAO,CAACrO,eAAe,GAAGA,eAAe;AACzCqO,OAAO,CAACzK,WAAW,GAAGA,WAAW;AACjCyK,OAAO,CAACnO,SAAS,GAAGA,SAAS;AAC7BmO,OAAO,CAACvH,UAAU,GAAGA,UAAU;AAC/BuH,OAAO,CAACtF,gBAAgB,GAAGA,gBAAgB"},"metadata":{},"sourceType":"script","externalDependencies":[]}