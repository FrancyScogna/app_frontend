{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar code = require('@lexical/code');\nvar list = require('@lexical/list');\nvar richText = require('@lexical/rich-text');\nvar utils = require('@lexical/utils');\nvar link = require('@lexical/link');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n  for (const item of list) {\n    const key = callback(item);\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createMarkdownExport(transformers) {\n  const byType = transformersByType(transformers); // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1);\n  return node => {\n    const output = [];\n    const children = (node || lexical.$getRoot()).getChildren();\n    for (const child of children) {\n      const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);\n      if (result != null) {\n        output.push(result);\n      }\n    }\n    return output.join('\\n\\n');\n  };\n}\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n    if (result != null) {\n      return result;\n    }\n  }\n  if (lexical.$isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if (lexical.$isDecoratorNode(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers) {\n  const output = [];\n  const children = node.getChildren();\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n    if (lexical.$isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if (lexical.$isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n    } else if (lexical.$isElementNode(child)) {\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n    } else if (lexical.$isDecoratorNode(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n  return output.join('');\n}\nfunction exportTextFormat(node, textContent, textTransformers) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim();\n  let output = frozenString;\n  const applied = new Set();\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format); // Prevent adding opening tag is already opened by the previous sibling\n\n      const previousNode = getTextSibling(node, true);\n      if (!hasFormat(previousNode, format)) {\n        output = tag + output;\n      } // Prevent adding closing tag if next sibling will do it\n\n      const nextNode = getTextSibling(node, false);\n      if (!hasFormat(nextNode, format)) {\n        output += tag;\n      }\n    }\n  } // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n\n  return textContent.replace(frozenString, output);\n} // Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\n\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n  while (sibling) {\n    if (lexical.$isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n      if (lexical.$isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n    if (lexical.$isTextNode(sibling)) {\n      return sibling;\n    }\n    if (!lexical.$isElementNode(sibling)) {\n      return null;\n    }\n  }\n  return null;\n}\nfunction hasFormat(node, format) {\n  return lexical.$isTextNode(node) && node.hasFormat(format);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nconst CODE_BLOCK_REG_EXP = /^```(\\w{1,10})?\\s?$/;\nfunction createMarkdownImport(transformers) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || lexical.$getRoot();\n    root.clear();\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i]; // Codeblocks are processed first as anything inside such block\n      // is ignored for further processing\n      // TODO:\n      // Abstract it to be dynamic as other transformers (add multiline match option)\n\n      const [codeBlockNode, shiftedIndex] = importCodeBlock(lines, i, root);\n      if (codeBlockNode != null) {\n        i = shiftedIndex;\n        continue;\n      }\n      importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n    } // Removing empty paragraphs as md does not really\n    // allow empty lines and uses them as dilimiter\n\n    const children = root.getChildren();\n    for (const child of children) {\n      if (isEmptyParagraph(child)) {\n        child.remove();\n      }\n    }\n    if (lexical.$getSelection() !== null) {\n      root.selectEnd();\n    }\n  };\n}\nfunction isEmptyParagraph(node) {\n  if (!lexical.$isParagraphNode(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\nfunction importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n  const lineTextTrimmed = lineText.trim();\n  const textNode = lexical.$createTextNode(lineTextTrimmed);\n  const elementNode = lexical.$createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      replace(elementNode, [textNode], match, true);\n      break;\n    }\n  }\n  importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers); // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n\n  if (elementNode.isAttached() && lineTextTrimmed.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n    if (lexical.$isParagraphNode(previousNode) || richText.$isQuoteNode(previousNode) || list.$isListNode(previousNode)) {\n      let targetNode = previousNode;\n      if (list.$isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = utils.$findMatchingParent(lastDescendant, list.$isListItemNode);\n        }\n      }\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\nfunction importCodeBlock(lines, startLineIndex, rootNode) {\n  const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);\n  if (openMatch) {\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n    while (++endLineIndex < linesLength) {\n      const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);\n      if (closeMatch) {\n        const codeBlockNode = code.$createCodeNode(openMatch[1]);\n        const textNode = lexical.$createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join('\\n'));\n        codeBlockNode.append(textNode);\n        rootNode.append(codeBlockNode);\n        return [codeBlockNode, endLineIndex];\n      }\n    }\n  }\n  return [null, startLineIndex];\n} // Processing text content and replaces text format tags.\n// It takes outermost tag match and its content, creates text node with\n// format based on tag and then recursively executed over node's content\n//\n// E.g. for \"*Hello **world**!*\" string it will create text node with\n// \"Hello **world**!\" content and italic format and run recursively over\n// its content to transform \"**world**\" part\n\nfunction importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n  if (!match) {\n    // Once text format processing is done run text match transformers, as it\n    // only can span within single text node (unline formats that can cover multiple nodes)\n    importTextMatchTransformers(textNode, textMatchTransformers);\n    return;\n  }\n  let currentNode, remainderNode, leadingNode; // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n\n  if (match[0] === textContent) {\n    currentNode = textNode;\n  } else {\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    if (startIndex === 0) {\n      [currentNode, remainderNode] = textNode.splitText(endIndex);\n    } else {\n      [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n  currentNode.setTextContent(match[2]);\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!currentNode.hasFormat(format)) {\n        currentNode.toggleFormat(format);\n      }\n    }\n  } // Recursively run over inner text if it's not inline code\n\n  if (!currentNode.hasFormat('code')) {\n    importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n  } // Run over leading/remaining text if any\n\n  if (leadingNode) {\n    importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n  if (remainderNode) {\n    importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n}\nfunction importTextMatchTransformers(textNode_, textMatchTransformers) {\n  let textNode = textNode_;\n  mainLoop: while (textNode) {\n    for (const transformer of textMatchTransformers) {\n      const match = textNode.getTextContent().match(transformer.importRegExp);\n      if (!match) {\n        continue;\n      }\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      let replaceNode, leftTextNode, rightTextNode;\n      if (startIndex === 0) {\n        [replaceNode, textNode] = textNode.splitText(endIndex);\n      } else {\n        [leftTextNode, replaceNode, rightTextNode] = textNode.splitText(startIndex, endIndex);\n      }\n      if (leftTextNode) {\n        importTextMatchTransformers(leftTextNode, textMatchTransformers);\n      }\n      if (rightTextNode) {\n        textNode = rightTextNode;\n      }\n      transformer.replace(replaceNode, match);\n      continue mainLoop;\n    }\n    break;\n  }\n} // Finds first \"<tag>content<tag>\" match that is not nested into another tag\n\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n  if (openTagsMatch == null) {\n    return null;\n  }\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      } // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n  return null;\n}\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n    if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n    } else {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    }\n  }\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Reg exp to find opening tags\n    openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? '' : `${escapeRegExp}`) + '(' + openTagsRegExp.join('|') + ')', 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!lexical.$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent(); // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n    if (match && match[0].length === anchorOffset) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      replace(parentNode, siblings, match, false);\n      return true;\n    }\n  }\n  return false;\n}\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n  if (transformers == null) {\n    return false;\n  } // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n  for (const transformer of transformers) {\n    const match = textContent.match(transformer.regExp);\n    if (match === null) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n  return false;\n}\nfunction runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex]; // Quick check if we're possibly at the end of inline markdown style\n\n  const matchers = textFormatTransformers[closeChar];\n  if (!matchers) {\n    return false;\n  }\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1; // If tag is not single char check if rest of it matches with text content\n\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    } // Space before closing tag cancels inline markdown\n\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation after it\n\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag); // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n\n    let sibling = openNode;\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if (lexical.$isLineBreakNode(sibling)) {\n        break;\n      }\n      if (lexical.$isTextNode(sibling)) {\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    } // Opening tag is not found\n\n    if (openTagStartIndex < 0) {\n      continue;\n    } // No content between opening and closing tag\n\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    } // Checking longer tags for repeating chars (e.g. *** vs **)\n\n    const prevOpenNodeText = openNode.getTextContent();\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation before it\n\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    } // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = lexical.$getSelection();\n    const nextSelection = lexical.$createRangeSelection();\n    lexical.$setSelection(nextSelection); // Adjust offset based on deleted chars\n\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text'); // Apply formatting to selected text\n\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    } // Collapse selection up to the focus point\n\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type); // Remove formatting from collapsed selection\n\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n    if (lexical.$isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n    return true;\n  }\n  return false;\n}\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) &&\n    // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n  return -1;\n}\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersIndex = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n  for (const transformer of transformers) {\n    const type = transformer.type;\n    if (type === 'element' || type === 'text-match') {\n      const dependencies = transformer.dependencies;\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            throw Error(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n  const transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {\n      return;\n    }\n    runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);\n  };\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from undo/redo (as changes already calculated)\n    if (tags.has('historic')) {\n      return;\n    } // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n\n    if (editor.isComposing()) {\n      return;\n    }\n    const selection = editorState.read(lexical.$getSelection);\n    const prevSelection = prevEditorState.read(lexical.$getSelection);\n    if (!lexical.$isRangeSelection(prevSelection) || !lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return;\n    }\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n    if (!lexical.$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return;\n      }\n      const parentNode = anchorNode.getParent();\n      if (parentNode === null || code.$isCodeNode(parentNode)) {\n        return;\n      }\n      transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst createBlockNode = createNode => {\n  return (parentNode, children, match) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  };\n}; // Amount of spaces that define indentation level\n// TODO: should be an option\n\nconst LIST_INDENT_SIZE = 4;\nconst listReplace = listType => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = list.$createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n    if (list.$isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n      parentNode.remove();\n    } else if (list.$isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list$1 = list.$createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list$1.append(listItem);\n      parentNode.replace(list$1);\n    }\n    listItem.append(...children);\n    listItem.select(0, 0);\n    const indent = Math.floor(match[1].length / LIST_INDENT_SIZE);\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n  for (const listItemNode of children) {\n    if (list.$isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n        if (list.$isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n  return output.join('\\n');\n};\nconst HEADING = {\n  dependencies: [richText.HeadingNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isHeadingNode(node)) {\n      return null;\n    }\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: /^(#{1,6})\\s/,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return richText.$createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [richText.QuoteNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isQuoteNode(node)) {\n      return null;\n    }\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n    return output.join('\\n');\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n      if (richText.$isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...children]);\n        previousNode.select(0, 0);\n        parentNode.remove();\n        return;\n      }\n    }\n    const node = richText.$createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [code.CodeNode],\n  export: node => {\n    if (!code.$isCodeNode(node)) {\n      return null;\n    }\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExp: /^```(\\w{1,10})?\\s/,\n  replace: createBlockNode(match => {\n    return code.$createCodeNode(match ? match[1] : undefined);\n  }),\n  type: 'element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(\\d{1,})\\.\\s/,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n}; // Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst LINK = {\n  dependencies: [link.LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!link.$isLinkNode(node)) {\n      return null;\n    }\n    const title = node.getTitle();\n    const linkContent = title ? `[${node.getTextContent()}](${node.getURL()} \"${title}\")` : `[${node.getTextContent()}](${node.getURL()})`;\n    const firstChild = node.getFirstChild(); // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n\n    if (node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild)) {\n      return exportFormat(firstChild, linkContent);\n    } else {\n      return linkContent;\n    }\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = link.$createLinkNode(linkUrl, {\n      title: linkTitle\n    });\n    const linkTextNode = lexical.$createTextNode(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n  },\n  trigger: ')',\n  type: 'text-match'\n};\n\n/** @module @lexical/markdown */\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, CODE, UNORDERED_LIST, ORDERED_LIST]; // Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node) {\n  const importMarkdown = createMarkdownImport(transformers);\n  return importMarkdown(markdown, node);\n}\nfunction $convertToMarkdownString(transformers = TRANSFORMERS, node) {\n  const exportMarkdown = createMarkdownExport(transformers);\n  return exportMarkdown(node);\n}\nexports.$convertFromMarkdownString = $convertFromMarkdownString;\nexports.$convertToMarkdownString = $convertToMarkdownString;\nexports.BOLD_ITALIC_STAR = BOLD_ITALIC_STAR;\nexports.BOLD_ITALIC_UNDERSCORE = BOLD_ITALIC_UNDERSCORE;\nexports.BOLD_STAR = BOLD_STAR;\nexports.BOLD_UNDERSCORE = BOLD_UNDERSCORE;\nexports.CHECK_LIST = CHECK_LIST;\nexports.CODE = CODE;\nexports.ELEMENT_TRANSFORMERS = ELEMENT_TRANSFORMERS;\nexports.HEADING = HEADING;\nexports.HIGHLIGHT = HIGHLIGHT;\nexports.INLINE_CODE = INLINE_CODE;\nexports.ITALIC_STAR = ITALIC_STAR;\nexports.ITALIC_UNDERSCORE = ITALIC_UNDERSCORE;\nexports.LINK = LINK;\nexports.ORDERED_LIST = ORDERED_LIST;\nexports.QUOTE = QUOTE;\nexports.STRIKETHROUGH = STRIKETHROUGH;\nexports.TEXT_FORMAT_TRANSFORMERS = TEXT_FORMAT_TRANSFORMERS;\nexports.TEXT_MATCH_TRANSFORMERS = TEXT_MATCH_TRANSFORMERS;\nexports.TRANSFORMERS = TRANSFORMERS;\nexports.UNORDERED_LIST = UNORDERED_LIST;\nexports.registerMarkdownShortcuts = registerMarkdownShortcuts;","map":{"version":3,"names":["lexical","require","code","list","richText","utils","link","indexBy","callback","index","item","key","push","transformersByType","transformers","byType","t","type","element","textFormat","textMatch","PUNCTUATION_OR_SPACE","createMarkdownExport","textFormatTransformers","filter","transformer","format","length","node","output","children","$getRoot","getChildren","child","result","exportTopLevelElements","join","elementTransformers","textTransformersIndex","textMatchTransformers","export","_node","exportChildren","$isElementNode","$isDecoratorNode","getTextContent","mainLoop","parentNode","textNode","textContent","exportTextFormat","$isLineBreakNode","$isTextNode","textTransformers","frozenString","trim","applied","Set","tag","hasFormat","has","add","previousNode","getTextSibling","nextNode","replace","backward","sibling","getPreviousSibling","getNextSibling","parent","getParentOrThrow","isInline","descendant","getLastDescendant","getFirstDescendant","CAN_USE_DOM","window","document","createElement","documentMode","test","navigator","platform","userAgent","InputEvent","IS_SAFARI","IS_IOS","MSStream","IS_CHROME","IS_APPLE_WEBKIT","MARKDOWN_EMPTY_LINE_REG_EXP","CODE_BLOCK_REG_EXP","createMarkdownImport","textFormatTransformersIndex","createTextFormatTransformersIndex","markdownString","lines","split","linesLength","root","clear","i","lineText","codeBlockNode","shiftedIndex","importCodeBlock","importBlocks","isEmptyParagraph","remove","$getSelection","selectEnd","$isParagraphNode","firstChild","getFirstChild","getChildrenSize","rootNode","lineTextTrimmed","$createTextNode","elementNode","$createParagraphNode","append","regExp","match","setTextContent","slice","importTextFormatTransformers","isAttached","$isQuoteNode","$isListNode","targetNode","lastDescendant","$findMatchingParent","$isListItemNode","getTextContentSize","splice","$createLineBreakNode","startLineIndex","openMatch","endLineIndex","closeMatch","$createCodeNode","findOutermostMatch","importTextMatchTransformers","currentNode","remainderNode","leadingNode","startIndex","endIndex","splitText","transformersByTag","toggleFormat","textNode_","importRegExp","replaceNode","leftTextNode","rightTextNode","openTagsMatch","openTagsRegExp","fullMatchRegExp","fullMatchRegExpByTag","fullMatch","intraword","beforeChar","afterChar","escapeRegExp","tagRegExp","RegExp","runElementTransformers","anchorNode","anchorOffset","grandParentNode","getParent","$isRootOrShadowRoot","nextSiblings","getNextSiblings","siblings","runTextMatchTransformers","transformersByTrigger","lastChar","selectNext","runTextFormatTransformers","closeTagEndIndex","closeChar","matchers","matcher","tagLength","closeTagStartIndex","isEqualSubString","afterCloseTagChar","closeNode","openNode","openTagStartIndex","getOpenTagStartIndex","siblingTextContent","prevOpenNodeText","beforeOpenTagChar","prevCloseNodeText","closeNodeText","openNodeText","selection","nextSelection","$createRangeSelection","$setSelection","newOffset","anchor","set","__key","focus","formatText","offset","$isRangeSelection","string","maxIndex","stringA","aStart","stringB","bStart","registerMarkdownShortcuts","editor","TRANSFORMERS","textMatchTransformersIndex","trigger","dependencies","hasNode","Error","getType","transform","registerUpdateListener","tags","dirtyLeaves","editorState","prevEditorState","isComposing","read","prevSelection","isCollapsed","anchorKey","_nodeMap","get","update","$isCodeNode","createBlockNode","createNode","select","LIST_INDENT_SIZE","listReplace","listType","listItem","$createListItemNode","undefined","getListType","insertBefore","list$1","$createListNode","Number","indent","Math","floor","setIndent","listExport","listNode","depth","listItemNode","repeat","prefix","getStart","getChecked","HEADING","HeadingNode","$isHeadingNode","level","getTag","$createHeadingNode","QUOTE","QuoteNode","line","_match","isImport","$createQuoteNode","CODE","CodeNode","getLanguage","UNORDERED_LIST","ListNode","ListItemNode","CHECK_LIST","ORDERED_LIST","INLINE_CODE","HIGHLIGHT","BOLD_ITALIC_STAR","BOLD_ITALIC_UNDERSCORE","BOLD_STAR","BOLD_UNDERSCORE","STRIKETHROUGH","ITALIC_STAR","ITALIC_UNDERSCORE","LINK","LinkNode","exportFormat","$isLinkNode","title","getTitle","linkContent","getURL","linkText","linkUrl","linkTitle","linkNode","$createLinkNode","linkTextNode","setFormat","getFormat","ELEMENT_TRANSFORMERS","TEXT_FORMAT_TRANSFORMERS","TEXT_MATCH_TRANSFORMERS","$convertFromMarkdownString","markdown","importMarkdown","$convertToMarkdownString","exportMarkdown","exports"],"sources":["C:/Users/franc/Desktop/Progetto/Frontend/app_frontend/node_modules/@lexical/markdown/LexicalMarkdown.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar code = require('@lexical/code');\nvar list = require('@lexical/list');\nvar richText = require('@lexical/rich-text');\nvar utils = require('@lexical/utils');\nvar link = require('@lexical/link');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n\n  for (const item of list) {\n    const key = callback(item);\n\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createMarkdownExport(transformers) {\n  const byType = transformersByType(transformers); // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1);\n  return node => {\n    const output = [];\n    const children = (node || lexical.$getRoot()).getChildren();\n\n    for (const child of children) {\n      const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);\n\n      if (result != null) {\n        output.push(result);\n      }\n    }\n\n    return output.join('\\n\\n');\n  };\n}\n\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n\n    if (result != null) {\n      return result;\n    }\n  }\n\n  if (lexical.$isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if (lexical.$isDecoratorNode(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\n\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers) {\n  const output = [];\n  const children = node.getChildren();\n\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n\n    if (lexical.$isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if (lexical.$isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n    } else if (lexical.$isElementNode(child)) {\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n    } else if (lexical.$isDecoratorNode(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n\n  return output.join('');\n}\n\nfunction exportTextFormat(node, textContent, textTransformers) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim();\n  let output = frozenString;\n  const applied = new Set();\n\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format); // Prevent adding opening tag is already opened by the previous sibling\n\n      const previousNode = getTextSibling(node, true);\n\n      if (!hasFormat(previousNode, format)) {\n        output = tag + output;\n      } // Prevent adding closing tag if next sibling will do it\n\n\n      const nextNode = getTextSibling(node, false);\n\n      if (!hasFormat(nextNode, format)) {\n        output += tag;\n      }\n    }\n  } // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n\n\n  return textContent.replace(frozenString, output);\n} // Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\n\n\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  while (sibling) {\n    if (lexical.$isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n\n      if (lexical.$isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n\n    if (lexical.$isTextNode(sibling)) {\n      return sibling;\n    }\n\n    if (!lexical.$isElementNode(sibling)) {\n      return null;\n    }\n  }\n\n  return null;\n}\n\nfunction hasFormat(node, format) {\n  return lexical.$isTextNode(node) && node.hasFormat(format);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nconst CODE_BLOCK_REG_EXP = /^```(\\w{1,10})?\\s?$/;\nfunction createMarkdownImport(transformers) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || lexical.$getRoot();\n    root.clear();\n\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i]; // Codeblocks are processed first as anything inside such block\n      // is ignored for further processing\n      // TODO:\n      // Abstract it to be dynamic as other transformers (add multiline match option)\n\n      const [codeBlockNode, shiftedIndex] = importCodeBlock(lines, i, root);\n\n      if (codeBlockNode != null) {\n        i = shiftedIndex;\n        continue;\n      }\n\n      importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n    } // Removing empty paragraphs as md does not really\n    // allow empty lines and uses them as dilimiter\n\n\n    const children = root.getChildren();\n\n    for (const child of children) {\n      if (isEmptyParagraph(child)) {\n        child.remove();\n      }\n    }\n\n    if (lexical.$getSelection() !== null) {\n      root.selectEnd();\n    }\n  };\n}\n\nfunction isEmptyParagraph(node) {\n  if (!lexical.$isParagraphNode(node)) {\n    return false;\n  }\n\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\nfunction importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n  const lineTextTrimmed = lineText.trim();\n  const textNode = lexical.$createTextNode(lineTextTrimmed);\n  const elementNode = lexical.$createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      replace(elementNode, [textNode], match, true);\n      break;\n    }\n  }\n\n  importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers); // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n\n  if (elementNode.isAttached() && lineTextTrimmed.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n\n    if (lexical.$isParagraphNode(previousNode) || richText.$isQuoteNode(previousNode) || list.$isListNode(previousNode)) {\n      let targetNode = previousNode;\n\n      if (list.$isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = utils.$findMatchingParent(lastDescendant, list.$isListItemNode);\n        }\n      }\n\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\n\nfunction importCodeBlock(lines, startLineIndex, rootNode) {\n  const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);\n\n  if (openMatch) {\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n\n    while (++endLineIndex < linesLength) {\n      const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);\n\n      if (closeMatch) {\n        const codeBlockNode = code.$createCodeNode(openMatch[1]);\n        const textNode = lexical.$createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join('\\n'));\n        codeBlockNode.append(textNode);\n        rootNode.append(codeBlockNode);\n        return [codeBlockNode, endLineIndex];\n      }\n    }\n  }\n\n  return [null, startLineIndex];\n} // Processing text content and replaces text format tags.\n// It takes outermost tag match and its content, creates text node with\n// format based on tag and then recursively executed over node's content\n//\n// E.g. for \"*Hello **world**!*\" string it will create text node with\n// \"Hello **world**!\" content and italic format and run recursively over\n// its content to transform \"**world**\" part\n\n\nfunction importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n\n  if (!match) {\n    // Once text format processing is done run text match transformers, as it\n    // only can span within single text node (unline formats that can cover multiple nodes)\n    importTextMatchTransformers(textNode, textMatchTransformers);\n    return;\n  }\n\n  let currentNode, remainderNode, leadingNode; // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n\n  if (match[0] === textContent) {\n    currentNode = textNode;\n  } else {\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n\n    if (startIndex === 0) {\n      [currentNode, remainderNode] = textNode.splitText(endIndex);\n    } else {\n      [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n\n  currentNode.setTextContent(match[2]);\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!currentNode.hasFormat(format)) {\n        currentNode.toggleFormat(format);\n      }\n    }\n  } // Recursively run over inner text if it's not inline code\n\n\n  if (!currentNode.hasFormat('code')) {\n    importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n  } // Run over leading/remaining text if any\n\n\n  if (leadingNode) {\n    importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n\n  if (remainderNode) {\n    importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n}\n\nfunction importTextMatchTransformers(textNode_, textMatchTransformers) {\n  let textNode = textNode_;\n\n  mainLoop: while (textNode) {\n    for (const transformer of textMatchTransformers) {\n      const match = textNode.getTextContent().match(transformer.importRegExp);\n\n      if (!match) {\n        continue;\n      }\n\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      let replaceNode, leftTextNode, rightTextNode;\n\n      if (startIndex === 0) {\n        [replaceNode, textNode] = textNode.splitText(endIndex);\n      } else {\n        [leftTextNode, replaceNode, rightTextNode] = textNode.splitText(startIndex, endIndex);\n      }\n\n      if (leftTextNode) {\n        importTextMatchTransformers(leftTextNode, textMatchTransformers);\n      }\n\n      if (rightTextNode) {\n        textNode = rightTextNode;\n      }\n\n      transformer.replace(replaceNode, match);\n      continue mainLoop;\n    }\n\n    break;\n  }\n} // Finds first \"<tag>content<tag>\" match that is not nested into another tag\n\n\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n\n  if (openTagsMatch == null) {\n    return null;\n  }\n\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      } // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n\n\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n\n    if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n    } else {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    }\n  }\n\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Reg exp to find opening tags\n    openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? '' : `${escapeRegExp}`) + '(' + openTagsRegExp.join('|') + ')', 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n\n  if (!lexical.$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n\n  const textContent = anchorNode.getTextContent(); // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n\n    if (match && match[0].length === anchorOffset) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      replace(parentNode, siblings, match, false);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n\n  if (transformers == null) {\n    return false;\n  } // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n\n\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n\n  for (const transformer of transformers) {\n    const match = textContent.match(transformer.regExp);\n\n    if (match === null) {\n      continue;\n    }\n\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n\n  return false;\n}\n\nfunction runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex]; // Quick check if we're possibly at the end of inline markdown style\n\n  const matchers = textFormatTransformers[closeChar];\n\n  if (!matchers) {\n    return false;\n  }\n\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1; // If tag is not single char check if rest of it matches with text content\n\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    } // Space before closing tag cancels inline markdown\n\n\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation after it\n\n\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag); // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n\n    let sibling = openNode;\n\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if (lexical.$isLineBreakNode(sibling)) {\n        break;\n      }\n\n      if (lexical.$isTextNode(sibling)) {\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    } // Opening tag is not found\n\n\n    if (openTagStartIndex < 0) {\n      continue;\n    } // No content between opening and closing tag\n\n\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    } // Checking longer tags for repeating chars (e.g. *** vs **)\n\n\n    const prevOpenNodeText = openNode.getTextContent();\n\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation before it\n\n\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    } // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n\n\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = lexical.$getSelection();\n    const nextSelection = lexical.$createRangeSelection();\n    lexical.$setSelection(nextSelection); // Adjust offset based on deleted chars\n\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text'); // Apply formatting to selected text\n\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    } // Collapse selection up to the focus point\n\n\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type); // Remove formatting from collapsed selection\n\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n\n    if (lexical.$isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) && // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n\n  return -1;\n}\n\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersIndex = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n\n  for (const transformer of transformers) {\n    const type = transformer.type;\n\n    if (type === 'element' || type === 'text-match') {\n      const dependencies = transformer.dependencies;\n\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            throw Error(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n\n  const transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {\n      return;\n    }\n\n    runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);\n  };\n\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from undo/redo (as changes already calculated)\n    if (tags.has('historic')) {\n      return;\n    } // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n\n\n    if (editor.isComposing()) {\n      return;\n    }\n\n    const selection = editorState.read(lexical.$getSelection);\n    const prevSelection = prevEditorState.read(lexical.$getSelection);\n\n    if (!lexical.$isRangeSelection(prevSelection) || !lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return;\n    }\n\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n\n    if (!lexical.$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return;\n      }\n\n      const parentNode = anchorNode.getParent();\n\n      if (parentNode === null || code.$isCodeNode(parentNode)) {\n        return;\n      }\n\n      transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst createBlockNode = createNode => {\n  return (parentNode, children, match) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  };\n}; // Amount of spaces that define indentation level\n// TODO: should be an option\n\n\nconst LIST_INDENT_SIZE = 4;\n\nconst listReplace = listType => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = list.$createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n\n    if (list.$isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild();\n\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n\n      parentNode.remove();\n    } else if (list.$isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list$1 = list.$createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list$1.append(listItem);\n      parentNode.replace(list$1);\n    }\n\n    listItem.append(...children);\n    listItem.select(0, 0);\n    const indent = Math.floor(match[1].length / LIST_INDENT_SIZE);\n\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\n\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n\n  for (const listItemNode of children) {\n    if (list.$isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n\n        if (list.$isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n\n  return output.join('\\n');\n};\n\nconst HEADING = {\n  dependencies: [richText.HeadingNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isHeadingNode(node)) {\n      return null;\n    }\n\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: /^(#{1,6})\\s/,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return richText.$createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [richText.QuoteNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isQuoteNode(node)) {\n      return null;\n    }\n\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n\n    return output.join('\\n');\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n\n      if (richText.$isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...children]);\n        previousNode.select(0, 0);\n        parentNode.remove();\n        return;\n      }\n    }\n\n    const node = richText.$createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [code.CodeNode],\n  export: node => {\n    if (!code.$isCodeNode(node)) {\n      return null;\n    }\n\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExp: /^```(\\w{1,10})?\\s/,\n  replace: createBlockNode(match => {\n    return code.$createCodeNode(match ? match[1] : undefined);\n  }),\n  type: 'element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(\\d{1,})\\.\\s/,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n}; // Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst LINK = {\n  dependencies: [link.LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!link.$isLinkNode(node)) {\n      return null;\n    }\n\n    const title = node.getTitle();\n    const linkContent = title ? `[${node.getTextContent()}](${node.getURL()} \"${title}\")` : `[${node.getTextContent()}](${node.getURL()})`;\n    const firstChild = node.getFirstChild(); // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n\n    if (node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild)) {\n      return exportFormat(firstChild, linkContent);\n    } else {\n      return linkContent;\n    }\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = link.$createLinkNode(linkUrl, {\n      title: linkTitle\n    });\n    const linkTextNode = lexical.$createTextNode(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n  },\n  trigger: ')',\n  type: 'text-match'\n};\n\n/** @module @lexical/markdown */\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, CODE, UNORDERED_LIST, ORDERED_LIST]; // Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\n\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node) {\n  const importMarkdown = createMarkdownImport(transformers);\n  return importMarkdown(markdown, node);\n}\n\nfunction $convertToMarkdownString(transformers = TRANSFORMERS, node) {\n  const exportMarkdown = createMarkdownExport(transformers);\n  return exportMarkdown(node);\n}\n\nexports.$convertFromMarkdownString = $convertFromMarkdownString;\nexports.$convertToMarkdownString = $convertToMarkdownString;\nexports.BOLD_ITALIC_STAR = BOLD_ITALIC_STAR;\nexports.BOLD_ITALIC_UNDERSCORE = BOLD_ITALIC_UNDERSCORE;\nexports.BOLD_STAR = BOLD_STAR;\nexports.BOLD_UNDERSCORE = BOLD_UNDERSCORE;\nexports.CHECK_LIST = CHECK_LIST;\nexports.CODE = CODE;\nexports.ELEMENT_TRANSFORMERS = ELEMENT_TRANSFORMERS;\nexports.HEADING = HEADING;\nexports.HIGHLIGHT = HIGHLIGHT;\nexports.INLINE_CODE = INLINE_CODE;\nexports.ITALIC_STAR = ITALIC_STAR;\nexports.ITALIC_UNDERSCORE = ITALIC_UNDERSCORE;\nexports.LINK = LINK;\nexports.ORDERED_LIST = ORDERED_LIST;\nexports.QUOTE = QUOTE;\nexports.STRIKETHROUGH = STRIKETHROUGH;\nexports.TEXT_FORMAT_TRANSFORMERS = TEXT_FORMAT_TRANSFORMERS;\nexports.TEXT_MATCH_TRANSFORMERS = TEXT_MATCH_TRANSFORMERS;\nexports.TRANSFORMERS = TRANSFORMERS;\nexports.UNORDERED_LIST = UNORDERED_LIST;\nexports.registerMarkdownShortcuts = registerMarkdownShortcuts;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}