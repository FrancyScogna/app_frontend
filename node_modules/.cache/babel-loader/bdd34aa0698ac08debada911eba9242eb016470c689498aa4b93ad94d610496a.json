{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar useLexicalNodeSelection = require('@lexical/react/useLexicalNodeSelection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar React = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand('INSERT_HORIZONTAL_RULE_COMMAND');\nfunction HorizontalRuleComponent({\n  nodeKey\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection.useLexicalNodeSelection(nodeKey);\n  const onDelete = React.useCallback(event => {\n    if (isSelected && lexical.$isNodeSelection(lexical.$getSelection())) {\n      event.preventDefault();\n      const node = lexical.$getNodeByKey(nodeKey);\n      if ($isHorizontalRuleNode(node)) {\n        node.remove();\n      }\n    }\n    return false;\n  }, [isSelected, nodeKey]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, event => {\n      const hrElem = editor.getElementByKey(nodeKey);\n      if (event.target === hrElem) {\n        if (!event.shiftKey) {\n          clearSelection();\n        }\n        setSelected(!isSelected);\n        return true;\n      }\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_DELETE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW));\n  }, [clearSelection, editor, isSelected, nodeKey, onDelete, setSelected]);\n  React.useEffect(() => {\n    const hrElem = editor.getElementByKey(nodeKey);\n    if (hrElem !== null) {\n      hrElem.className = isSelected ? 'selected' : '';\n    }\n  }, [editor, isSelected, nodeKey]);\n  return null;\n}\nclass HorizontalRuleNode extends lexical.DecoratorNode {\n  static getType() {\n    return 'horizontalrule';\n  }\n  static clone(node) {\n    return new HorizontalRuleNode(node.__key);\n  }\n  static importJSON(serializedNode) {\n    return $createHorizontalRuleNode();\n  }\n  static importDOM() {\n    return {\n      hr: () => ({\n        conversion: convertHorizontalRuleElement,\n        priority: 0\n      })\n    };\n  }\n  exportJSON() {\n    return {\n      type: 'horizontalrule',\n      version: 1\n    };\n  }\n  exportDOM() {\n    return {\n      element: document.createElement('hr')\n    };\n  }\n  createDOM() {\n    return document.createElement('hr');\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  isInline() {\n    return false;\n  }\n  updateDOM() {\n    return false;\n  }\n  decorate() {\n    return /*#__PURE__*/React.createElement(HorizontalRuleComponent, {\n      nodeKey: this.__key\n    });\n  }\n}\nfunction convertHorizontalRuleElement() {\n  return {\n    node: $createHorizontalRuleNode()\n  };\n}\nfunction $createHorizontalRuleNode() {\n  return lexical.$applyNodeReplacement(new HorizontalRuleNode());\n}\nfunction $isHorizontalRuleNode(node) {\n  return node instanceof HorizontalRuleNode;\n}\nexports.$createHorizontalRuleNode = $createHorizontalRuleNode;\nexports.$isHorizontalRuleNode = $isHorizontalRuleNode;\nexports.HorizontalRuleNode = HorizontalRuleNode;\nexports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;","map":{"version":3,"names":["LexicalComposerContext","require","useLexicalNodeSelection","utils","lexical","React","INSERT_HORIZONTAL_RULE_COMMAND","createCommand","HorizontalRuleComponent","nodeKey","editor","useLexicalComposerContext","isSelected","setSelected","clearSelection","onDelete","useCallback","event","$isNodeSelection","$getSelection","preventDefault","node","$getNodeByKey","$isHorizontalRuleNode","remove","useEffect","mergeRegister","registerCommand","CLICK_COMMAND","hrElem","getElementByKey","target","shiftKey","COMMAND_PRIORITY_LOW","KEY_DELETE_COMMAND","KEY_BACKSPACE_COMMAND","className","HorizontalRuleNode","DecoratorNode","getType","clone","__key","importJSON","serializedNode","$createHorizontalRuleNode","importDOM","hr","conversion","convertHorizontalRuleElement","priority","exportJSON","type","version","exportDOM","element","document","createElement","createDOM","getTextContent","isInline","updateDOM","decorate","$applyNodeReplacement","exports"],"sources":["C:/Users/franc/Desktop/Progetto/Frontend/app_frontend/node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar useLexicalNodeSelection = require('@lexical/react/useLexicalNodeSelection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar React = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand('INSERT_HORIZONTAL_RULE_COMMAND');\n\nfunction HorizontalRuleComponent({\n  nodeKey\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection.useLexicalNodeSelection(nodeKey);\n  const onDelete = React.useCallback(event => {\n    if (isSelected && lexical.$isNodeSelection(lexical.$getSelection())) {\n      event.preventDefault();\n      const node = lexical.$getNodeByKey(nodeKey);\n\n      if ($isHorizontalRuleNode(node)) {\n        node.remove();\n      }\n    }\n\n    return false;\n  }, [isSelected, nodeKey]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, event => {\n      const hrElem = editor.getElementByKey(nodeKey);\n\n      if (event.target === hrElem) {\n        if (!event.shiftKey) {\n          clearSelection();\n        }\n\n        setSelected(!isSelected);\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_DELETE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW));\n  }, [clearSelection, editor, isSelected, nodeKey, onDelete, setSelected]);\n  React.useEffect(() => {\n    const hrElem = editor.getElementByKey(nodeKey);\n\n    if (hrElem !== null) {\n      hrElem.className = isSelected ? 'selected' : '';\n    }\n  }, [editor, isSelected, nodeKey]);\n  return null;\n}\n\nclass HorizontalRuleNode extends lexical.DecoratorNode {\n  static getType() {\n    return 'horizontalrule';\n  }\n\n  static clone(node) {\n    return new HorizontalRuleNode(node.__key);\n  }\n\n  static importJSON(serializedNode) {\n    return $createHorizontalRuleNode();\n  }\n\n  static importDOM() {\n    return {\n      hr: () => ({\n        conversion: convertHorizontalRuleElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportJSON() {\n    return {\n      type: 'horizontalrule',\n      version: 1\n    };\n  }\n\n  exportDOM() {\n    return {\n      element: document.createElement('hr')\n    };\n  }\n\n  createDOM() {\n    return document.createElement('hr');\n  }\n\n  getTextContent() {\n    return '\\n';\n  }\n\n  isInline() {\n    return false;\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  decorate() {\n    return /*#__PURE__*/React.createElement(HorizontalRuleComponent, {\n      nodeKey: this.__key\n    });\n  }\n\n}\n\nfunction convertHorizontalRuleElement() {\n  return {\n    node: $createHorizontalRuleNode()\n  };\n}\n\nfunction $createHorizontalRuleNode() {\n  return lexical.$applyNodeReplacement(new HorizontalRuleNode());\n}\nfunction $isHorizontalRuleNode(node) {\n  return node instanceof HorizontalRuleNode;\n}\n\nexports.$createHorizontalRuleNode = $createHorizontalRuleNode;\nexports.$isHorizontalRuleNode = $isHorizontalRuleNode;\nexports.HorizontalRuleNode = HorizontalRuleNode;\nexports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,uCAAuC,CAAC;AAC7E,IAAIC,uBAAuB,GAAGD,OAAO,CAAC,wCAAwC,CAAC;AAC/E,IAAIE,KAAK,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AACrC,IAAIG,OAAO,GAAGH,OAAO,CAAC,SAAS,CAAC;AAChC,IAAII,KAAK,GAAGJ,OAAO,CAAC,OAAO,CAAC;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMK,8BAA8B,GAAGF,OAAO,CAACG,aAAa,CAAC,gCAAgC,CAAC;AAE9F,SAASC,uBAAuBA,CAAC;EAC/BC;AACF,CAAC,EAAE;EACD,MAAM,CAACC,MAAM,CAAC,GAAGV,sBAAsB,CAACW,yBAAyB,CAAC,CAAC;EACnE,MAAM,CAACC,UAAU,EAAEC,WAAW,EAAEC,cAAc,CAAC,GAAGZ,uBAAuB,CAACA,uBAAuB,CAACO,OAAO,CAAC;EAC1G,MAAMM,QAAQ,GAAGV,KAAK,CAACW,WAAW,CAACC,KAAK,IAAI;IAC1C,IAAIL,UAAU,IAAIR,OAAO,CAACc,gBAAgB,CAACd,OAAO,CAACe,aAAa,CAAC,CAAC,CAAC,EAAE;MACnEF,KAAK,CAACG,cAAc,CAAC,CAAC;MACtB,MAAMC,IAAI,GAAGjB,OAAO,CAACkB,aAAa,CAACb,OAAO,CAAC;MAE3C,IAAIc,qBAAqB,CAACF,IAAI,CAAC,EAAE;QAC/BA,IAAI,CAACG,MAAM,CAAC,CAAC;MACf;IACF;IAEA,OAAO,KAAK;EACd,CAAC,EAAE,CAACZ,UAAU,EAAEH,OAAO,CAAC,CAAC;EACzBJ,KAAK,CAACoB,SAAS,CAAC,MAAM;IACpB,OAAOtB,KAAK,CAACuB,aAAa,CAAChB,MAAM,CAACiB,eAAe,CAACvB,OAAO,CAACwB,aAAa,EAAEX,KAAK,IAAI;MAChF,MAAMY,MAAM,GAAGnB,MAAM,CAACoB,eAAe,CAACrB,OAAO,CAAC;MAE9C,IAAIQ,KAAK,CAACc,MAAM,KAAKF,MAAM,EAAE;QAC3B,IAAI,CAACZ,KAAK,CAACe,QAAQ,EAAE;UACnBlB,cAAc,CAAC,CAAC;QAClB;QAEAD,WAAW,CAAC,CAACD,UAAU,CAAC;QACxB,OAAO,IAAI;MACb;MAEA,OAAO,KAAK;IACd,CAAC,EAAER,OAAO,CAAC6B,oBAAoB,CAAC,EAAEvB,MAAM,CAACiB,eAAe,CAACvB,OAAO,CAAC8B,kBAAkB,EAAEnB,QAAQ,EAAEX,OAAO,CAAC6B,oBAAoB,CAAC,EAAEvB,MAAM,CAACiB,eAAe,CAACvB,OAAO,CAAC+B,qBAAqB,EAAEpB,QAAQ,EAAEX,OAAO,CAAC6B,oBAAoB,CAAC,CAAC;EAC9N,CAAC,EAAE,CAACnB,cAAc,EAAEJ,MAAM,EAAEE,UAAU,EAAEH,OAAO,EAAEM,QAAQ,EAAEF,WAAW,CAAC,CAAC;EACxER,KAAK,CAACoB,SAAS,CAAC,MAAM;IACpB,MAAMI,MAAM,GAAGnB,MAAM,CAACoB,eAAe,CAACrB,OAAO,CAAC;IAE9C,IAAIoB,MAAM,KAAK,IAAI,EAAE;MACnBA,MAAM,CAACO,SAAS,GAAGxB,UAAU,GAAG,UAAU,GAAG,EAAE;IACjD;EACF,CAAC,EAAE,CAACF,MAAM,EAAEE,UAAU,EAAEH,OAAO,CAAC,CAAC;EACjC,OAAO,IAAI;AACb;AAEA,MAAM4B,kBAAkB,SAASjC,OAAO,CAACkC,aAAa,CAAC;EACrD,OAAOC,OAAOA,CAAA,EAAG;IACf,OAAO,gBAAgB;EACzB;EAEA,OAAOC,KAAKA,CAACnB,IAAI,EAAE;IACjB,OAAO,IAAIgB,kBAAkB,CAAChB,IAAI,CAACoB,KAAK,CAAC;EAC3C;EAEA,OAAOC,UAAUA,CAACC,cAAc,EAAE;IAChC,OAAOC,yBAAyB,CAAC,CAAC;EACpC;EAEA,OAAOC,SAASA,CAAA,EAAG;IACjB,OAAO;MACLC,EAAE,EAAEA,CAAA,MAAO;QACTC,UAAU,EAAEC,4BAA4B;QACxCC,QAAQ,EAAE;MACZ,CAAC;IACH,CAAC;EACH;EAEAC,UAAUA,CAAA,EAAG;IACX,OAAO;MACLC,IAAI,EAAE,gBAAgB;MACtBC,OAAO,EAAE;IACX,CAAC;EACH;EAEAC,SAASA,CAAA,EAAG;IACV,OAAO;MACLC,OAAO,EAAEC,QAAQ,CAACC,aAAa,CAAC,IAAI;IACtC,CAAC;EACH;EAEAC,SAASA,CAAA,EAAG;IACV,OAAOF,QAAQ,CAACC,aAAa,CAAC,IAAI,CAAC;EACrC;EAEAE,cAAcA,CAAA,EAAG;IACf,OAAO,IAAI;EACb;EAEAC,QAAQA,CAAA,EAAG;IACT,OAAO,KAAK;EACd;EAEAC,SAASA,CAAA,EAAG;IACV,OAAO,KAAK;EACd;EAEAC,QAAQA,CAAA,EAAG;IACT,OAAO,aAAaxD,KAAK,CAACmD,aAAa,CAAChD,uBAAuB,EAAE;MAC/DC,OAAO,EAAE,IAAI,CAACgC;IAChB,CAAC,CAAC;EACJ;AAEF;AAEA,SAASO,4BAA4BA,CAAA,EAAG;EACtC,OAAO;IACL3B,IAAI,EAAEuB,yBAAyB,CAAC;EAClC,CAAC;AACH;AAEA,SAASA,yBAAyBA,CAAA,EAAG;EACnC,OAAOxC,OAAO,CAAC0D,qBAAqB,CAAC,IAAIzB,kBAAkB,CAAC,CAAC,CAAC;AAChE;AACA,SAASd,qBAAqBA,CAACF,IAAI,EAAE;EACnC,OAAOA,IAAI,YAAYgB,kBAAkB;AAC3C;AAEA0B,OAAO,CAACnB,yBAAyB,GAAGA,yBAAyB;AAC7DmB,OAAO,CAACxC,qBAAqB,GAAGA,qBAAqB;AACrDwC,OAAO,CAAC1B,kBAAkB,GAAGA,kBAAkB;AAC/C0B,OAAO,CAACzD,8BAA8B,GAAGA,8BAA8B"},"metadata":{},"sourceType":"script","externalDependencies":[]}