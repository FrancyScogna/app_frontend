{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar html = require('@lexical/html');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @returns a string of HTML content\n */\n\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return html.$generateHtmlFromNodes(editor, selection);\n}\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @returns\n */\n\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\n\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\n\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch {// Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch {// Fail silently.\n    }\n  } // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      const partsLength = parts.length;\n      for (let i = 0; i < partsLength; i++) {\n        const part = parts[i];\n        if (part === '\\n' || part === '\\r\\n') {\n          selection.insertParagraph();\n        } else if (part === '\\t') {\n          selection.insertNodes([lexical.$createTabNode()]);\n        } else {\n          selection.insertText(part);\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\n\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = lexical.$isLineBreakNode(node);\n    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        topLevelBlocks.push(currentBlock); // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n    anchorCell.append(...topLevelBlocks);\n  }\n}\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n    const newGridRowNode = newGridRows[newRowIdx];\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n    newRowIdx++;\n  }\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  const serializedChildren = serializedNode.children;\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target); // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n\n  if (lexical.$isTextNode(target)) {\n    const text = target.__text; // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n} // TODO why $ function with Editor instance?\n\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\n\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\n\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null; // TODO custom selection\n// TODO potentially have a node customizable version for plain text\n\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\n\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {\n      if (utils.objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      } // Block the entire copy flow while we wait for the next ClipboardEvent\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL); // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n} // TODO shouldn't pass editor (pass namespace directly)\n\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = getDOMSelection(editor._window);\n  if (!domSelection) {\n    return false;\n  }\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n  if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = lexical.$getSelection();\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\nexports.copyToClipboard = copyToClipboard;","map":{"version":3,"names":["html","require","selection","utils","lexical","CAN_USE_DOM","window","document","createElement","getDOMSelection","targetWindow","getSelection","$getHtmlContent","editor","$getSelection","Error","$isRangeSelection","isCollapsed","getNodes","length","$generateHtmlFromNodes","$getLexicalContent","JSON","stringify","$generateJSONFromSelectedNodes","$insertDataTransferForPlainText","dataTransfer","text","getData","insertRawText","$insertDataTransferForRichText","lexicalString","payload","parse","namespace","_config","Array","isArray","nodes","$generateNodesFromSerializedNodes","$insertGeneratedNodes","htmlString","parser","DOMParser","dom","parseFromString","$generateNodesFromDOM","parts","split","partsLength","i","part","insertParagraph","insertNodes","$createTabNode","insertText","isSelectionInsideOfGrid","DEPRECATED_$isGridSelection","$findMatchingParent","anchor","getNode","n","DEPRECATED_$isGridCellNode","focus","DEPRECATED_$isGridNode","$mergeGridNodesStrategy","$basicInsertStrategy","topLevelBlocks","currentBlock","node","isLineBreakNode","$isLineBreakNode","$isDecoratorNode","isInline","$isElementNode","$isTextNode","isParentRequired","createParentElementNode","push","append","anchorCell","isFromLexical","newGrid","newGridRows","getChildren","newColumnCount","getFirstChildOrThrow","getChildrenSize","newRowCount","gridCellNode","gridRowNode","DEPRECATED_$isGridRowNode","gridNode","startY","getIndexWithinParent","stopY","Math","min","startX","stopX","fromX","fromY","toX","max","toY","gridRowNodes","newRowIdx","newAnchorCellKey","newFocusCellKey","r","currentGridRowNode","newGridRowNode","gridCellNodes","newGridCellNodes","newColumnIdx","c","currentGridCellNode","newGridCellNode","getKey","originalChildren","forEach","child","paragraphNode","$createParagraphNode","remove","newGridSelection","DEPRECATED_$createGridSelection","set","$setSelection","dispatchCommand","SELECTION_CHANGE_COMMAND","undefined","exportNodeToJSON","serializedNode","exportJSON","nodeClass","constructor","type","getType","name","serializedChildren","children","$appendNodesToJSON","selection$1","currentNode","targetArray","shouldInclude","isSelected","shouldExclude","excludeFromCopy","target","clone","$cloneWithProperties","$sliceSelectedTextNodeContent","__text","childNode","shouldIncludeChild","extractWithChild","serializedChildNode","root","$getRoot","topLevelChildren","topLevelNode","serializedNodes","$parseSerializedNode","$addNodeStyle","EVENT_LATENCY","clipboardEventTimeout","copyToClipboard","event","Promise","resolve","reject","update","$copyToClipboardEvent","rootElement","getRootElement","windowDocument","_window","domSelection","element","style","cssText","createTextNode","range","Range","setStart","setEnd","removeAllRanges","addRange","removeListener","registerCommand","COPY_COMMAND","secondEvent","objectKlassEquals","ClipboardEvent","clearTimeout","COMMAND_PRIORITY_CRITICAL","setTimeout","execCommand","anchorDOM","anchorNode","focusDOM","focusNode","isSelectionWithinEditor","preventDefault","clipboardData","plainString","getTextContent","setData","exports"],"sources":["C:/Users/franc/Desktop/Progetto/Frontend/app_frontend/node_modules/@lexical/clipboard/LexicalClipboard.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar html = require('@lexical/html');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @returns a string of HTML content\n */\n\n\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n\n  return html.$generateHtmlFromNodes(editor, selection);\n}\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @returns\n */\n\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\n\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\n\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch {// Fail silently.\n    }\n  }\n\n  const htmlString = dataTransfer.getData('text/html');\n\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch {// Fail silently.\n    }\n  } // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n\n\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      const partsLength = parts.length;\n\n      for (let i = 0; i < partsLength; i++) {\n        const part = parts[i];\n\n        if (part === '\\n' || part === '\\r\\n') {\n          selection.insertParagraph();\n        } else if (part === '\\t') {\n          selection.insertNodes([lexical.$createTabNode()]);\n        } else {\n          selection.insertText(part);\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\n\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\n\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = lexical.$isLineBreakNode(node);\n\n    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        topLevelBlocks.push(currentBlock); // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n\n    anchorCell.append(...topLevelBlocks);\n  }\n}\n\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const newGridRowNode = newGridRows[newRowIdx];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n\n    newRowIdx++;\n  }\n\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n\n  const serializedChildren = serializedNode.children;\n\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n\n  return serializedNode;\n}\n\nfunction $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target); // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n\n  if (lexical.$isTextNode(target)) {\n    const text = target.__text; // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n\n  return shouldInclude;\n} // TODO why $ function with Editor instance?\n\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\n\n\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\n\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n\n    nodes.push(node);\n  }\n\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null; // TODO custom selection\n// TODO potentially have a node customizable version for plain text\n\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\n\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {\n      if (utils.objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      } // Block the entire copy flow while we wait for the next ClipboardEvent\n\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL); // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n} // TODO shouldn't pass editor (pass namespace directly)\n\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = getDOMSelection(editor._window);\n\n  if (!domSelection) {\n    return false;\n  }\n\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n\n  if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = lexical.$getSelection();\n\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\nexports.copyToClipboard = copyToClipboard;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}