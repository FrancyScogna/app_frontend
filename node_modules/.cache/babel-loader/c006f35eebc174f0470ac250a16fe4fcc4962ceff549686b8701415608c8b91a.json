{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/** @module @lexical/html */\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\n\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (utils.isHTMLElement(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;","map":{"version":3,"names":["selection","require","utils","lexical","$generateNodesFromDOM","editor","dom","elements","body","childNodes","lexicalNodes","i","length","element","IGNORE_TAGS","has","nodeName","lexicalNode","$createNodesFromDOM","concat","$generateHtmlFromNodes","document","window","Error","container","createElement","root","$getRoot","topLevelChildren","getChildren","topLevelNode","$appendNodesToHTML","innerHTML","currentNode","parentElement","selection$1","shouldInclude","isSelected","shouldExclude","$isElementNode","excludeFromCopy","target","clone","$cloneWithProperties","$isTextNode","$sliceSelectedTextNodeContent","children","after","exportDOM","fragment","createDocumentFragment","childNode","shouldIncludeChild","extractWithChild","isHTMLElement","append","newElement","call","replaceWith","getConversionFunction","domNode","cachedConversions","_htmlConversions","get","toLowerCase","currentConversion","undefined","cachedConversion","domConversion","priority","conversion","Set","node","forChildMap","Map","parentLexicalNode","currentLexicalNode","transformFunction","transformOutput","postTransform","transformNodes","Array","isArray","forChildFunction","push","forChild","set","childLexicalNodes","exports"],"sources":["C:/Users/franc/Desktop/Progetto/Frontend/app_frontend/node_modules/@lexical/html/LexicalHtml.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/** @module @lexical/html */\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\n\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n\n  return container.innerHTML;\n}\n\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n\n  if (!element) {\n    return false;\n  }\n\n  const fragment = document.createDocumentFragment();\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    if (utils.isHTMLElement(element)) {\n      element.append(fragment);\n    }\n\n    parentElement.append(element);\n\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n\n  return shouldInclude;\n}\n\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n\n  let currentConversion = null;\n\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\n\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\n\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode));\n  }\n\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n\n  return lexicalNodes;\n}\n\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}