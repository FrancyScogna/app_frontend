{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\n\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if (lexical.$isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if (lexical.$isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\n\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length; //sort rects from top left to bottom right.\n\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top; // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i]; // Exclude rects that overlap preceding Rects in the sorted list.\n\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left; // Exclude selections that span the entire element\n\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\n\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n\n      styleObject[key.trim()] = value.trim();\n    }\n  }\n  return styleObject;\n}\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\n\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\n\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\n/**\n * Returns a copy of a node, but generates a new key for the copy.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\n\nfunction $cloneWithProperties(node) {\n  const constructor = node.constructor; // @ts-expect-error\n\n  const clone = constructor.clone(node);\n  clone.__parent = node.__parent;\n  clone.__next = node.__next;\n  clone.__prev = node.__prev;\n  if (lexical.$isElementNode(node) && lexical.$isElementNode(clone)) {\n    return $updateElementNodeProperties(clone, node);\n  }\n  if (lexical.$isTextNode(node) && lexical.$isTextNode(clone)) {\n    return $updateTextNodeProperties(clone, node);\n  }\n  return clone;\n}\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\n\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const isBackward = selection.isBackward();\n      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\n\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  return point.offset === point.getNode().getChildrenSize();\n}\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\n\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if (lexical.$isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        if (lexical.$isElementNode(parentSibling)) {\n          nextNode = parentSibling.getLastDescendant();\n        } else {\n          nextNode = parentSibling;\n        }\n      }\n    }\n    let text = currentNode.getTextContent(); // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n\n    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!lexical.$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !lexical.$isRootNode(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey(); // See if we can just revert it to what was in the last editor state\n\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = lexical.$getNodeByKey(key);\n        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = lexical.$getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = lexical.$createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset; // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = lexical.$createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\n\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. { CSSProperty: value }\n */\n\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    const cellSelection = lexical.$createRangeSelection();\n    const cellSelectionAnchor = cellSelection.anchor;\n    const cellSelectionFocus = cellSelection.focus;\n    for (let i = 0; i < selectedNodesLength; i++) {\n      const node = selectedNodes[i];\n      if (lexical.DEPRECATED_$isGridCellNode(node)) {\n        cellSelectionAnchor.set(node.getKey(), 0, 'element');\n        cellSelectionFocus.set(node.getKey(), node.getChildrenSize(), 'element');\n        $patchStyleText(lexical.$normalizeSelection__EXPERIMENTAL(cellSelection), patch);\n      }\n    }\n    lexical.$setSelection(selection);\n    return;\n  }\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  if (selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    return;\n  }\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key; // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n\n  if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n    if (lexical.$isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  } // This is the case where we only selected a single node\n\n  if (selectedNodes.length === 1) {\n    if (lexical.$isTextNode(firstNode)) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.\n\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n      }\n      $patchStyle(firstNode, patch);\n    }\n    if (lexical.$isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length; // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      } // if the entire last node isn't selected, split it\n\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0) {\n        $patchStyle(lastNode, patch);\n      }\n    } // style all the text nodes in between\n\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\n\nfunction $setBlocksType(selection, createElement) {\n  if (selection.anchor.key === 'root') {\n    const element = createElement();\n    const root = lexical.$getRoot();\n    const firstChild = root.getFirstChild();\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n    return;\n  }\n  const nodes = selection.getNodes();\n  let maybeBlock = selection.anchor.getNode().getParentOrThrow();\n  if (nodes.indexOf(maybeBlock) === -1) {\n    nodes.push(maybeBlock);\n  }\n  if (maybeBlock.isInline()) {\n    maybeBlock = maybeBlock.getParentOrThrow();\n    if (nodes.indexOf(maybeBlock) === -1) {\n      nodes.push(maybeBlock);\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!isBlock(node)) {\n      continue;\n    }\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\nfunction isBlock(node) {\n  if (!lexical.$isElementNode(node) || lexical.$isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || lexical.$isLineBreakNode(firstChild) || lexical.$isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\n\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  const anchor = selection.anchor;\n  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i]; // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n\n    if (lexical.$isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\n\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = []; // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if (lexical.$isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set(); // Find any top level empty elements\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set(); // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement); // Move node and its siblings to the new\n        // element.\n\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if (lexical.$isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null; // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n\n  if (lexical.$isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if (lexical.$isElementNode(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = lexical.$getPreviousSelection();\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    lexical.$setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\n\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\n\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\n\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\n\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\n\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n  if (lexical.$isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n  if (lexical.$isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\n\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\n\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if (selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]; // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if (lexical.$isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\nexports.$addNodeStyle = $addNodeStyle;\nexports.$cloneWithProperties = $cloneWithProperties;\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\nexports.$isAtNodeEnd = $isAtNodeEnd;\nexports.$isParentElementRTL = $isParentElementRTL;\nexports.$moveCaretSelection = $moveCaretSelection;\nexports.$moveCharacter = $moveCharacter;\nexports.$patchStyleText = $patchStyleText;\nexports.$selectAll = $selectAll;\nexports.$setBlocksType = $setBlocksType;\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\nexports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\nexports.$wrapNodes = $wrapNodes;\nexports.createDOMRange = createDOMRange;\nexports.createRectsFromDOMRange = createRectsFromDOMRange;\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\nexports.trimTextContentFromAnchor = trimTextContentFromAnchor;","map":{"version":3,"names":["lexical","require","CSS_TO_STYLES","Map","getDOMTextNode","element","node","nodeType","Node","TEXT_NODE","firstChild","getDOMIndexWithinParent","parent","parentNode","Error","Array","from","childNodes","indexOf","createDOMRange","editor","anchorNode","_anchorOffset","focusNode","_focusOffset","anchorKey","getKey","focusKey","range","document","createRange","anchorDOM","getElementByKey","focusDOM","anchorOffset","focusOffset","$isTextNode","undefined","nodeName","setStart","setEnd","e","collapsed","createRectsFromDOMRange","rootElement","getRootElement","rootRect","getBoundingClientRect","computedStyle","getComputedStyle","rootPadding","parseFloat","paddingLeft","paddingRight","selectionRects","getClientRects","selectionRectsLength","length","sort","a","b","top","Math","abs","left","prevRect","i","selectionRect","isOverlappingRect","height","width","selectionSpansElement","splice","getStyleObjectFromRawCSS","css","styleObject","styles","split","style","key","value","trim","getStyleObjectFromCSS","get","set","Object","freeze","getCSSFromStyleObject","$updateElementNodeProperties","target","source","__first","__last","__size","__format","__indent","__dir","$updateTextNodeProperties","__style","__mode","__detail","$cloneWithProperties","constructor","clone","__parent","__next","__prev","$isElementNode","$sliceSelectedTextNodeContent","selection","textNode","isSelected","isSegmented","isToken","$isRangeSelection","DEPRECATED_$isGridSelection","anchor","getNode","focus","isAnchor","is","isFocus","isBackward","getCharacterOffsets","isSame","isFirst","isLast","startOffset","endOffset","offset","__text","slice","$isAtNodeEnd","point","type","getTextContentSize","getChildrenSize","trimTextContentFromAnchor","delCount","currentNode","remaining","descendantNode","getDescendantByIndex","nextNode","getPreviousSibling","additionalElementWhitespace","getParentOrThrow","parentSibling","getParent","isInline","getLastDescendant","text","getTextContent","currentNodeSize","remove","$isRootNode","prevTextContent","getEditorState","read","prevNode","$getNodeByKey","isSimpleText","slicedText","prevSelection","$getPreviousSelection","$createTextNode","replace","setTextContent","isCollapsed","prevOffset","select","splitStart","splitEnd","excessNode","splitText","$addNodeStyle","CSSText","getStyle","$patchStyle","patch","prevStyles","newStyles","entries","reduce","newCSSText","setStyle","$patchStyleText","selectedNodes","getNodes","selectedNodesLength","cellSelection","$createRangeSelection","cellSelectionAnchor","cellSelectionFocus","DEPRECATED_$isGridCellNode","$normalizeSelection__EXPERIMENTAL","$setSelection","lastIndex","firstNode","lastNode","firstNodeText","firstNodeTextLength","isBefore","startType","endType","endKey","nextSibling","getNextSibling","splitNodes","replacement","lastNodeText","lastNodeTextLength","__key","selectedNode","selectedNodeKey","$setBlocksType","createElement","root","$getRoot","getFirstChild","append","nodes","maybeBlock","push","isBlock","targetElement","setFormat","getFormatType","setIndent","getIndent","$isRootOrShadowRoot","isLeafElement","$isLineBreakNode","canBeEmpty","isPointAttached","isAttached","$removeParentEmptyElements","startingNode","latest","getLatest","$wrapNodes","wrappingElement","nodesLength","children","getChildren","forEach","child","topLevelNode","descendants","$wrapNodesImpl","$hasAncestor","elementMapping","elements","targetIsPrevSibling","prevSibling","emptyElements","Set","add","movedNodes","$isLeafNode","has","parentKey","getChildrenKeys","lastElement","insertAfter","insertBefore","selectEnd","dirty","$shouldOverrideDefaultCharacterSelection","possibleNode","$getAdjacentNode","$isDecoratorNode","isIsolated","$moveCaretSelection","isHoldingShift","granularity","modify","$isParentElementRTL","getDirection","$moveCharacter","isRTL","$selectAll","topParent","getTopLevelElementOrThrow","getFirstDescendant","firstType","lastType","lastOffset","$getNodeStyleValueForProperty","styleProperty","defaultValue","$getSelectionStyleValueForProperty","styleValue","endNode","nodeStyleValue","exports"],"sources":["C:/Users/franc/Desktop/Progetto/Frontend/app_frontend/node_modules/@lexical/selection/LexicalSelection.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\n\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\n\n\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n\n  if (lexical.$isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n\n  if (lexical.$isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n\n  const firstChild = anchorDOM.firstChild;\n\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n\n  return range;\n}\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\n\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    return [];\n  }\n\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length; //sort rects from top left to bottom right.\n\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top; // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n\n    return top;\n  });\n  let prevRect;\n\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i]; // Exclude rects that overlap preceding Rects in the sorted list.\n\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left; // Exclude selections that span the entire element\n\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n\n    prevRect = selectionRect;\n  }\n\n  return selectionRects;\n}\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\n\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n\n      styleObject[key.trim()] = value.trim();\n    }\n  }\n\n  return styleObject;\n}\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\n\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n\n  return value;\n}\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\n\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\n\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\n/**\n * Returns a copy of a node, but generates a new key for the copy.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\n\n\nfunction $cloneWithProperties(node) {\n  const constructor = node.constructor; // @ts-expect-error\n\n  const clone = constructor.clone(node);\n  clone.__parent = node.__parent;\n  clone.__next = node.__next;\n  clone.__prev = node.__prev;\n\n  if (lexical.$isElementNode(node) && lexical.$isElementNode(clone)) {\n    return $updateElementNodeProperties(clone, node);\n  }\n\n  if (lexical.$isTextNode(node) && lexical.$isTextNode(clone)) {\n    return $updateTextNodeProperties(clone, node);\n  }\n\n  return clone;\n}\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\n\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n\n    if (isAnchor || isFocus) {\n      const isBackward = selection.isBackward();\n      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n\n  return textNode;\n}\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\n\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n\n  return point.offset === point.getNode().getChildrenSize();\n}\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\n\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n\n  if (lexical.$isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n\n  while (remaining > 0 && currentNode !== null) {\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n\n      while (parentSibling === null) {\n        parent = parent.getParent();\n\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n\n        parentSibling = parent.getPreviousSibling();\n      }\n\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n\n        if (lexical.$isElementNode(parentSibling)) {\n          nextNode = parentSibling.getLastDescendant();\n        } else {\n          nextNode = parentSibling;\n        }\n      }\n    }\n\n    let text = currentNode.getTextContent(); // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n\n    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n\n    const currentNodeSize = text.length;\n\n    if (!lexical.$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n\n      if (parent != null && parent.getChildrenSize() === 0 && !lexical.$isRootNode(parent)) {\n        parent.remove();\n      }\n\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey(); // See if we can just revert it to what was in the last editor state\n\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = lexical.$getNodeByKey(key);\n\n        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = lexical.$getPreviousSelection();\n        let target = currentNode;\n\n        if (!currentNode.isSimpleText()) {\n          const textNode = lexical.$createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n\n        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset; // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = lexical.$createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n\n      remaining = 0;\n    }\n  }\n}\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\n\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n\n    return styles;\n  }, { ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. { CSSProperty: value }\n */\n\n\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n\n  if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    const cellSelection = lexical.$createRangeSelection();\n    const cellSelectionAnchor = cellSelection.anchor;\n    const cellSelectionFocus = cellSelection.focus;\n\n    for (let i = 0; i < selectedNodesLength; i++) {\n      const node = selectedNodes[i];\n\n      if (lexical.DEPRECATED_$isGridCellNode(node)) {\n        cellSelectionAnchor.set(node.getKey(), 0, 'element');\n        cellSelectionFocus.set(node.getKey(), node.getChildrenSize(), 'element');\n        $patchStyleText(lexical.$normalizeSelection__EXPERIMENTAL(cellSelection), patch);\n      }\n    }\n\n    lexical.$setSelection(selection);\n    return;\n  }\n\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n\n  if (selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key; // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n\n  if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  } // This is the case where we only selected a single node\n\n\n  if (selectedNodes.length === 1) {\n    if (lexical.$isTextNode(firstNode)) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.\n\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n\n  } else {\n    if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n      }\n\n      $patchStyle(firstNode, patch);\n    }\n\n    if (lexical.$isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length; // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      } // if the entire last node isn't selected, split it\n\n\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      if (endOffset !== 0) {\n        $patchStyle(lastNode, patch);\n      }\n    } // style all the text nodes in between\n\n\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\n\nfunction $setBlocksType(selection, createElement) {\n  if (selection.anchor.key === 'root') {\n    const element = createElement();\n    const root = lexical.$getRoot();\n    const firstChild = root.getFirstChild();\n\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n\n    return;\n  }\n\n  const nodes = selection.getNodes();\n  let maybeBlock = selection.anchor.getNode().getParentOrThrow();\n\n  if (nodes.indexOf(maybeBlock) === -1) {\n    nodes.push(maybeBlock);\n  }\n\n  if (maybeBlock.isInline()) {\n    maybeBlock = maybeBlock.getParentOrThrow();\n\n    if (nodes.indexOf(maybeBlock) === -1) {\n      nodes.push(maybeBlock);\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (!isBlock(node)) {\n      continue;\n    }\n\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\n\nfunction isBlock(node) {\n  if (!lexical.$isElementNode(node) || lexical.$isRootOrShadowRoot(node)) {\n    return false;\n  }\n\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || lexical.$isLineBreakNode(firstChild) || lexical.$isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\n\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\n\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n\n  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n\n    node = parentNode;\n  }\n}\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\n\n\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  const anchor = selection.anchor;\n\n  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n\n    target.replace(element);\n    return;\n  }\n\n  let topLevelNode = null;\n  let descendants = [];\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i]; // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n\n    if (lexical.$isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\n\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = []; // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n\n  let targetIsPrevSibling = false;\n\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n\n    target = target.getParentOrThrow();\n\n    if (lexical.$isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n\n  const emptyElements = new Set(); // Find any top level empty elements\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n\n  const movedNodes = new Set(); // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n\n    if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement); // Move node and its siblings to the new\n        // element.\n\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n\n          if (lexical.$isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n\n  let lastElement = null; // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n\n  if (lexical.$isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n\n      if (lexical.$isElementNode(firstChild)) {\n        target = firstChild;\n      }\n\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n\n  const prevSelection = lexical.$getPreviousSelection();\n\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    lexical.$setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\n\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\n\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\n\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\n\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\n\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n\n  if (lexical.$isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n\n  if (lexical.$isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\n\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n\n  return defaultValue;\n}\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\n\n\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n\n  if (selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]; // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n\n    if (lexical.$isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n\n  return styleValue === null ? defaultValue : styleValue;\n}\n\nexports.$addNodeStyle = $addNodeStyle;\nexports.$cloneWithProperties = $cloneWithProperties;\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\nexports.$isAtNodeEnd = $isAtNodeEnd;\nexports.$isParentElementRTL = $isParentElementRTL;\nexports.$moveCaretSelection = $moveCaretSelection;\nexports.$moveCharacter = $moveCharacter;\nexports.$patchStyleText = $patchStyleText;\nexports.$selectAll = $selectAll;\nexports.$setBlocksType = $setBlocksType;\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\nexports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\nexports.$wrapNodes = $wrapNodes;\nexports.createDOMRange = createDOMRange;\nexports.createRectsFromDOMRange = createRectsFromDOMRange;\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\nexports.trimTextContentFromAnchor = trimTextContentFromAnchor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}