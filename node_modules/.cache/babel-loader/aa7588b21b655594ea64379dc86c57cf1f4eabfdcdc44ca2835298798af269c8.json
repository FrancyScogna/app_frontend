{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createCommand(type) {\n  return {\n    type\n  };\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3; // Reconciling\n\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2; // Text node modes\n\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2; // IS_INERT = 3\n// Text node formatting\n\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT; // Text node details\n\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1; // Element node formatting\n\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6; // Reconciliation\n\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b'; // For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\n\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n'; // For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\n\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'; // eslint-disable-next-line no-misleading-character-class\n\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']'); // eslint-disable-next-line no-misleading-character-class\n\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcesssingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  return (\n    // @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom ||\n    // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement(); // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\n          continue;\n        }\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            handleTextMutation(\n            // nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true; // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      } // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n              if (correctDOM === null) {\n                continue;\n              }\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      } // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n\n      const records = observer.takeRecords(); // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        } // Clear any of those removal mutations\n\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  } // Backward\n\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  } // Forward\n\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet keyCounter = 1;\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (activeElement === null) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' &&\n  // @ts-ignore iternal field\n  activeElement.__lexicalEditor == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    // @ts-expect-error: internal field\n    const editor = currentNode.__lexicalEditor;\n    if (editor != null) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\nfunction isDOMNodeLexicalTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  const isStateFlagPresent = format & activeFormat;\n  if (isStateFlagPresent && (alignWithFormat === null || (alignWithFormat & activeFormat) === 0)) {\n    // Remove the state flag.\n    return format ^ activeFormat;\n  }\n  if (alignWithFormat === null || alignWithFormat & activeFormat) {\n    // Add the state flag.\n    return format | activeFormat;\n  }\n  return format;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node); // TODO Split this function into leaf/element\n\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling(); // TODO: this function duplicates a bunch of operations, can be simplified.\n\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n} // Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\n\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor(); // @ts-ignore We intentionally add this to the Node.\n\n  const key = dom[`__lexicalKey_${editor._key}`];\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n    if (editorState.isEmpty()) {\n      return;\n    }\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n    const nodeMap = editorState._nodeMap;\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection._cachedNodes = null;\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\nfunction getNodeKeyFromDOM(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key = node[`__lexicalKey_${editor._key}`];\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n  return null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter())) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n} // This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\n\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(keyCode, altKey, ctrlKey, metaKey) {\n  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(keyCode, shiftKey) {\n  return isReturn(keyCode) && !shiftKey;\n}\nfunction isLineBreak(keyCode, shiftKey) {\n  return isReturn(keyCode) && shiftKey;\n} // Inserts a new line after the selection\n\nfunction isOpenLineBreak(keyCode, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && keyCode === 79;\n}\nfunction isDeleteWordBackward(keyCode, altKey, ctrlKey) {\n  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(keyCode, altKey, ctrlKey) {\n  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(keyCode);\n}\nfunction isDeleteLineForward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isDelete(keyCode);\n}\nfunction isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(keyCode);\n}\nfunction isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(keyCode) || keyCode === 68 && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(keyCode);\n}\nfunction isUndo(keyCode, shiftKey, metaKey, ctrlKey) {\n  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return keyCode === 90 && metaKey && shiftKey;\n  }\n  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;\n}\nfunction isCopy(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (keyCode === 67) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isCut(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (keyCode === 88) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isArrowLeft(keyCode) {\n  return keyCode === 37;\n}\nfunction isArrowRight(keyCode) {\n  return keyCode === 39;\n}\nfunction isArrowUp(keyCode) {\n  return keyCode === 38;\n}\nfunction isArrowDown(keyCode) {\n  return keyCode === 40;\n}\nfunction isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(keyCode, ctrlKey, metaKey) {\n  return isArrowUp(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(keyCode, ctrlKey, metaKey) {\n  return isArrowDown(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(keyCode) {\n  return keyCode === 32;\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nfunction isReturn(keyCode) {\n  return keyCode === 13;\n}\nfunction isBackspace(keyCode) {\n  return keyCode === 8;\n}\nfunction isEscape(keyCode) {\n  return keyCode === 27;\n}\nfunction isDelete(keyCode) {\n  return keyCode === 46;\n}\nfunction isSelectAll(keyCode, metaKey, ctrlKey) {\n  return keyCode === 65 && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll() {\n  const root = $getRoot();\n  const selection = root.select(0, root.getChildrenSize());\n  $setSelection($normalizeSelection(selection));\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n  const classNames = classNamesTheme[classNameThemeType]; // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n\n  if (typeof classNames === 'string') {\n    const classNamesArr = classNames.split(' ');\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey); // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n  if (defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = domElem.ownerDocument;\n  return ownerDoc && ownerDoc.defaultView || null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\nfunction $copyNode(node) {\n  // @ts-ignore\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n    }\n  }\n  const replaceFunc = registeredNode.replace;\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node);\n    if (!(replacementNode instanceof node.constructor)) {\n      {\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\n      }\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = blockCursorTheme.split(' '); // @ts-expect-error: intentional\n\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  } // Remove cursor\n\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent); // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n}\nfunction $getChildrenRecursively(node) {\n  const nodes = [];\n  const stack = [node];\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    if (!(currentNode !== undefined)) {\n      throw Error(`Stack.length > 0; can't be undefined`);\n    }\n    if ($isElementNode(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n  return nodes;\n}\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\n\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n/**\n * @param x - The element being testing\n * @returns Returns true if x is an HTML element, false otherwise.\n */\n\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key; // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      } // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMapDelete.push(childKey);\n    }\n    child = child.getNextSibling();\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap; // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n\n  const nodeMapDelete = [];\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        } // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  } // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '40px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1); // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      } // Decorators are always non editable\n\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  createChildren(children, element, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    createNode(children[startIndex], dom, insertDOM);\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  } // @ts-expect-error: internal field\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\n} // If we end an element with a LineBreakNode, then we need to add an additional <br>\n\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n      if (element != null) {\n        dom.removeChild(element);\n      } // @ts-expect-error: internal field\n\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br'); // @ts-expect-error: internal field\n\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent =\n  // @ts-expect-error: internal field\n  dom.__lexicalDirTextContent; // @ts-expect-error: internal field\n\n  const previousDirection = dom.__lexicalDir;\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined; // Remove the old theme classes if they exist\n\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = previousDirectionTheme.split(' ');\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        } // @ts-ignore: intentional\n\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = nextDirectionTheme.split(' '); // @ts-expect-error: intentional\n\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        } // Update direction\n\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction; // @ts-expect-error: internal field\n\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent; // @ts-expect-error: internal field\n\n    dom.__lexicalDir = direction;\n  }\n}\nfunction reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  reconcileChildren(prevElement, nextElement, dom);\n  reconcileBlockDirection(nextElement, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction reconcileChildren(prevElement, nextElement, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFrstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFrstChildKey) {\n      reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = createNode(nextFrstChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevFirstChildKey, null);\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  } // @ts-expect-error: internal field\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key); // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      } // @ts-expect-error: internal field\n\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  } // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  } // Update node. If it returns true, we need to unmount and re-create the node\n\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = createNode(key, null, null);\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    nextNode = nextNode.getWritable();\n    nextNode.__cachedText = editorTextContent;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getFirstChild(element) {\n  return element.firstChild;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n          reconcileNode(nextKey, dom);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\nfunction reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = ''; // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap); // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  reconcileNode('root', null); // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n\n  activeEditor$1 = undefined; // @ts-ignore\n\n  activeEditorNodes = undefined; // @ts-ignore\n\n  activeDirtyElements = undefined; // @ts-ignore\n\n  activeDirtyLeaves = undefined; // @ts-ignore\n\n  activePrevNodeMap = undefined; // @ts-ignore\n\n  activeNextNodeMap = undefined; // @ts-ignore\n\n  activeEditorConfig = undefined; // @ts-ignore\n\n  activePrevKeyToDOMMap = undefined; // @ts-ignore\n\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap; // @ts-ignore We intentionally add this to the Node.\n\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = 0;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nlet rootElementsRegistered = 0;\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0]; // This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false; // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    const selection = $getSelection(); // Update the selection format\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        } // If we have marked a collapsed selection format, and we're\n        // within the given time range – then attempt to use that format\n        // instead of getting the format from the anchor node.\n\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element') {\n            selection.format = 0;\n            selection.style = '';\n          }\n        }\n      } else {\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          if ($isTextNode(node)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n} // This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\n\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Tripple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n        if (domAnchorNode !== null) {\n          const nodeType = domAnchorNode.nodeType; // If the user is attempting to click selection back onto text, then\n          // we should attempt create a range selection.\n          // When we click on an empty paragraph node or the end of a paragraph that ends\n          // with an image/poll, the nodeType will be ELEMENT_NODE\n\n          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {\n            const newSelection = internalCreateRangeSelection(lastSelection, domSelection, editor);\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n  const targetRanges = event.getTargetRanges();\n  if (targetRanges.length === 0) {\n    return null;\n  }\n  return targetRanges[0];\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event); // We let the browser do its own thing for composition.\n\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        // Used for handling backspace in Android.\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && selection.anchor.key === selection.focus.key) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0; // Fixes an Android bug where selection flickers when backspacing\n\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          event.preventDefault();\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data; // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    } // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null); // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n    }\n  });\n}\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection === null) {\n        return;\n      }\n      const offset = anchor.offset; // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length; // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      } // This ensures consistency on Android.\n\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData); // onInput always fires after onCompositionEnd for FF.\n\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    } // Also flush any other mutations that might have occurred\n    // since the change.\n\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null); // Handle termination of composition.\n\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    } // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.keyCode;\n  if (editor.isComposing()) {\n    return;\n  }\n  const {\n    keyCode,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(keyCode, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(keyCode)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(keyCode, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(keyCode, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(keyCode)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(keyCode)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(keyCode)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(keyCode, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      } // FF does it well (no need to override behavior)\n    } else if (!IS_FIREFOX && isSelectAll(keyCode, metaKey, ctrlKey)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = []; // @ts-expect-error: internal field\n\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n} // Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\n\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const target = event.target;\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (domAnchorNode === null) {\n        return;\n      }\n      const nodeType = domAnchorNode.nodeType; // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n      const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor);\n      $setSelection(newSelection);\n    });\n  } // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true); // If newly selected editor is nested, then add it to the map, clean map otherwise\n\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  if (rootElementsRegistered === 0) {\n    const doc = rootElement.ownerDocument;\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered++; // @ts-expect-error: internal field\n\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable()) {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable()) {\n        switch (eventName) {\n          case 'cut':\n            return dispatchCommand(editor, CUT_COMMAND, event);\n          case 'copy':\n            return dispatchCommand(editor, COPY_COMMAND, event);\n          case 'paste':\n            return dispatchCommand(editor, PASTE_COMMAND, event);\n          case 'dragstart':\n            return dispatchCommand(editor, DRAGSTART_COMMAND, event);\n          case 'dragover':\n            return dispatchCommand(editor, DRAGOVER_COMMAND, event);\n          case 'dragend':\n            return dispatchCommand(editor, DRAGEND_COMMAND, event);\n          case 'focus':\n            return dispatchCommand(editor, FOCUS_COMMAND, event);\n          case 'blur':\n            {\n              return dispatchCommand(editor, BLUR_COMMAND, event);\n            }\n          case 'drop':\n            return dispatchCommand(editor, DROP_COMMAND, event);\n        }\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  if (rootElementsRegistered !== 0) {\n    rootElementsRegistered--; // We only want to have a single global selectionchange event handler, shared\n    // between all editor instances.\n\n    if (rootElementsRegistered === 0) {\n      const doc = rootElement.ownerDocument;\n      doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n    }\n  } // @ts-expect-error: internal field\n\n  const editor = rootElement.__lexicalEditor;\n  if (editor !== null && editor !== undefined) {\n    cleanActiveNestedEditorsMap(editor); // @ts-expect-error: internal field\n\n    rootElement.__lexicalEditor = null;\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  } // @ts-expect-error: internal field\n\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n  constructor(key) {\n    // @ts-expect-error\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type,\n        // @ts-expect-error\n        this.constructor);\n      }\n    }\n  } // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n\n  getType() {\n    return this.__type;\n  }\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    } // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n\n    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element' && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {\n      return false;\n    }\n    return isSelected;\n  }\n  /**\n   * Returns this nodes key.\n   */\n\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n\n  isParentOf(targetNode) {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  } // TO-DO: this function can be simplified a lot\n\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n  /**\n   * Returns a mutable version of the node. Will throw an error if\n   * called outside of a Lexical Editor {@link LexicalEditor.update} callback.\n   *\n   */\n\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key; // Ensure we get the latest node from pending state\n\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection._cachedNodes = null;\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const constructor = latestNode.constructor; // @ts-expect-error\n\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n    mutableNode.__next = latestNode.__next;\n    mutableNode.__prev = latestNode.__prev;\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      mutableNode.__first = latestNode.__first;\n      mutableNode.__last = latestNode.__last;\n      mutableNode.__size = latestNode.__size;\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n    }\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode); // Update reference in node map\n\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n\n  getTextContent() {\n    return '';\n  }\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n\n  getTextContentSize() {\n    return this.getTextContent().length;\n  } // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n\n  exportJSON() {\n    {\n      throw Error(`exportJSON: base method not extended`);\n    }\n  }\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n\n  static transform() {\n    return null;\n  } // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n\n  remove(preserveEmptyParent) {\n    removeNode(this, true, preserveEmptyParent);\n  }\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) selection = selection.clone();\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev; // TODO: this is O(n), can we improve?\n\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n\n  isParentRequired() {\n    return false;\n  }\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n\n  markDirty() {\n    this.getWritable();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type); // Common error - split in its own invariant\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        const parentElement = node.parentElement; // If the <br> is the only child, then skip including it\n\n        let firstChild;\n        let lastChild;\n        if (parentElement !== null && ((firstChild = parentElement.firstChild) === node || firstChild.nextSibling === node && firstChild.nodeType === DOM_TEXT_TYPE && (firstChild.textContent || '').match(/^( |\\t|\\r?\\n)+$/) !== null) && ((lastChild = parentElement.lastChild) === node || lastChild.previousSibling === node && lastChild.nodeType === DOM_TEXT_TYPE && (lastChild.textContent || '').match(/^( |\\t|\\r?\\n)+$/) !== null)) {\n          return null;\n        }\n        return {\n          conversion: convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode();\n  }\n  exportJSON() {\n    return {\n      type: 'linebreak',\n      version: 1\n    };\n  }\n}\nfunction convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList; // Firstly we handle the base theme.\n\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  } // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing(); // Always add a suffix if we're composing a node\n\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        } // @ts-expect-error\n\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme; // Apply theme class names\n\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n/** @noInheritDoc */\n\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  } // View\n\n  createDOM(config) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme; // Apply theme class names\n\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  } // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n    if (!(element !== null && isHTMLElement(element))) {\n      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n    element.style.whiteSpace = 'pre-wrap'; // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1\n    };\n  } // Mutators\n\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.togglerUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it is present.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n\n  toggleFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return this.setFormat(this.getFormat() ^ formatFlag);\n  }\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n\n  canInsertTextBefore() {\n    return true;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n\n  canInsertTextAfter() {\n    return true;\n  }\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    } // Handle selection\n\n    const selection = $getSelection(); // Then handle all other parts\n\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    } // Insert the nodes into the parent's children\n\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const insertionIndex = this.getIndexWithinParent();\n    if (hasReplacedSelf) {\n      writableParent.splice(insertionIndex, 0, splitNodes);\n      this.remove();\n    } else {\n      writableParent.splice(insertionIndex, 1, splitNodes);\n    }\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n    return splitNodes;\n  }\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode; // Google Docs uses span tags + font-weight for bold text\n\n  const hasBoldFontWeight = span.style.fontWeight === '700'; // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n\n  const hasLinethroughTextDecoration = span.style.textDecoration === 'line-through'; // Google Docs uses span tags + font-style for italic text\n\n  const hasItalicFontStyle = span.style.fontStyle === 'italic'; // Google Docs uses span tags + text-decoration: underline for underline text\n\n  const hasUnderlineTextDecoration = span.style.textDecoration === 'underline'; // Google Docs uses span tags + vertical-align to specify subscript and superscript\n\n  const verticalAlign = span.style.verticalAlign;\n  return {\n    forChild: lexicalNode => {\n      if (!$isTextNode(lexicalNode)) {\n        return lexicalNode;\n      }\n      if (hasBoldFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n      if (hasLinethroughTextDecoration) {\n        lexicalNode.toggleFormat('strikethrough');\n      }\n      if (hasItalicFontStyle) {\n        lexicalNode.toggleFormat('italic');\n      }\n      if (hasUnderlineTextDecoration) {\n        lexicalNode.toggleFormat('underline');\n      }\n      if (verticalAlign === 'sub') {\n        lexicalNode.toggleFormat('subscript');\n      }\n      if (verticalAlign === 'super') {\n        lexicalNode.toggleFormat('superscript');\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode; // Google Docs wraps all copied HTML in a <b> with font-weight normal\n\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nconst preParentCache = new WeakMap();\nfunction isNodePre(node) {\n  return node.nodeName === 'PRE' || node.nodeType === DOM_ELEMENT_TYPE && node.style.whiteSpace.startsWith('pre');\n}\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n  const resultNode = cached === undefined ? parent : cached;\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n  return resultNode;\n}\nfunction convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n  let textContent = domNode_.textContent || ''; // No collapse and preserve segment break for pre, pre-wrap and pre-line\n\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n    return {\n      node: nodes\n    };\n  }\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n        isStartOfLine = false;\n        break;\n      }\n    }\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nconst inlineParents = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, 'i');\nfunction findTextInLine(text, forward) {\n  let node = text; // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    let sibling;\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n      if (parentElement === null) {\n        return null;\n      }\n      node = parentElement;\n    }\n    node = sibling;\n    if (node.nodeType === DOM_ELEMENT_TYPE) {\n      const display = node.style.display;\n      if (display === '' && node.nodeName.match(inlineParents) === null || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n    let descendant = node;\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n    if (node.nodeType === DOM_TEXT_TYPE) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format)) {\n        lexicalNode.toggleFormat(format);\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n  static clone(node) {\n    const newNode = new TabNode(node.__key); // TabNode __text can be either '\\t' or ''. insertText will remove the empty Node\n\n    newNode.__text = node.__text;\n    newNode.__format = node.__format;\n    newNode.__style = node.__style;\n    return newNode;\n  }\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedTabNode) {\n    const node = $createTabNode();\n    node.setFormat(serializedTabNode.format);\n    node.setStyle(serializedTabNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'tab',\n      version: 1\n    };\n  }\n  setTextContent(_text) {\n    {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n  }\n  setDetail(_detail) {\n    {\n      throw Error(`TabNode does not support setDetail`);\n    }\n  }\n  setMode(_type) {\n    {\n      throw Error(`TabNode does not support setMode`);\n    }\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Point {\n  constructor(key, offset, type) {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection._cachedNodes = null;\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target); // Fix the end point offset if it refers to the same element as start,\n    // as we've now inserted another element before it. Note that we only\n    // do it if selection is not collapsed as otherwise it'll transfer\n    // both focus and anchor to the text node below\n\n    if (end.type === 'element' && end.key === start.key && end.offset !== start.offset) {\n      end.set(end.key, end.offset + 1, 'element');\n    }\n  } // Transfer the element point to a text point.\n\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\nclass NodeSelection {\n  constructor(objects) {\n    this.dirty = false;\n    this._nodes = objects;\n    this._cachedNodes = null;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {// Do nothing?\n  }\n  insertText() {// Do nothing?\n  }\n  insertNodes(nodes, selectStart) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd; // Insert nodes\n\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes, selectStart); // Remove selected nodes\n\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n    return true;\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nfunction DEPRECATED_$getGridCellNodeRect(GridCellNode) {\n  const [CellNode,, GridNode] = DEPRECATED_$getNodeTriplet(GridCellNode);\n  const rows = GridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length; // Create a matrix of the same size as the table to track the position of each cell\n\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1; // Put the cell into the corresponding position in the matrix\n\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      } // Return to the original index, row span and column span of the cell.\n\n      if (CellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\nclass GridSelection {\n  constructor(gridKey, anchor, focus) {\n    this.gridKey = gridKey;\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n  is(selection) {\n    if (!DEPRECATED_$isGridSelection(selection)) {\n      return false;\n    }\n    return this.gridKey === selection.gridKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(gridKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.gridKey = gridKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new GridSelection(this.gridKey, this.anchor, this.focus);\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {// Do nothing?\n  }\n  insertText() {// Do nothing?\n  }\n  insertNodes(nodes, selectStart) {\n    const focusNode = this.focus.getNode();\n    const selection = $normalizeSelection(focusNode.select(0, focusNode.getChildrenSize()));\n    return selection.insertNodes(nodes, selectStart);\n  } // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n    if (!DEPRECATED_$isGridCellNode(anchorCellNode)) {\n      throw Error(`Expected GridSelection anchor to be (or a child of) GridCellNode`);\n    }\n    const anchorCellNodeRect = DEPRECATED_$getGridCellNodeRect(anchorCellNode);\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNode = $getNodeByKey(this.focus.key);\n    if (!DEPRECATED_$isGridCellNode(focusCellNode)) {\n      throw Error(`Expected GridSelection focus to be (or a child of) GridCellNode`);\n    }\n    const focusCellNodeRect = DEPRECATED_$getGridCellNodeRect(focusCellNode);\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = $findMatchingParent(anchorNode, DEPRECATED_$isGridCellNode); // todo replace with triplet\n\n    const focusCell = $findMatchingParent(focusNode, DEPRECATED_$isGridCellNode);\n    if (!DEPRECATED_$isGridCellNode(anchorCell)) {\n      throw Error(`Expected GridSelection anchor to be (or a child of) GridCellNode`);\n    }\n    if (!DEPRECATED_$isGridCellNode(focusCell)) {\n      throw Error(`Expected GridSelection focus to be (or a child of) GridCellNode`);\n    }\n    const anchorRow = anchorCell.getParent();\n    if (!DEPRECATED_$isGridRowNode(anchorRow)) {\n      throw Error(`Expected anchorCell to have a parent GridRowNode`);\n    }\n    const gridNode = anchorRow.getParent();\n    if (!DEPRECATED_$isGridNode(gridNode)) {\n      throw Error(`Expected tableNode to have a parent GridNode`);\n    } // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing GridSelection and moving the logic to the plugin would make\n    // this possible.\n\n    const [map, cellAMap, cellBMap] = DEPRECATED_$computeGridMap(gridNode, anchorCell, focusCell);\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n    function expandBoundary(mapValue) {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n        exploredMinColumn = previousColumn;\n      }\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n        exploredMinRow = previousRow;\n      }\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n        exploredMaxColumn = nextColumn;\n      }\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n        exploredMaxRow = nextRow;\n      }\n    }\n    const nodes = [gridNode];\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!DEPRECATED_$isGridRowNode(currentRow)) {\n          throw Error(`Expected GridCellNode parent to be a GridRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodes.push(currentRow);\n        }\n        nodes.push(cell, ...$getChildrenRecursively(cell));\n        lastRow = currentRow;\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction DEPRECATED_$isGridSelection(x) {\n  return x instanceof GridSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this.format = format;\n    this.style = style;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset); // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n    let nodes;\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n    this.insertNodes(nodes);\n  }\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection as a new\n   * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.\n   *\n   * @param text the text to insert into the Selection\n   */\n\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = this.isCollapsed() || anchor.isBefore(focus);\n    const format = this.format;\n    const style = this.style;\n    if (isBefore && anchor.type === 'element') {\n      $transferStartingElementPointToTextPoint(anchor, focus, format, style);\n    } else if (!isBefore && focus.type === 'element') {\n      $transferStartingElementPointToTextPoint(focus, anchor, format, style);\n    }\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const firstPoint = isBefore ? anchor : focus;\n    const endPoint = isBefore ? focus : anchor;\n    const startOffset = firstPoint.offset;\n    const endOffset = endPoint.offset;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          } // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]); // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode; // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      } // Handle mutations to the last node.\n\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          } // root node selections only select whole nodes, so no text splice is necessary\n\n          if (!$isRootNode(endPoint.getNode())) {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      } // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement); // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      } // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      } // Remove all selected nodes that haven't already been removed.\n\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n\n  removeText() {\n    this.insertText('');\n  }\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   */\n\n  formatText(formatType) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType); // When changing format, we should stop composition\n\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType); // When changing format, we should stop composition\n\n      $setCompositionKey(null);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset; // In case selection started at the end of text node use next text node\n\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize(); // Single node selected\n\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n      if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat); // Update selection only if starts/ends on text node\n\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    } // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n\n    if (startOffset !== 0) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat); // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize()) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    } // Process all text nodes in between\n\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      if (!textNode.isToken()) {\n        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n        textNode.setFormat(nextFormat);\n      }\n    } // Update selection only if starts/ends on text node\n\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accomodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   * @param selectStart - whether or not to select the start after the insertion.\n   * @returns true if the nodes were inserted successfully, false otherwise.\n   */\n\n  insertNodes(nodes, selectStart) {\n    // If there is a range selected remove the text in it\n    if (!this.isCollapsed()) {\n      const selectionEnd = this.isBackward() ? this.anchor : this.focus;\n      const nextSibling = selectionEnd.getNode().getNextSibling();\n      const nextSiblingKey = nextSibling ? nextSibling.getKey() : null;\n      const prevSibling = selectionEnd.getNode().getPreviousSibling();\n      const prevSiblingKey = prevSibling ? prevSibling.getKey() : null;\n      this.removeText(); // If the selection has been moved to an adjacent inline element, create\n      // a temporary text node that we can insert the nodes after.\n\n      if (this.isCollapsed() && this.focus.type === 'element') {\n        let textNode;\n        if (this.focus.key === nextSiblingKey && this.focus.offset === 0) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertBefore(textNode);\n        } else if (this.focus.key === prevSiblingKey && this.focus.offset === this.focus.getNode().getChildrenSize()) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertAfter(textNode);\n        }\n        if (textNode) {\n          this.focus.set(textNode.__key, 0, 'text');\n          this.anchor.set(textNode.__key, 0, 'text');\n        }\n      }\n    }\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    const anchorNode = anchor.getNode();\n    let target = anchorNode;\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n      const placementNode = element.getChildAtIndex(anchorOffset - 1);\n      if (placementNode === null) {\n        target = element;\n      } else {\n        target = placementNode;\n      }\n    }\n    const siblings = []; // Get all remaining text node siblings in this element so we can\n    // append them after the last node we're inserting.\n\n    const nextSiblings = anchorNode.getNextSiblings();\n    const topLevelElement = $isRootOrShadowRoot(anchorNode) ? null : anchorNode.getTopLevelElementOrThrow();\n    if ($isTextNode(anchorNode)) {\n      const textContent = anchorNode.getTextContent();\n      const textContentLength = textContent.length;\n      if (anchorOffset === 0 && textContentLength !== 0) {\n        const prevSibling = anchorNode.getPreviousSibling();\n        if (prevSibling !== null) {\n          target = prevSibling;\n        } else {\n          target = anchorNode.getParentOrThrow();\n        }\n        siblings.push(anchorNode);\n      } else if (anchorOffset === textContentLength) {\n        target = anchorNode;\n      } else if (anchorNode.isToken()) {\n        // Do nothing if we're inside a token node\n        return false;\n      } else {\n        // If we started with a range selected grab the danglingText after the\n        // end of the selection and put it on our siblings array so we can\n        // append it after the last node we're inserting\n        let danglingText;\n        [target, danglingText] = anchorNode.splitText(anchorOffset);\n        siblings.push(danglingText);\n      }\n    }\n    const startingNode = target;\n    siblings.push(...nextSiblings);\n    const firstNode = nodes[0];\n    let didReplaceOrMerge = false;\n    let lastNode = null; // Time to insert the nodes!\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!$isRootOrShadowRoot(target) && !$isDecoratorNode(target) && $isElementNode(node) && !node.isInline()) {\n        // -----\n        // Heuristics for the replacement or merging of elements\n        // -----\n        // If we have an incoming element node as the first node, then we'll need\n        // see if we can merge any descendant leaf nodes into our existing target.\n        // We can do this by finding the first descendant in our node and then we can\n        // pluck it and its parent (siblings included) out and insert them directly\n        // into our target. We only do this for the first node, as we are only\n        // interested in merging with the anchor, which is our target.\n        //\n        // If we apply either the replacement or merging heuristics, we need to be\n        // careful that we're not trying to insert a non-element node into a root node,\n        // so we check if the target's parent after this logic is the root node and if\n        // so we trigger an invariant to ensure this problem is caught in development\n        // and fixed accordingly.\n        if (node.is(firstNode)) {\n          if ($isElementNode(target) && target.isEmpty() && target.canReplaceWith(node)) {\n            target.replace(node);\n            target = node;\n            didReplaceOrMerge = true;\n            continue;\n          } // We may have a node tree where there are many levels, for example with\n          // lists and tables. So let's find the first descendant to try and merge\n          // with. So if we have the target:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //\n          // and we are trying to insert:\n          //\n          // ListNode (3)\n          //   ListItemNode (4)\n          //     Text (5)\n          //   ListItemNode (6)\n          //\n          // The result would be:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //   Text (5)\n          //\n\n          const firstDescendant = node.getFirstDescendant();\n          if ($isLeafNode(firstDescendant)) {\n            let element = firstDescendant.getParentOrThrow();\n            while (element.isInline()) {\n              element = element.getParentOrThrow();\n            }\n            const children = element.getChildren();\n            const childrenLength = children.length;\n            if ($isElementNode(target)) {\n              let firstChild = target.getFirstChild();\n              for (let s = 0; s < childrenLength; s++) {\n                const child = children[s];\n                if (firstChild === null) {\n                  target.append(child);\n                } else {\n                  firstChild.insertAfter(child);\n                }\n                firstChild = child;\n              }\n            } else {\n              for (let s = childrenLength - 1; s >= 0; s--) {\n                target.insertAfter(children[s]);\n              }\n              target = target.getParentOrThrow();\n            }\n            lastNode = children[childrenLength - 1];\n            element.remove();\n            didReplaceOrMerge = true;\n            if (element.is(node)) {\n              continue;\n            }\n          }\n        }\n        if ($isTextNode(target)) {\n          if (topLevelElement === null) {\n            {\n              throw Error(`insertNode: topLevelElement is root node`);\n            }\n          }\n          target = topLevelElement;\n        }\n      } else if (didReplaceOrMerge && !$isElementNode(node) && !$isDecoratorNode(node) && $isRootOrShadowRoot(target.getParent())) {\n        {\n          throw Error(`insertNodes: cannot insert a non-element into a root node`);\n        }\n      }\n      didReplaceOrMerge = false;\n      if ($isElementNode(target) && !target.isInline()) {\n        lastNode = node;\n        if ($isDecoratorNode(node) && !node.isInline()) {\n          if (nodes.length === 1 && target.canBeEmpty() && target.isEmpty()) {\n            target = target.insertBefore(node, false);\n          } else {\n            target = target.insertAfter(node, false);\n          }\n        } else if (!$isElementNode(node)) {\n          const firstChild = target.getFirstChild();\n          if (firstChild !== null) {\n            firstChild.insertBefore(node);\n          } else {\n            target.append(node);\n          }\n          target = node;\n        } else {\n          if (!node.canBeEmpty() && node.isEmpty()) {\n            continue;\n          }\n          if ($isRootNode(target)) {\n            const placementNode = target.getChildAtIndex(anchorOffset);\n            if (placementNode !== null) {\n              placementNode.insertBefore(node);\n            } else {\n              target.append(node);\n            }\n            target = node;\n          } else if (node.isInline()) {\n            target.append(node);\n            target = node;\n          } else {\n            target = target.insertAfter(node, false);\n          }\n        }\n      } else if (!$isElementNode(node) || $isElementNode(node) && node.isInline() || $isDecoratorNode(target) && !target.isInline()) {\n        lastNode = node; // when pasting top level node in the middle of paragraph\n        // we need to split paragraph instead of placing it inline\n\n        if ($isRangeSelection(this) && $isDecoratorNode(node) && ($isElementNode(target) || $isTextNode(target)) && !node.isInline()) {\n          let splitNode;\n          let splitOffset;\n          if ($isTextNode(target)) {\n            splitNode = target.getParentOrThrow();\n            const [textNode] = target.splitText(anchorOffset);\n            splitOffset = textNode.getIndexWithinParent() + 1;\n          } else {\n            splitNode = target;\n            splitOffset = anchorOffset;\n          }\n          const [, rightTree] = $splitNode(splitNode, splitOffset);\n          target = rightTree.insertBefore(node);\n        } else {\n          target = target.insertAfter(node, false);\n        }\n      } else {\n        const nextTarget = target.getParentOrThrow(); // if we're inserting an Element after a LineBreak, we want to move the target to the parent\n        // and remove the LineBreak so we don't have empty space.\n\n        if ($isLineBreakNode(target)) {\n          target.remove();\n        }\n        target = nextTarget; // Re-try again with the target being the parent\n\n        i--;\n        continue;\n      }\n    }\n    if (selectStart) {\n      // Handle moving selection to start for all nodes\n      if ($isTextNode(startingNode)) {\n        startingNode.select();\n      } else {\n        const prevSibling = target.getPreviousSibling();\n        if ($isTextNode(prevSibling)) {\n          prevSibling.select();\n        } else {\n          const index = target.getIndexWithinParent();\n          target.getParentOrThrow().select(index, index);\n        }\n      }\n    }\n    if ($isElementNode(target)) {\n      // If the last node to be inserted was a text node,\n      // then we should attempt to move selection to that.\n      const lastChild = $isTextNode(lastNode) ? lastNode : $isElementNode(lastNode) && lastNode.isInline() ? lastNode.getLastDescendant() : target.getLastDescendant();\n      if (!selectStart) {\n        // Handle moving selection to end for elements\n        if (lastChild === null) {\n          target.select();\n        } else if ($isTextNode(lastChild)) {\n          if (lastChild.getTextContent() === '') {\n            lastChild.selectPrevious();\n          } else {\n            lastChild.select();\n          }\n        } else {\n          lastChild.selectNext();\n        }\n      }\n      if (siblings.length !== 0) {\n        const originalTarget = target;\n        for (let i = siblings.length - 1; i >= 0; i--) {\n          const sibling = siblings[i];\n          const prevParent = sibling.getParentOrThrow();\n          if ($isElementNode(target) && !$isBlockElementNode(sibling) && !($isDecoratorNode(sibling) && (\n          // Note: We are only looking for decorators that are inline and not isolated.\n          !sibling.isInline() || sibling.isIsolated()))) {\n            if (originalTarget === target) {\n              target.append(sibling);\n            } else {\n              target.insertBefore(sibling);\n            }\n            target = sibling;\n          } else if (!$isElementNode(target) && !$isBlockElementNode(sibling)) {\n            target.insertBefore(sibling);\n            target = sibling;\n          } else {\n            if ($isElementNode(sibling) && !sibling.canInsertAfter(target)) {\n              // @ts-ignore The clone method does exist on the constructor.\n              const prevParentClone = prevParent.constructor.clone(prevParent);\n              if (!$isElementNode(prevParentClone)) {\n                {\n                  throw Error(`insertNodes: cloned parent clone is not an element`);\n                }\n              }\n              prevParentClone.append(sibling);\n              target.insertAfter(prevParentClone);\n            } else {\n              target.insertAfter(sibling);\n            }\n          } // Check if the prev parent is empty, as it might need\n          // removing.\n\n          if (prevParent.isEmpty() && !prevParent.canBeEmpty()) {\n            prevParent.remove();\n          }\n        }\n      }\n    } else if (!selectStart) {\n      // Handle moving selection to end for other nodes\n      if ($isTextNode(target)) {\n        target.select();\n      } else {\n        const element = target.getParentOrThrow();\n        const index = target.getIndexWithinParent() + 1;\n        element.select(index, index);\n      }\n    }\n    return true;\n  }\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   */\n\n  insertParagraph() {\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    let currentElement;\n    let nodesToMove = [];\n    let siblingsToMove = [];\n    if (anchor.type === 'text') {\n      const anchorNode = anchor.getNode();\n      nodesToMove = anchorNode.getNextSiblings().reverse();\n      currentElement = anchorNode.getParentOrThrow();\n      const isInline = currentElement.isInline();\n      const textContentLength = isInline ? currentElement.getTextContentSize() : anchorNode.getTextContentSize();\n      if (anchorOffset === 0) {\n        nodesToMove.push(anchorNode);\n      } else {\n        if (isInline) {\n          // For inline nodes, we want to move all the siblings to the new paragraph\n          // if selection is at the end, we just move the siblings. Otherwise, we also\n          // split the text node and add that and it's siblings below.\n          siblingsToMove = currentElement.getNextSiblings();\n        }\n        if (anchorOffset !== textContentLength) {\n          if (!isInline || anchorOffset !== anchorNode.getTextContentSize()) {\n            const [, splitNode] = anchorNode.splitText(anchorOffset);\n            nodesToMove.push(splitNode);\n          }\n        }\n      }\n    } else {\n      currentElement = anchor.getNode();\n      if ($isRootOrShadowRoot(currentElement)) {\n        const paragraph = $createParagraphNode();\n        const child = currentElement.getChildAtIndex(anchorOffset);\n        paragraph.select();\n        if (child !== null) {\n          child.insertBefore(paragraph, false);\n        } else {\n          currentElement.append(paragraph);\n        }\n        return;\n      }\n      nodesToMove = currentElement.getChildren().slice(anchorOffset).reverse();\n    }\n    const nodesToMoveLength = nodesToMove.length;\n    if (anchorOffset === 0 && nodesToMoveLength > 0 && currentElement.isInline()) {\n      const parent = currentElement.getParentOrThrow();\n      const newElement = parent.insertNewAfter(this, false);\n      if ($isElementNode(newElement)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          newElement.append(children[i]);\n        }\n      }\n      return;\n    }\n    const newElement = currentElement.insertNewAfter(this, false);\n    if (newElement === null) {\n      // Handle as a line break insertion\n      this.insertLineBreak();\n    } else if ($isElementNode(newElement)) {\n      // If we're at the beginning of the current element, move the new element to be before the current element\n      const currentElementFirstChild = currentElement.getFirstChild();\n      const isBeginning = anchorOffset === 0 && (currentElement.is(anchor.getNode()) || currentElementFirstChild && currentElementFirstChild.is(anchor.getNode()));\n      if (isBeginning && nodesToMoveLength > 0) {\n        currentElement.insertBefore(newElement);\n        return;\n      }\n      let firstChild = null;\n      const siblingsToMoveLength = siblingsToMove.length;\n      const parent = newElement.getParentOrThrow(); // For inline elements, we append the siblings to the parent.\n\n      if (siblingsToMoveLength > 0) {\n        for (let i = 0; i < siblingsToMoveLength; i++) {\n          const siblingToMove = siblingsToMove[i];\n          parent.append(siblingToMove);\n        }\n      }\n      if (nodesToMoveLength !== 0) {\n        for (let i = 0; i < nodesToMoveLength; i++) {\n          const nodeToMove = nodesToMove[i];\n          if (firstChild === null) {\n            newElement.append(nodeToMove);\n          } else {\n            firstChild.insertBefore(nodeToMove);\n          }\n          firstChild = nodeToMove;\n        }\n      }\n      if (!newElement.canBeEmpty() && newElement.getChildrenSize() === 0) {\n        newElement.selectPrevious();\n        newElement.remove();\n      } else {\n        newElement.selectStart();\n      }\n    }\n  }\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   *\n   * @param selectStart whether or not to select the start of the insertion range after the operation completes.\n   */\n\n  insertLineBreak(selectStart) {\n    const lineBreakNode = $createLineBreakNode();\n    const anchor = this.anchor;\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n      if ($isRootNode(element)) {\n        this.insertParagraph();\n      }\n    }\n    if (selectStart) {\n      this.insertNodes([lineBreakNode], true);\n    } else {\n      if (this.insertNodes([lineBreakNode])) {\n        lineBreakNode.selectNext(0, 0);\n      }\n    }\n  }\n  /**\n   * Returns the character-based offsets of the Selection, accounting for non-text Points\n   * by using the children size or text content.\n   *\n   * @returns the character offsets for the Selection\n   */\n\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move'; // Handle the selection movement around decorators.\n\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement; // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    } // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity); // Guard against no ranges\n\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0); // Apply the DOM selection to our Lexical selection.\n\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        } // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const focus = this.focus;\n      let anchorNode = anchor.getNode();\n      if (!isBackward && (\n      // Delete forward handle case\n      anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n        const parent = anchorNode.getParent();\n        const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n        if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n          return;\n        }\n      } // Handle the deletion around decorators.\n\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      if (this.anchor.type === 'text') {\n        this.modify('extend', isBackward, 'lineboundary');\n      } // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n\n      const endPoint = isBackward ? this.focus : this.anchor;\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n    }\n    this.removeText();\n  }\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction getCharacterOffsets(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode; // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false; // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length; // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === editor._blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (editor._blockCursorElement !== null) {\n      resolvedOffset--;\n    }\n    resolvedNode = getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = getNodeFromDOM(dom); // Ensure resolvedElement is actually a element.\n\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n            resolvedOffset = 0;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent(); // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize(); // @ts-expect-error: intentional\n\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0; // @ts-expect-error: intentional\n\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\nfunction normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus); // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\nfunction internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = getNodeFromDOM(anchorDOM);\n    const focusNode = getNodeFromDOM(focusDOM); // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  } // Handle normalization of selection when it is at the boundaries.\n\n  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n} // This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction DEPRECATED_$createGridSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new GridSelection('root', anchor, focus);\n}\nfunction internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n  if ($isNodeSelection(lastSelection) || DEPRECATED_$isGridSelection(lastSelection)) {\n    return lastSelection.clone();\n  }\n  return internalCreateRangeSelection(lastSelection, domSelection, editor);\n}\nfunction internalCreateRangeSelection(lastSelection, domSelection, editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  } // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcesssingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  } // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n\n  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key; // Single node. We shift selection but never redimension it\n\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element'); // The new selection might point to text nodes, try to resolve them\n\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  } // The new selection might point to text nodes, try to resolve them\n\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement; // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  } // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  } // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  } // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  } catch (error) {// If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n  }\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      let selectionRect;\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes, selectStart) {\n  let selection = $getSelection() || $getPreviousSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  return selection.insertNodes(nodes, selectStart);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\nfunction DEPRECATED_$computeGridMap(grid, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function write(startRow, startColumn, cell) {\n    const value = {\n      cell,\n      startColumn,\n      startRow\n    };\n    const rowSpan = cell.__rowSpan;\n    const colSpan = cell.__colSpan;\n    for (let i = 0; i < rowSpan; i++) {\n      if (tableMap[startRow + i] === undefined) {\n        tableMap[startRow + i] = [];\n      }\n      for (let j = 0; j < colSpan; j++) {\n        tableMap[startRow + i][startColumn + j] = value;\n      }\n    }\n    if (cellA.is(cell)) {\n      cellAValue = value;\n    }\n    if (cellB.is(cell)) {\n      cellBValue = value;\n    }\n  }\n  function isEmpty(row, column) {\n    return tableMap[row] === undefined || tableMap[row][column] === undefined;\n  }\n  const gridChildren = grid.getChildren();\n  for (let i = 0; i < gridChildren.length; i++) {\n    const row = gridChildren[i];\n    if (!DEPRECATED_$isGridRowNode(row)) {\n      throw Error(`Expected GridNode children to be GridRowNode`);\n    }\n    const rowChildren = row.getChildren();\n    let j = 0;\n    for (const cell of rowChildren) {\n      if (!DEPRECATED_$isGridCellNode(cell)) {\n        throw Error(`Expected GridRowNode children to be GridCellNode`);\n      }\n      while (!isEmpty(i, j)) {\n        j++;\n      }\n      write(i, j, cell);\n      j += cell.__colSpan;\n    }\n  }\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Grid`);\n  }\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Grid`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction DEPRECATED_$getNodeTriplet(source) {\n  let cell;\n  if (source instanceof DEPRECATED_GridCellNode) {\n    cell = source;\n  } else if (source instanceof LexicalNode) {\n    const cell_ = $findMatchingParent(source, DEPRECATED_$isGridCellNode);\n    if (!DEPRECATED_$isGridCellNode(cell_)) {\n      throw Error(`Expected to find a parent GridCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), DEPRECATED_$isGridCellNode);\n    if (!DEPRECATED_$isGridCellNode(cell_)) {\n      throw Error(`Expected to find a parent GridCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!DEPRECATED_$isGridRowNode(row)) {\n    throw Error(`Expected GridCellNode to have a parent GridRowNode`);\n  }\n  const grid = row.getParent();\n  if (!DEPRECATED_$isGridNode(grid)) {\n    throw Error(`Expected GridRowNode to have a parent GridNode`);\n  }\n  return [cell, row, grid];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n  return activeEditor;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\n\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size; // We want to prioritize node transforms over element transforms\n\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    } // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    } // Make the editorState immutable\n\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n} // This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  } // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false; // We don't want updates to sync block the reconciliation.\n\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      } // Reset editor and restore incoming editor state to the DOM\n\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState); // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window); // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  } // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false; // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      let tag;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n      nextUpdateFn();\n    }\n  }\n  return skipTransforms;\n}\nfunction beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection != null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = internalCreateSelection(editor);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    } // Restore existing editor state to the DOM\n\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\n\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n  }\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getFirstChild();\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n      break;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getLastChild();\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n      break;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length; // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n    return textContentSize;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  } // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    if ($isElementNode(firstNode) || $isTextNode(firstNode)) {\n      return firstNode.select(0, 0);\n    } // Decorator or LineBreak\n\n    if (firstNode !== null) {\n      return firstNode.selectPrevious();\n    }\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      return lastNode.select();\n    } // Decorator or LineBreak\n\n    if (lastNode !== null) {\n      return lastNode.selectNext();\n    }\n    return this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      } // Set child parent to self\n\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize; // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        } // Cleanup if node can't be empty\n\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  } // JSON serialization\n\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1\n    };\n  } // These are intended to be extends for specific element heuristics.\n\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  } // TODO 0.10 deprecate\n\n  canExtractContents() {\n    return true;\n  }\n  canReplaceWith(replacement) {\n    return true;\n  }\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  } // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n\n  isShadowRoot() {\n    return false;\n  }\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  } // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  } // Mutate\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n    return super.append(...nodesToAppend);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1\n    };\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection; // Check if we need to update because of changes in selection\n\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  const serializedChildren = serializedNode.children;\n  if ($isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  } // @ts-expect-error\n\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  } // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) element.append(document.createElement('br'));\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'paragraph',\n      version: 1\n    };\n  } // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newElement = $createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren(); // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  } // Remove all the DOM nodes from the root element\n\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM != null ? node.klass.importDOM.bind(node.klass) : null;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM();\n    if (map !== null) {\n      Object.keys(map).forEach(key => {\n        let currentCache = conversionCache.get(key);\n        if (currentCache === undefined) {\n          currentCache = [];\n          conversionCache.set(key, currentCache);\n        }\n        currentCache.push(map[key]);\n      });\n    }\n  });\n  return conversionCache;\n}\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\n\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ...(config.nodes || [])];\n  const onError = config.onError;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replacementClass = null;\n      let replacementKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replacementClass = options.with;\n        replacementKlass = options.withKlass ? options.withKlass : null;\n      } // Ensure custom nodes implement required methods.\n\n      {\n        const name = klass.name;\n        if (name !== 'RootNode') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') &&\n          // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !proto.hasOwnProperty('exportJSON')) {\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n      registeredNodes.set(type, {\n        klass,\n        replace: replacementClass,\n        replaceWithKlass: replacementKlass,\n        transforms\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes), isEditable);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor; // The root element associated with this editor\n\n    this._rootElement = null; // The current editor state\n\n    this._editorState = editorState; // Handling of drafts and updates\n\n    this._pendingEditorState = null; // Used to help co-ordinate selection and events\n\n    this._compositionKey = null;\n    this._deferred = []; // Used during reconciliation\n\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false; // Listeners\n\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    }; // Commands\n\n    this._commands = new Map(); // Editor configuration for theme/context.\n\n    this._config = config; // Mapping of types to their nodes\n\n    this._nodes = nodes; // React node decorators for portals\n\n    this._decorators = {};\n    this._pendingDecorators = null; // Used to optimize reconciliation\n\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set(); // Handling of DOM mutations\n\n    this._observer = null; // Used for identifying owning editors\n\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched, subject to priority. Listeners that run at a higher priority can \"intercept\"\n   * commands and prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners registered at the same priority level will run deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n  registerMutationListener(klass, listener) {\n    const registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klass);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n  /** @internal */\n\n  registerNodeTransformToKlass(klass, listener) {\n    const type = klass.getType();\n    const registeredNode = this._nodes.get(type);\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    return registeredNode;\n  }\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload.\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n\n  getDecorators() {\n    return this._decorators;\n  }\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n\n  getRootElement() {\n    return this._rootElement;\n  }\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n\n  getKey() {\n    return this._key;\n  }\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add('history-merge');\n        commitPendingUpdates(this); // TODO: remove this flag once we no longer use UEv2 internally\n\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        // If content editable is unmounted we'll reset editor state back to original\n        // (or pending) editor state since there will be no reconciliation\n        this._editorState = pendingEditorState;\n        this._pendingEditorState = null;\n        this._window = null;\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n\n  getEditorState() {\n    return this._editorState;\n  }\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      commitPendingUpdates(this);\n    }\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n    commitPendingUpdates(this);\n  }\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserliazation from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        },\n        tag: 'focus'\n      }); // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n  /**\n   * Removes focus from the editor.\n   */\n\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass DEPRECATED_GridCellNode extends ElementNode {\n  /** @internal */\n  constructor(colSpan, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colSpan: this.__colSpan,\n      rowSpan: this.__rowSpan\n    };\n  }\n  getColSpan() {\n    return this.__colSpan;\n  }\n  setColSpan(colSpan) {\n    this.getWritable().__colSpan = colSpan;\n    return this;\n  }\n  getRowSpan() {\n    return this.__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    this.getWritable().__rowSpan = rowSpan;\n    return this;\n  }\n}\nfunction DEPRECATED_$isGridCellNode(node) {\n  return node instanceof DEPRECATED_GridCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridNode extends ElementNode {}\nfunction DEPRECATED_$isGridNode(node) {\n  return node instanceof DEPRECATED_GridNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridRowNode extends ElementNode {}\nfunction DEPRECATED_$isGridRowNode(node) {\n  return node instanceof DEPRECATED_GridRowNode;\n}\nexports.$addUpdateTag = $addUpdateTag;\nexports.$applyNodeReplacement = $applyNodeReplacement;\nexports.$copyNode = $copyNode;\nexports.$createLineBreakNode = $createLineBreakNode;\nexports.$createNodeSelection = $createNodeSelection;\nexports.$createParagraphNode = $createParagraphNode;\nexports.$createRangeSelection = $createRangeSelection;\nexports.$createTabNode = $createTabNode;\nexports.$createTextNode = $createTextNode;\nexports.$getAdjacentNode = $getAdjacentNode;\nexports.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;\nexports.$getNearestRootOrShadowRoot = $getNearestRootOrShadowRoot;\nexports.$getNodeByKey = $getNodeByKey;\nexports.$getPreviousSelection = $getPreviousSelection;\nexports.$getRoot = $getRoot;\nexports.$getSelection = $getSelection;\nexports.$getTextContent = $getTextContent;\nexports.$hasAncestor = $hasAncestor;\nexports.$hasUpdateTag = $hasUpdateTag;\nexports.$insertNodes = $insertNodes;\nexports.$isBlockElementNode = $isBlockElementNode;\nexports.$isDecoratorNode = $isDecoratorNode;\nexports.$isElementNode = $isElementNode;\nexports.$isInlineElementOrDecoratorNode = $isInlineElementOrDecoratorNode;\nexports.$isLeafNode = $isLeafNode;\nexports.$isLineBreakNode = $isLineBreakNode;\nexports.$isNodeSelection = $isNodeSelection;\nexports.$isParagraphNode = $isParagraphNode;\nexports.$isRangeSelection = $isRangeSelection;\nexports.$isRootNode = $isRootNode;\nexports.$isRootOrShadowRoot = $isRootOrShadowRoot;\nexports.$isTabNode = $isTabNode;\nexports.$isTextNode = $isTextNode;\nexports.$nodesOfType = $nodesOfType;\nexports.$normalizeSelection__EXPERIMENTAL = $normalizeSelection;\nexports.$parseSerializedNode = $parseSerializedNode;\nexports.$selectAll = $selectAll;\nexports.$setCompositionKey = $setCompositionKey;\nexports.$setSelection = $setSelection;\nexports.$splitNode = $splitNode;\nexports.BLUR_COMMAND = BLUR_COMMAND;\nexports.CAN_REDO_COMMAND = CAN_REDO_COMMAND;\nexports.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;\nexports.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;\nexports.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;\nexports.CLICK_COMMAND = CLICK_COMMAND;\nexports.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL;\nexports.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;\nexports.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;\nexports.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW;\nexports.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;\nexports.CONTROLLED_TEXT_INSERTION_COMMAND = CONTROLLED_TEXT_INSERTION_COMMAND;\nexports.COPY_COMMAND = COPY_COMMAND;\nexports.CUT_COMMAND = CUT_COMMAND;\nexports.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;\nexports.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;\nexports.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;\nexports.DEPRECATED_$computeGridMap = DEPRECATED_$computeGridMap;\nexports.DEPRECATED_$createGridSelection = DEPRECATED_$createGridSelection;\nexports.DEPRECATED_$getGridCellNodeRect = DEPRECATED_$getGridCellNodeRect;\nexports.DEPRECATED_$getNodeTriplet = DEPRECATED_$getNodeTriplet;\nexports.DEPRECATED_$isGridCellNode = DEPRECATED_$isGridCellNode;\nexports.DEPRECATED_$isGridNode = DEPRECATED_$isGridNode;\nexports.DEPRECATED_$isGridRowNode = DEPRECATED_$isGridRowNode;\nexports.DEPRECATED_$isGridSelection = DEPRECATED_$isGridSelection;\nexports.DEPRECATED_GridCellNode = DEPRECATED_GridCellNode;\nexports.DEPRECATED_GridNode = DEPRECATED_GridNode;\nexports.DEPRECATED_GridRowNode = DEPRECATED_GridRowNode;\nexports.DRAGEND_COMMAND = DRAGEND_COMMAND;\nexports.DRAGOVER_COMMAND = DRAGOVER_COMMAND;\nexports.DRAGSTART_COMMAND = DRAGSTART_COMMAND;\nexports.DROP_COMMAND = DROP_COMMAND;\nexports.DecoratorNode = DecoratorNode;\nexports.ElementNode = ElementNode;\nexports.FOCUS_COMMAND = FOCUS_COMMAND;\nexports.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;\nexports.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND;\nexports.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;\nexports.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;\nexports.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND;\nexports.INSERT_TAB_COMMAND = INSERT_TAB_COMMAND;\nexports.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;\nexports.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;\nexports.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;\nexports.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;\nexports.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;\nexports.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;\nexports.KEY_DOWN_COMMAND = KEY_DOWN_COMMAND;\nexports.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;\nexports.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;\nexports.KEY_MODIFIER_COMMAND = KEY_MODIFIER_COMMAND;\nexports.KEY_SPACE_COMMAND = KEY_SPACE_COMMAND;\nexports.KEY_TAB_COMMAND = KEY_TAB_COMMAND;\nexports.LineBreakNode = LineBreakNode;\nexports.MOVE_TO_END = MOVE_TO_END;\nexports.MOVE_TO_START = MOVE_TO_START;\nexports.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;\nexports.PASTE_COMMAND = PASTE_COMMAND;\nexports.ParagraphNode = ParagraphNode;\nexports.REDO_COMMAND = REDO_COMMAND;\nexports.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;\nexports.RootNode = RootNode;\nexports.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND;\nexports.SELECT_ALL_COMMAND = SELECT_ALL_COMMAND;\nexports.TabNode = TabNode;\nexports.TextNode = TextNode;\nexports.UNDO_COMMAND = UNDO_COMMAND;\nexports.createCommand = createCommand;\nexports.createEditor = createEditor;\nexports.getNearestEditorFromDOMNode = getNearestEditorFromDOMNode;\nexports.isHTMLAnchorElement = isHTMLAnchorElement;\nexports.isHTMLElement = isHTMLElement;\nexports.isSelectionCapturedInDecoratorInput = isSelectionCapturedInDecoratorInput;\nexports.isSelectionWithinEditor = isSelectionWithinEditor;","map":{"version":3,"names":["createCommand","type","SELECTION_CHANGE_COMMAND","CLICK_COMMAND","DELETE_CHARACTER_COMMAND","INSERT_LINE_BREAK_COMMAND","INSERT_PARAGRAPH_COMMAND","CONTROLLED_TEXT_INSERTION_COMMAND","PASTE_COMMAND","REMOVE_TEXT_COMMAND","DELETE_WORD_COMMAND","DELETE_LINE_COMMAND","FORMAT_TEXT_COMMAND","UNDO_COMMAND","REDO_COMMAND","KEY_DOWN_COMMAND","KEY_ARROW_RIGHT_COMMAND","MOVE_TO_END","KEY_ARROW_LEFT_COMMAND","MOVE_TO_START","KEY_ARROW_UP_COMMAND","KEY_ARROW_DOWN_COMMAND","KEY_ENTER_COMMAND","KEY_SPACE_COMMAND","KEY_BACKSPACE_COMMAND","KEY_ESCAPE_COMMAND","KEY_DELETE_COMMAND","KEY_TAB_COMMAND","INSERT_TAB_COMMAND","INDENT_CONTENT_COMMAND","OUTDENT_CONTENT_COMMAND","DROP_COMMAND","FORMAT_ELEMENT_COMMAND","DRAGSTART_COMMAND","DRAGOVER_COMMAND","DRAGEND_COMMAND","COPY_COMMAND","CUT_COMMAND","SELECT_ALL_COMMAND","CLEAR_EDITOR_COMMAND","CLEAR_HISTORY_COMMAND","CAN_REDO_COMMAND","CAN_UNDO_COMMAND","FOCUS_COMMAND","BLUR_COMMAND","KEY_MODIFIER_COMMAND","CAN_USE_DOM","window","document","createElement","documentMode","IS_APPLE","test","navigator","platform","IS_FIREFOX","userAgent","CAN_USE_BEFORE_INPUT","InputEvent","IS_SAFARI","IS_IOS","MSStream","IS_CHROME","IS_APPLE_WEBKIT","DOM_ELEMENT_TYPE","DOM_TEXT_TYPE","NO_DIRTY_NODES","HAS_DIRTY_NODES","FULL_RECONCILE","IS_NORMAL","IS_TOKEN","IS_SEGMENTED","IS_BOLD","IS_ITALIC","IS_STRIKETHROUGH","IS_UNDERLINE","IS_CODE","IS_SUBSCRIPT","IS_SUPERSCRIPT","IS_HIGHLIGHT","IS_ALL_FORMATTING","IS_DIRECTIONLESS","IS_UNMERGEABLE","IS_ALIGN_LEFT","IS_ALIGN_CENTER","IS_ALIGN_RIGHT","IS_ALIGN_JUSTIFY","IS_ALIGN_START","IS_ALIGN_END","NON_BREAKING_SPACE","ZERO_WIDTH_SPACE","COMPOSITION_SUFFIX","DOUBLE_LINE_BREAK","COMPOSITION_START_CHAR","RTL","LTR","RTL_REGEX","RegExp","LTR_REGEX","TEXT_TYPE_TO_FORMAT","bold","code","highlight","italic","strikethrough","subscript","superscript","underline","DETAIL_TYPE_TO_DETAIL","directionless","unmergeable","ELEMENT_TYPE_TO_FORMAT","center","end","justify","left","right","start","ELEMENT_FORMAT_TO_TYPE","TEXT_MODE_TO_TYPE","normal","segmented","token","TEXT_TYPE_TO_MODE","TEXT_MUTATION_VARIANCE","isProcessingMutations","lastTextEntryTimeStamp","getIsProcesssingMutations","updateTimeStamp","event","timeStamp","initTextEntryListener","editor","getWindow","addEventListener","isManagedLineBreak","dom","target","__lexicalLineBreak","_key","undefined","getLastSelection","getEditorState","read","selection","$getSelection","clone","handleTextMutation","node","domSelection","getDOMSelection","_window","anchorOffset","focusOffset","anchorNode","text","nodeValue","$updateTextNodeFromDOMContent","shouldUpdateTextNodeFromMutation","targetDOM","targetNode","$isRangeSelection","anchor","getNode","is","format","getFormat","nodeType","isAttached","$flushMutations$1","mutations","observer","shouldFlushTextMutations","performance","now","updateEditor","badDOMTargets","Map","rootElement","getRootElement","currentEditorState","_editorState","blockCursorElement","_blockCursorElement","shouldRevertSelection","possibleTextForFirefoxPaste","i","length","mutation","$getNearestNodeFromDOMNode","$isDecoratorNode","$isTextNode","addedDOMs","addedNodes","s","addedDOM","getNodeFromDOMNode","parentDOM","parentNode","nodeName","possibleText","innerText","removeChild","removedDOMs","removedNodes","removedDOMsLength","unremovedBRs","removedDOM","appendChild","internalGetRoot","set","size","$isElementNode","childKeys","getChildrenKeys","currentDOM","firstChild","key","correctDOM","getElementByKey","replaceChild","nextSibling","markDirty","records","takeRecords","record","dirty","$setSelection","isFirefoxClipboardEvents","insertRawText","flushRootMutations","_observer","initMutationObserver","MutationObserver","$canSimpleTextNodesBeMerged","node1","node2","node1Mode","__mode","node1Format","__format","node1Style","__style","node2Mode","node2Format","node2Style","$mergeTextNodes","writableNode1","mergeWithSibling","normalizedNodes","getActiveEditor","_normalizedNodes","add","__key","$normalizeTextNode","textNode","__text","isSimpleText","isUnmergeable","remove","previousNode","getPreviousSibling","nextNode","getNextSibling","$normalizeSelection","$normalizePoint","focus","point","offset","nextOffsetAtEnd","getChildrenSize","getChildAtIndex","getTextContentSize","keyCounter","generateRandomKey","getRegisteredNodeOrThrow","registeredNode","_nodes","get","Error","scheduleMicroTask","queueMicrotask","fn","Promise","resolve","then","$isSelectionCapturedInDecorator","isSelectionCapturedInDecoratorInput","anchorDOM","activeElement","contentEditable","__lexicalEditor","isSelectionWithinEditor","focusDOM","contains","getNearestEditorFromDOMNode","error","currentNode","getParentElement","getTextDirection","$isTokenOrSegmented","isToken","isSegmented","isDOMNodeLexicalTextNode","getDOMTextNode","element","toggleTextFormatType","alignWithFormat","activeFormat","isStateFlagPresent","$isLeafNode","$isLineBreakNode","$setNodeKey","existingKey","errorOnReadOnly","errorOnInfiniteTransforms","editorState","getActiveEditorState","_nodeMap","_dirtyElements","_dirtyLeaves","_cloneNotNeeded","_dirtyType","internalMarkParentElementsAsDirty","parentKey","nodeMap","dirtyElements","nextParentKey","has","__parent","removeFromParent","oldParent","getParent","writableNode","getWritable","writableParent","prevSibling","writableNextSibling","__first","__prev","writablePrevSibling","__next","__last","__size","internalMarkNodeAsDirty","latest","getLatest","parent","internalMarkSiblingsAsDirty","$setCompositionKey","compositionKey","previousCompositionKey","_compositionKey","$getNodeByKey","$getCompositionKey","isCurrentlyReadOnlyMode","startingDOM","cloneDecorators","currentDecorators","_decorators","pendingDecorators","Object","assign","_pendingDecorators","getEditorStateTextContent","$getRoot","getTextContent","markAllNodesAsDirty","isEmpty","_pendingEditorState","tag","isFrozen","_cachedNodes","_selection","$flushMutations","getNodeFromDOM","nodeKey","getNodeKeyFromDOM","getTextNodeOffset","moveSelectionToEnd","doesContainGrapheme","str","getEditorsToPropagate","editorsToPropagate","currentEditor","push","_parentEditor","createUID","Math","random","toString","replace","substr","getAnchorTextFromDOM","$updateSelectedTextFromDOM","isCompositionEnd","data","textContent","compositionEnd","isDirty","isComposing","normalizedTextContent","slice","prevTextContent","setTimeout","update","prevSelection","$getPreviousSelection","prevTextContentSize","getKey","canInsertTextBefore","canInsertTextAfter","setTextContent","setTextNodeRange","originalTextContent","replacement","$createTextNode","$previousSiblingDoesNotAcceptText","previousSibling","isInline","$shouldInsertTextAfterOrBeforeTextNode","isCollapsed","getParentOrThrow","isTab","keyCode","altKey","ctrlKey","metaKey","isBold","controlOrMeta","isItalic","isUnderline","isParagraph","shiftKey","isReturn","isLineBreak","isOpenLineBreak","isDeleteWordBackward","isBackspace","isDeleteWordForward","isDelete","isDeleteLineBackward","isDeleteLineForward","isDeleteBackward","isDeleteForward","isUndo","isRedo","isCopy","isCut","isArrowLeft","isArrowRight","isArrowUp","isArrowDown","isMoveBackward","isMoveToStart","isMoveForward","isMoveToEnd","isMoveUp","isMoveDown","isModifier","isSpace","isEscape","isSelectAll","$selectAll","root","select","getCachedClassNameArray","classNamesTheme","classNameThemeType","__lexicalClassNameCache","classNamesCache","cachedClassNames","classNames","classNamesArr","split","setMutatedNode","mutatedNodes","registeredNodes","mutationListeners","__type","klass","mutatedNodesByType","prevMutation","isMove","$nodesOfType","readOnly","_readOnly","klassType","getType","nodes","nodesOfType","resolveElement","isBackward","block","getIndexWithinParent","$getAdjacentNode","focusNode","possibleNode","inputType","dispatchCommand","command","payload","triggerCommandListeners","$textContentRequiresDoubleLinebreakAtEnd","$isRootNode","isLastChild","getElementByKeyOrThrow","_keyToDOMMap","parentElement","assignedSlot","host","scrollIntoViewIfNeeded","selectionRect","doc","ownerDocument","defaultView","top","currentTop","bottom","currentBottom","targetTop","targetBottom","isBodyElement","body","innerHeight","targetRect","getBoundingClientRect","diff","scrollBy","scrollTop","yOffset","$hasUpdateTag","_updateTags","$addUpdateTag","$maybeMoveChildrenSelectionToParent","$hasAncestor","child","getDefaultView","domElem","ownerDoc","windowObj","$isInlineElementOrDecoratorNode","$getNearestRootOrShadowRoot","$isRootOrShadowRoot","isShadowRoot","$copyNode","copy","constructor","$applyNodeReplacement","replaceFunc","replacementNode","errorOnInsertTextNodeOnRoot","insertNode","createBlockCursorElement","editorConfig","theme","setAttribute","blockCursorTheme","blockCursor","classList","needsBlockCursor","canBeEmpty","removeDOMBlockCursorElement","style","removeProperty","updateDOMBlockCursorElement","nextSelection","elementNode","elementNodeSize","isBlockCursor","insertBeforeElement","sibling","elementDOM","_config","caretColor","insertBefore","targetWindow","getSelection","$splitNode","startNode","recurse","isParentRoot","nodeToMove","insertAfter","leftTree","rightTree","newParent","nextSiblings","getNextSiblings","append","$findMatchingParent","startingNode","findFn","curr","$getChildrenRecursively","stack","pop","unshift","getChildren","isHTMLAnchorElement","x","isHTMLElement","tagName","$garbageCollectDetachedDecorators","pendingEditorState","decorators","$garbageCollectDetachedDeepChildNodes","prevNodeMap","nodeMapDelete","dirtyNodes","getFirstChild","childKey","delete","$garbageCollectDetachedNodes","prevEditorState","dirtyLeaves","subTreeTextContent","subTreeDirectionedTextContent","editorTextContent","activeEditorConfig","activeEditor$1","activeEditorNodes","treatAllNodesAsDirty","activeEditorStateReadOnly","activeMutationListeners","activeTextDirection","activeDirtyElements","activeDirtyLeaves","activePrevNodeMap","activeNextNodeMap","activePrevKeyToDOMMap","destroyNode","getPrevElementByKeyOrThrow","children","createChildrenArray","destroyChildren","_startIndex","endIndex","startIndex","setTextAlign","domStyle","value","setProperty","DEFAULT_INDENT_VALUE","setElementIndent","indent","indentClassName","elementHasClassName","indentationBaseValue","getComputedStyle","getPropertyValue","setElementFormat","createNode","insertDOM","createDOM","storeDOMWithKey","__indent","childrenSize","createChildrenWithDirection","reconcileElementTerminatingLineBreak","decorator","decorate","reconcileDecorator","isDirectionless","possibleLineBreak","freeze","previousSubTreeDirectionedTextContent","createChildren","reconcileBlockDirection","previousSubTreeTextContent","__lexicalTextContent","isLastChildLineBreakOrDecorator","prevElement","nextElement","prevLineBreak","nextLineBreak","previousSubTreeDirectionTextContent","__lexicalDirTextContent","previousDirection","__lexicalDir","hasEmptyDirectionedTextContent","direction","previousDirectionTheme","nextDirectionTheme","removeAttribute","dir","__dir","reconcileChildrenWithDirection","reconcileChildren","prevChildrenSize","nextChildrenSize","prevFirstChildKey","nextFrstChildKey","reconcileNode","lastDOM","replacementDOM","prevChildren","nextChildren","lexicalLineBreak","canUseFastPath","reconcileNodeChildren","prevNode","updateDOM","nextIndent","nextFormat","__cachedText","prevChildrenLength","nextChildrenLength","prevEndIndex","nextEndIndex","prevChildrenSet","nextChildrenSet","siblingDOM","prevIndex","nextIndex","prevKey","nextKey","Set","nextHasPrevKey","prevHasNextKey","childDOM","appendNewChildren","removeOldChildren","reconcileRoot","nextEditorState","dirtyType","_listeners","currentMutatedNodes","keyToDOMMap","PASS_THROUGH_COMMAND","ANDROID_COMPOSITION_LATENCY","rootElementEvents","onKeyDown","onPointerDown","onCompositionStart","onCompositionEnd","onInput","onClick","onBeforeInput","lastKeyDownTimeStamp","lastKeyCode","lastBeforeInputInsertTextTimeStamp","unprocessedBeforeInputData","rootElementsRegistered","isSelectionChangeFromDOMUpdate","isSelectionChangeFromMouseDown","isInsertLineBreak","isFirefoxEndingComposition","collapsedSelectionFormat","$shouldPreventDefaultAndInsertText","domTargetRange","isBeforeInput","domAnchorNode","anchorKey","backingAnchorElement","textLength","collapsed","startContainer","startOffset","getStyle","shouldSkipSelectionChange","domNode","onSelectionChange","isActive","windowEvent","currentTimeStamp","lastFormat","lastStyle","lastOffset","lastKey","combinedFormat","hasTextNodes","getNodes","nodesLength","lastSelection","getTopLevelElementOrThrow","removeAllRanges","detail","pointerType","newSelection","internalCreateRangeSelection","Node","getTargetRange","getTargetRanges","targetRanges","$canRemoveText","isPossiblyAndroidKeyPress","targetRange","preventDefault","applyDOMRange","dataTransfer","getData","stopPropagation","onCompositionEndImpl","characterData","$isNodeSelection","getRootElementRemoveHandles","eventHandles","__lexicalEventHandles","activeNestedEditorsMap","onDocumentSelectionChange","nextActiveEditor","editors","rootEditor","rootEditorKey","activeNestedEditor","prevActiveEditor","stopLexicalPropagation","_lexicalHandled","hasStoppedLexicalPropagation","stopped","addRootElementEvents","removeHandles","eventName","onEvent","eventHandler","isEditable","removeEventListener","removeRootElementEvents","cleanActiveNestedEditorsMap","markSelectionChangeFromDOMUpdate","markCollapsedSelectionFormat","removeNode","nodeToRemove","restoreSelection","preserveEmptyParent","selectionMoved","moveSelectionPointToSibling","isSelected","selectPrevious","index","$updateElementSelectionOnCreateDeleteNode","selectEnd","LexicalNode","name","_data","errorOnTypeKlassMismatch","targetSelection","some","n","getTopLevelElement","getParents","parents","getParentKeys","self","getPreviousSiblings","siblings","getCommonAncestor","a","b","aLength","bLength","bSet","ancestor","object","isBefore","isParentOf","commonAncestor","indexA","indexB","getNodesBetween","visited","getLastChild","parentSibling","reverse","latestNode","cloneNotNeeded","mutableNode","__detail","_editor","_prevNode","_dom","exportDOM","exportJSON","importJSON","_serializedNode","transform","replaceWith","includeChildren","toReplaceKey","writableReplaceWith","forEach","$moveSelectionPointToEnd","nodeToInsert","writableSelf","writableNodeToInsert","elementAnchorSelectionOnNode","elementFocusSelectionOnNode","oldIndex","oldParentKey","insertKey","writableParentKey","isParentRequired","createParentElementNode","$createParagraphNode","selectNext","editorKlass","LineBreakNode","importDOM","br","lastChild","match","conversion","convertLineBreakElement","priority","serializedLineBreakNode","$createLineBreakNode","version","getElementOuterTag","getElementInnerTag","setTextThemeClassNames","prevFormat","textClassNames","domClassList","hasUnderlineStrikethrough","prevUnderlineStrikethrough","nextUnderlineStrikethrough","flag","diffComposedText","nextText","suffix","insert","deleteData","insertData","createTextInnerDOM","innerDOM","innerTag","config","wrapElementWith","el","TextNode","getDetail","getMode","hasFormat","formatFlag","getFormatFlags","outerTag","cssText","prevOuterTag","nextOuterTag","prevInnerTag","nextInnerTag","prevTag","nextTag","prevInnerDOM","nextInnerDOM","prevStyle","nextStyle","#text","convertTextDOMNode","convertBringAttentionToElement","convertTextFormatElement","em","span","convertSpanElement","strong","sub","sup","u","serializedNode","setFormat","setDetail","setMode","mode","setStyle","whiteSpace","selectionTransform","toggleFormat","toggleDirectionless","toggleUnmergeable","_anchorOffset","_focusOffset","internalMakeRangeSelection","spliceText","delCount","newText","moveSelection","handledTextLength","newOffset","updatedText","splitText","splitOffsets","offsetsSet","parts","string","partsLength","firstPart","hasReplacedSelf","splitNodes","textSize","part","partSize","siblingKey","nextTextSize","insertionIndex","splice","targetKey","adjustPointOffsetForMergedSibling","targetText","isTextEntity","hasBoldFontWeight","fontWeight","hasLinethroughTextDecoration","textDecoration","hasItalicFontStyle","fontStyle","hasUnderlineTextDecoration","verticalAlign","forChild","lexicalNode","hasNormalFontWeight","preParentCache","WeakMap","isNodePre","startsWith","findParentPreDOMNode","cached","resultNode","domNode_","parentDom","$createTabNode","previousText","isStartOfLine","findTextInLine","previousTextContent","isEndOfLine","nextTextContent","inlineParents","forward","display","descendant","nodeNameToTextFormat","toLowerCase","TabNode","newNode","serializedTabNode","_text","_detail","_type","$isTabNode","Point","aNode","bNode","aOffset","bOffset","aNodeDescendant","getDescendantByIndex","bNodeDescendant","oldKey","$createPoint","selectPointOnNode","textContentLength","lastNode","getLastDescendant","$transferStartingElementPointToTextPoint","placementNode","$setPointValues","NodeSelection","objects","Array","from","every","clear","extract","insertText","insertNodes","selectStart","selectedNodes","selectedNodesLength","lastSelectedNode","selectionAtEnd","cachedNodes","RangeSelection","DEPRECATED_$getGridCellNodeRect","GridCellNode","CellNode","GridNode","DEPRECATED_$getNodeTriplet","rows","rowCount","columnCount","cellMatrix","rowIndex","row","cells","columnIndex","cellIndex","cell","rowSpan","__rowSpan","colSpan","__colSpan","j","GridSelection","gridKey","DEPRECATED_$isGridSelection","anchorCellKey","focusCellKey","getCharacterOffsets","getShape","anchorCellNode","DEPRECATED_$isGridCellNode","anchorCellNodeRect","focusCellNode","focusCellNodeRect","startX","min","stopX","max","startY","stopY","fromX","fromY","toX","toY","anchorCell","focusCell","anchorRow","DEPRECATED_$isGridRowNode","gridNode","DEPRECATED_$isGridNode","map","cellAMap","cellBMap","DEPRECATED_$computeGridMap","minColumn","startColumn","minRow","startRow","maxColumn","maxRow","exploredMinColumn","exploredMinRow","exploredMaxColumn","exploredMaxRow","expandBoundary","mapValue","cellStartColumn","cellStartRow","rowDiff","previousColumn","columnDiff","previousRow","nextColumn","nextRow","lastRow","currentRow","firstPoint","lastPoint","firstNode","endOffset","firstNodeDescendant","lastNodeDescendant","prevWasElement","range","resolvedSelectionPoints","internalResolveSelectionPoints","endContainer","anchorPoint","focusPoint","endPoint","firstNodeText","firstNodeTextLength","firstNodeParent","lastIndex","lastNodeParent","normalizeSelectionPointsForBoundaries","firstNodeFormat","firstNodeStyle","markedNodeKeysForKeep","firstElement","lastElement","lastElementChild","lastNodeChildren","selectedNodesSet","firstAndLastElementsAreEqual","insertionTarget","lastNodeChild","lastRemovedParent","childrenLength","selectedNode","removeText","formatText","formatType","selectedTextNodes","selectedTextNodesLength","startPoint","firstIndex","firstNextFormat","lastNextFormat","selectionEnd","nextSiblingKey","prevSiblingKey","topLevelElement","danglingText","didReplaceOrMerge","canReplaceWith","firstDescendant","getFirstDescendant","splitNode","splitOffset","nextTarget","originalTarget","prevParent","$isBlockElementNode","isIsolated","canInsertAfter","prevParentClone","insertParagraph","currentElement","nodesToMove","siblingsToMove","paragraph","nodesToMoveLength","newElement","insertNewAfter","insertLineBreak","currentElementFirstChild","isBeginning","siblingsToMoveLength","siblingToMove","lineBreakNode","shift","lastNodeText","lastNodeTextLength","modify","alter","granularity","collapse","isKeyboardSelectable","nodeSelection","$createNodeSelection","elementKey","_rootElement","moveNativeSelection","rangeCount","getRangeAt","validNodes","shrinkSelection","firstValidNode","lastValidNode","$swapPoints","deleteCharacter","wasCollapsed","textContentSize","$removeSegment","$updateCaretSelectionForUnicodeCharacter","collapseAtStart","deleteLine","deleteWord","getCharacterOffset","anchorType","characterOffset","splitLength","segmentOffset","restoreOffset","isLast","join","trim","shouldResolveAncestor","resolvedElement","resolvedOffset","internalResolveSelectionPoint","resolvedNode","childNodes","childNodesLength","hasBlockCursor","resolveSelectionPointOnBoundary","lastAnchor","lastFocus","resolvedAnchorPoint","resolvedFocusPoint","focusKey","focusType","$createRangeSelection","DEPRECATED_$createGridSelection","internalCreateSelection","eventType","isSelectionChange","useDOMSelection","nodeOffset","times","selectionOffset","newSelectionOffset","$updateSelectionResolveTextNodes","firstPointNode","lastPointNode","firstPointOffset","lastPointOffset","childSize","anchorOffsetAtEnd","focusOffsetAtEnd","applySelectionTransforms","updateDOMSelection","tags","nodeCount","anchorDOMNode","focusDOMNode","nextAnchorOffset","nextFocusOffset","nextAnchorNode","nextFocusNode","anchorFormatOrStyleChanged","preventScroll","setBaseAndExtent","selectionTarget","Text","createRange","selectNode","$insertNodes","$getTextContent","grid","cellA","cellB","tableMap","cellAValue","cellBValue","write","column","gridChildren","rowChildren","source","DEPRECATED_GridCellNode","cell_","activeEditorState","activeEditor","isReadOnlyMode","isAttemptingToRecoverFromReconcilerError","infiniteTransformCount","observerOptions","childList","subtree","internalGetActiveEditor","$applyTransforms","transformsCache","transformsArr","transforms","transformsArrLength","$isNodeValidForTransform","$normalizeAllDirtyTextNodes","$applyAllTransforms","untransformedDirtyLeaves","untransformedDirtyLeavesLength","untransformedDirtyElements","untransformedDirtyElementsLength","currentUntransformedDirtyElement","intentionallyMarkedAsDirty","$parseSerializedNode","internalSerializedNode","$parseSerializedNodeImpl","nodeClass","isArray","serializedJSONChildNode","childNode","parseEditorState","serializedEditorState","updateFn","createEmptyEditorState","previousActiveEditorState","previousReadOnlyMode","previousActiveEditor","previousDirtyElements","previousDirtyLeaves","previousCloneNotNeeded","previousDirtyType","handleDEVOnlyPendingUpdateGuarantees","_onError","readEditorState","callbackFn","commitPendingUpdates","recoveryEditorState","shouldSkipDOM","_headless","currentSelection","pendingSelection","needsUpdate","previouslyUpdating","_updating","disconnect","resetEditor","observe","deferred","_deferred","_editable","triggerMutationListeners","triggerListeners","triggerTextContentListeners","triggerDeferredUpdateCallbacks","triggerEnqueuedUpdates","currentTextContent","latestTextContent","updateTags","listeners","listenersLength","listener","isCurrentlyEnqueuingUpdates","apply","returnVal","e","commandListeners","_commands","listenerInPriorityOrder","listenersSet","queuedUpdates","_updates","queuedUpdate","options","beginUpdate","processNestedUpdates","initialSkipTransforms","skipTransforms","nextUpdateFn","onUpdate","discrete","editorStateWasCloned","cloneEditorState","_flushSync","startingCompositionKey","endingCompositionKey","pendingNodeMap","shouldUpdate","editorStateHasDirtySelection","DecoratorNode","ElementNode","getFormatType","getIndent","parentLastChild","getAllTextNodes","textNodes","subChildrenNodes","firstKey","getFirstChildOrThrow","getLastChildOrThrow","getDirection","childrenCount","nodesToAppend","setDirection","setIndent","indentLevel","deleteCount","nodesToInsert","nodesToInsertLength","oldSize","writableSelfKey","nodesToInsertKeys","nodesToRemoveKeys","nodeAfterRange","nodeBeforeRange","newSize","nodeToDelete","nodeKeyToDelete","writableNodeToDelete","nodeKeyToInsert","writablePrevNode","writableNodeAfterRange","nodesToRemoveKeySet","nodesToInsertKeySet","isPointRemoved","canIndent","excludeFromCopy","destination","canExtractContents","canMergeWith","extractWithChild","RootNode","cachedText","$createRootNode","current","EditorState","exportNodeToJSON","serializedChildren","serializedChildNode","toJSON","ParagraphNode","p","convertParagraphElement","textAlign","textIndent","_","parseInt","$isParagraphNode","COMMAND_PRIORITY_EDITOR","COMMAND_PRIORITY_LOW","COMMAND_PRIORITY_NORMAL","COMMAND_PRIORITY_HIGH","COMMAND_PRIORITY_CRITICAL","prevRootElement","nextRootElement","keyNodeMap","initializeConversionCache","conversionCache","handledConversions","bind","keys","currentCache","createEditor","parentEditor","disableEvents","namespace","initialEditorState","onError","editable","replacementClass","replacementKlass","with","withKlass","proto","prototype","method","hasOwnProperty","console","warn","replaceWithKlass","LexicalEditor","htmlConversions","textcontent","_htmlConversions","registerUpdateListener","listenerSetOrMap","registerEditableListener","registerDecoratorListener","registerTextContentListener","registerRootListener","registerCommand","commandsMap","listenersInPriorityOrder","String","registerMutationListener","registerNodeTransformToKlass","registerNodeTransform","registeredReplaceWithNode","hasNode","hasNodes","getDecorators","setRootElement","userSelect","wordBreak","setEditorState","maybeStringifiedEditorState","JSON","parse","defaultSelection","blur","setEditable","getColSpan","setColSpan","getRowSpan","setRowSpan","DEPRECATED_GridNode","DEPRECATED_GridRowNode","exports","$normalizeSelection__EXPERIMENTAL"],"sources":["C:/Users/franc/Desktop/Progetto/Frontend/app_frontend/node_modules/lexical/Lexical.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3; // Reconciling\n\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2; // Text node modes\n\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2; // IS_INERT = 3\n// Text node formatting\n\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT; // Text node details\n\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1; // Element node formatting\n\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6; // Reconciliation\n\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b'; // For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\n\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n'; // For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\n\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'; // eslint-disable-next-line no-misleading-character-class\n\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']'); // eslint-disable-next-line no-misleading-character-class\n\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcesssingMutations() {\n  return isProcessingMutations;\n}\n\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\n\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\n\nfunction isManagedLineBreak(dom, target, editor) {\n  return (// @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom || // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\n\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\n\nfunction handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n\n  const text = target.nodeValue;\n\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\n\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\n\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement(); // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\n          continue;\n        }\n\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            handleTextMutation( // nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true; // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n\n          const addedDOMs = mutation.addedNodes;\n\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      } // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n\n\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n\n              if (correctDOM === null) {\n                continue;\n              }\n\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      } // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n\n\n      const records = observer.takeRecords(); // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        } // Clear any of those removal mutations\n\n\n        observer.takeRecords();\n      }\n\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\n\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\n\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  } // Backward\n\n\n  let previousNode;\n\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  } // Forward\n\n\n  let nextNode;\n\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\n\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet keyCounter = 1;\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n\n  if (activeElement === null) {\n    return false;\n  }\n\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' && // @ts-ignore iternal field\n  activeElement.__lexicalEditor == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n\n  while (currentNode != null) {\n    // @ts-expect-error: internal field\n    const editor = currentNode.__lexicalEditor;\n\n    if (editor != null) {\n      return editor;\n    }\n\n    currentNode = getParentElement(currentNode);\n  }\n\n  return null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\n\nfunction isDOMNodeLexicalTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\n\nfunction getDOMTextNode(element) {\n  let node = element;\n\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  const isStateFlagPresent = format & activeFormat;\n\n  if (isStateFlagPresent && (alignWithFormat === null || (alignWithFormat & activeFormat) === 0)) {\n    // Remove the state flag.\n    return format ^ activeFormat;\n  }\n\n  if (alignWithFormat === null || alignWithFormat & activeFormat) {\n    // Add the state flag.\n    return format | activeFormat;\n  }\n\n  return format;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    node.__key = existingKey;\n    return;\n  }\n\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n\n  editorState._nodeMap.set(key, node); // TODO Split this function into leaf/element\n\n\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n\n  editor._cloneNotNeeded.add(key);\n\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\n\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n\n    const node = nodeMap.get(nextParentKey);\n\n    if (node === undefined) {\n      break;\n    }\n\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling(); // TODO: this function duplicates a bunch of operations, can be simplified.\n\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n\n      writableNode.__prev = null;\n    }\n\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n\n      writableNode.__next = null;\n    }\n\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n} // Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\n\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n\n  const node = editorState._nodeMap.get(key);\n\n  if (node === undefined) {\n    return null;\n  }\n\n  return node;\n}\nfunction getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor(); // @ts-ignore We intentionally add this to the Node.\n\n  const key = dom[`__lexicalKey_${editor._key}`];\n\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n\n  while (dom != null) {\n    const node = getNodeFromDOMNode(dom, editorState);\n\n    if (node !== null) {\n      return node;\n    }\n\n    dom = getParentElement(dom);\n  }\n\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n\n    if (editorState.isEmpty()) {\n      return;\n    }\n\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n\n    const nodeMap = editorState._nodeMap;\n\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n\n    selection.dirty = true;\n    selection._cachedNodes = null;\n  }\n\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n\n    return null;\n  }\n\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\n\nfunction getNodeKeyFromDOM( // Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key = node[`__lexicalKey_${editor._key}`];\n\n    if (key !== undefined) {\n      return key;\n    }\n\n    node = getParentElement(node);\n  }\n\n  return null;\n}\n\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n\n  return null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n\n  if (domSelection === null) {\n    return;\n  }\n\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n\n    const prevTextContent = node.getTextContent();\n\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n\n        return;\n      }\n\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing || // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter())) {\n        node.markDirty();\n        return;\n      }\n\n      const selection = $getSelection();\n\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\n\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n} // This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\n\n\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(keyCode, altKey, ctrlKey, metaKey) {\n  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(keyCode, shiftKey) {\n  return isReturn(keyCode) && !shiftKey;\n}\nfunction isLineBreak(keyCode, shiftKey) {\n  return isReturn(keyCode) && shiftKey;\n} // Inserts a new line after the selection\n\nfunction isOpenLineBreak(keyCode, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && keyCode === 79;\n}\nfunction isDeleteWordBackward(keyCode, altKey, ctrlKey) {\n  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(keyCode, altKey, ctrlKey) {\n  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(keyCode);\n}\nfunction isDeleteLineForward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isDelete(keyCode);\n}\nfunction isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n\n    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;\n  }\n\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n\n  return isBackspace(keyCode);\n}\nfunction isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n\n    return isDelete(keyCode) || keyCode === 68 && ctrlKey;\n  }\n\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n\n  return isDelete(keyCode);\n}\nfunction isUndo(keyCode, shiftKey, metaKey, ctrlKey) {\n  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return keyCode === 90 && metaKey && shiftKey;\n  }\n\n  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;\n}\nfunction isCopy(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n\n  if (keyCode === 67) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n\n  return false;\n}\nfunction isCut(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n\n  if (keyCode === 88) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n\n  return false;\n}\n\nfunction isArrowLeft(keyCode) {\n  return keyCode === 37;\n}\n\nfunction isArrowRight(keyCode) {\n  return keyCode === 39;\n}\n\nfunction isArrowUp(keyCode) {\n  return keyCode === 38;\n}\n\nfunction isArrowDown(keyCode) {\n  return keyCode === 40;\n}\n\nfunction isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(keyCode, ctrlKey, metaKey) {\n  return isArrowUp(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(keyCode, ctrlKey, metaKey) {\n  return isArrowDown(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(keyCode) {\n  return keyCode === 32;\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n\n  return ctrlKey;\n}\nfunction isReturn(keyCode) {\n  return keyCode === 13;\n}\nfunction isBackspace(keyCode) {\n  return keyCode === 8;\n}\nfunction isEscape(keyCode) {\n  return keyCode === 27;\n}\nfunction isDelete(keyCode) {\n  return keyCode === 46;\n}\nfunction isSelectAll(keyCode, metaKey, ctrlKey) {\n  return keyCode === 65 && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll() {\n  const root = $getRoot();\n  const selection = root.select(0, root.getChildrenSize());\n  $setSelection($normalizeSelection(selection));\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n\n  const classNames = classNamesTheme[classNameThemeType]; // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n\n  if (typeof classNames === 'string') {\n    const classNamesArr = classNames.split(' ');\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n\n  const prevMutation = mutatedNodesByType.get(nodeKey); // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n\n  return nodesOfType;\n}\n\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\n\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n\n      return possibleNode;\n    }\n  }\n\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n\n  if (defaultView === null) {\n    return;\n  }\n\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n\n    let diff = 0;\n\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n\n    if (isBodyElement) {\n      break;\n    }\n\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n\n  editor._updateTags.add(tag);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = domElem.ownerDocument;\n  return ownerDoc && ownerDoc.defaultView || null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n\n    parent = parent.getParentOrThrow();\n  }\n\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\nfunction $copyNode(node) {\n  // @ts-ignore\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n\n  const registeredNode = editor._nodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n    }\n  }\n\n  const replaceFunc = registeredNode.replace;\n\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node);\n\n    if (!(replacementNode instanceof node.constructor)) {\n      {\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\n      }\n    }\n\n    return replacementNode;\n  }\n\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\n\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = blockCursorTheme.split(' '); // @ts-expect-error: intentional\n\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n\n  return element;\n}\n\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\n\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n\n      if (needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n\n      rootElement.style.caretColor = 'transparent';\n\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n\n      return;\n    }\n  } // Remove cursor\n\n\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n\n  if (startNode == null) {\n    startNode = node;\n  }\n\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent); // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n\n    if (isParentRoot) {\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\nfunction $getChildrenRecursively(node) {\n  const nodes = [];\n  const stack = [node];\n\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n\n    if (!(currentNode !== undefined)) {\n      throw Error(`Stack.length > 0; can't be undefined`);\n    }\n\n    if ($isElementNode(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n\n  return nodes;\n}\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\n\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n/**\n * @param x - The element being testing\n * @returns Returns true if x is an HTML element, false otherwise.\n */\n\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n\n      delete decorators[key];\n    }\n  }\n}\n\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n\n  while (child !== null) {\n    const childKey = child.__key; // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      } // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n\n\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n\n      nodeMapDelete.push(childKey);\n    }\n\n    child = child.getNextSibling();\n  }\n}\n\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap; // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n\n  const nodeMapDelete = [];\n\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        } // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n\n\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\n\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  } // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n\n\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\n\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\n\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\n\nconst DEFAULT_INDENT_VALUE = '40px';\n\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\n\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\n\nfunction createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1); // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      createChildrenWithDirection(children, endIndex, node, dom);\n    }\n\n    const format = node.__format;\n\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      } // Decorators are always non editable\n\n\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\n\nfunction createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  createChildren(children, element, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\n\nfunction createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    createNode(children[startIndex], dom, insertDOM);\n  }\n\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  } // @ts-expect-error: internal field\n\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\n} // If we end an element with a LineBreakNode, then we need to add an additional <br>\n\n\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\n\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n\n      if (element != null) {\n        dom.removeChild(element);\n      } // @ts-expect-error: internal field\n\n\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br'); // @ts-expect-error: internal field\n\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\n\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent = // @ts-expect-error: internal field\n  dom.__lexicalDirTextContent; // @ts-expect-error: internal field\n\n  const previousDirection = dom.__lexicalDir;\n\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined; // Remove the old theme classes if they exist\n\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = previousDirectionTheme.split(' ');\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        } // @ts-ignore: intentional\n\n\n        classList.remove(...previousDirectionTheme);\n      }\n\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = nextDirectionTheme.split(' '); // @ts-expect-error: intentional\n\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        } // Update direction\n\n\n        dom.dir = direction;\n      }\n\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n\n    activeTextDirection = direction; // @ts-expect-error: internal field\n\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent; // @ts-expect-error: internal field\n\n    dom.__lexicalDir = direction;\n  }\n}\n\nfunction reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  reconcileChildren(prevElement, nextElement, dom);\n  reconcileBlockDirection(nextElement, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\n\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n\n  return children;\n}\n\nfunction reconcileChildren(prevElement, nextElement, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFrstChildKey = nextElement.__first;\n\n    if (prevFirstChildKey === nextFrstChildKey) {\n      reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = createNode(nextFrstChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevFirstChildKey, null);\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\n    }\n  }\n\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  } // @ts-expect-error: internal field\n\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key); // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      } // @ts-expect-error: internal field\n\n\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n\n    return dom;\n  } // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n\n\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  } // Update node. If it returns true, we need to unmount and re-create the node\n\n\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = createNode(key, null, null);\n\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n\n    const nextFormat = nextNode.__format;\n\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n\n    if (isDirty) {\n      reconcileChildrenWithDirection(prevNode, nextNode, dom);\n\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    nextNode = nextNode.getWritable();\n    nextNode.__cachedText = editorTextContent;\n  }\n\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n\n  return dom;\n}\n\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n\n  pendingDecorators[key] = decorator;\n}\n\nfunction getFirstChild(element) {\n  return element.firstChild;\n}\n\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n\n  return nextSibling;\n}\n\nfunction reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n\n          reconcileNode(nextKey, dom);\n        }\n\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n  }\n\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\n\nfunction reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = ''; // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap); // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  reconcileNode('root', null); // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n\n  activeEditor$1 = undefined; // @ts-ignore\n\n  activeEditorNodes = undefined; // @ts-ignore\n\n  activeDirtyElements = undefined; // @ts-ignore\n\n  activeDirtyLeaves = undefined; // @ts-ignore\n\n  activePrevNodeMap = undefined; // @ts-ignore\n\n  activeNextNodeMap = undefined; // @ts-ignore\n\n  activeEditorConfig = undefined; // @ts-ignore\n\n  activePrevKeyToDOMMap = undefined; // @ts-ignore\n\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap; // @ts-ignore We intentionally add this to the Node.\n\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\n\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\n\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\n\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = 0;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nlet rootElementsRegistered = 0;\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0]; // This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key || // If we're working with a non-text node.\n  !$isTextNode(anchorNode) || // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT || // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() || // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) || // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) || // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style || // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\n\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\n\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false; // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n\n    const selection = $getSelection(); // Update the selection format\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        } // If we have marked a collapsed selection format, and we're\n        // within the given time range – then attempt to use that format\n        // instead of getting the format from the anchor node.\n\n\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element') {\n            selection.format = 0;\n            selection.style = '';\n          }\n        }\n      } else {\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n\n          if ($isTextNode(node)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n} // This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\n\n\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Tripple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n\n        if (domAnchorNode !== null) {\n          const nodeType = domAnchorNode.nodeType; // If the user is attempting to click selection back onto text, then\n          // we should attempt create a range selection.\n          // When we click on an empty paragraph node or the end of a paragraph that ends\n          // with an image/poll, the nodeType will be ELEMENT_NODE\n\n          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {\n            const newSelection = internalCreateRangeSelection(lastSelection, domSelection, editor);\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\n\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\n\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n\n  const targetRanges = event.getTargetRanges();\n\n  if (targetRanges.length === 0) {\n    return null;\n  }\n\n  return targetRanges[0];\n}\n\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\n\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\n\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event); // We let the browser do its own thing for composition.\n\n  if (inputType === 'deleteCompositionText' || // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n\n        $setSelection(prevSelection.clone());\n      }\n\n      if ($isRangeSelection(selection)) {\n        // Used for handling backspace in Android.\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && selection.anchor.key === selection.focus.key) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0; // Fixes an Android bug where selection flickers when backspacing\n\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          event.preventDefault();\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n        }\n\n        return;\n      }\n    }\n\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n\n    const data = event.data; // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    } // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n\n\n    event.preventDefault();\n\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null); // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n\n          break;\n        }\n\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n\n          break;\n        }\n\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n\n    }\n  });\n}\n\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n\n      if (domSelection === null) {\n        return;\n      }\n\n      const offset = anchor.offset; // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n\n      const textLength = data.length; // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      } // This ensures consistency on Android.\n\n\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData); // onInput always fires after onCompositionEnd for FF.\n\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    } // Also flush any other mutations that might have occurred\n    // since the change.\n\n\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\n\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n\n      if ( // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\n\nfunction onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null); // Handle termination of composition.\n\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n\n      return;\n    } // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n\n\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n\n  $updateSelectedTextFromDOM(true, editor, data);\n}\n\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\n\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.keyCode;\n\n  if (editor.isComposing()) {\n    return;\n  }\n\n  const {\n    keyCode,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n\n  if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(keyCode, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(keyCode)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(keyCode, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(keyCode, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(keyCode)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(keyCode)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(keyCode)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(keyCode, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      } // FF does it well (no need to override behavior)\n\n    } else if (!IS_FIREFOX && isSelectAll(keyCode, metaKey, ctrlKey)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\n\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n\n  if (eventHandles === undefined) {\n    eventHandles = []; // @ts-expect-error: internal field\n\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n\n  return eventHandles;\n} // Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\n\n\nconst activeNestedEditorsMap = new Map();\n\nfunction onDocumentSelectionChange(event) {\n  const target = event.target;\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n\n  if (domSelection === null) {\n    return;\n  }\n\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n\n  if (nextActiveEditor === null) {\n    return;\n  }\n\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n\n      if (domAnchorNode === null) {\n        return;\n      }\n\n      const nodeType = domAnchorNode.nodeType; // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n\n      const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor);\n      $setSelection(newSelection);\n    });\n  } // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n\n\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n\n  onSelectionChange(domSelection, nextActiveEditor, true); // If newly selected editor is nested, then add it to the map, clean map otherwise\n\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\n\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\n\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\n\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  if (rootElementsRegistered === 0) {\n    const doc = rootElement.ownerDocument;\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n\n  rootElementsRegistered++; // @ts-expect-error: internal field\n\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n\n      stopLexicalPropagation(event);\n\n      if (editor.isEditable()) {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n\n      stopLexicalPropagation(event);\n\n      if (editor.isEditable()) {\n        switch (eventName) {\n          case 'cut':\n            return dispatchCommand(editor, CUT_COMMAND, event);\n\n          case 'copy':\n            return dispatchCommand(editor, COPY_COMMAND, event);\n\n          case 'paste':\n            return dispatchCommand(editor, PASTE_COMMAND, event);\n\n          case 'dragstart':\n            return dispatchCommand(editor, DRAGSTART_COMMAND, event);\n\n          case 'dragover':\n            return dispatchCommand(editor, DRAGOVER_COMMAND, event);\n\n          case 'dragend':\n            return dispatchCommand(editor, DRAGEND_COMMAND, event);\n\n          case 'focus':\n            return dispatchCommand(editor, FOCUS_COMMAND, event);\n\n          case 'blur':\n            {\n              return dispatchCommand(editor, BLUR_COMMAND, event);\n            }\n\n          case 'drop':\n            return dispatchCommand(editor, DROP_COMMAND, event);\n        }\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  if (rootElementsRegistered !== 0) {\n    rootElementsRegistered--; // We only want to have a single global selectionchange event handler, shared\n    // between all editor instances.\n\n    if (rootElementsRegistered === 0) {\n      const doc = rootElement.ownerDocument;\n      doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n    }\n  } // @ts-expect-error: internal field\n\n\n  const editor = rootElement.__lexicalEditor;\n\n  if (editor !== null && editor !== undefined) {\n    cleanActiveNestedEditorsMap(editor); // @ts-expect-error: internal field\n\n    rootElement.__lexicalEditor = null;\n  }\n\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  } // @ts-expect-error: internal field\n\n\n  rootElement.__lexicalEventHandles = [];\n}\n\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\n\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n\n  if (parent === null) {\n    return;\n  }\n\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    removeNode(parent, restoreSelection);\n  }\n\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n\n\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  constructor(key) {\n    // @ts-expect-error\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, // @ts-expect-error\n        this.constructor);\n      }\n    }\n  } // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n\n\n  getType() {\n    return this.__type;\n  }\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n\n\n  isAttached() {\n    let nodeKey = this.__key;\n\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n\n      const node = $getNodeByKey(nodeKey);\n\n      if (node === null) {\n        break;\n      }\n\n      nodeKey = node.__parent;\n    }\n\n    return false;\n  }\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n\n\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n\n    if (targetSelection == null) {\n      return false;\n    }\n\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n\n    if ($isTextNode(this)) {\n      return isSelected;\n    } // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n\n\n    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element' && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {\n      return false;\n    }\n\n    return isSelected;\n  }\n  /**\n   * Returns this nodes key.\n   */\n\n\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n\n\n  getIndexWithinParent() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return -1;\n    }\n\n    let node = parent.getFirstChild();\n    let index = 0;\n\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n\n      index++;\n      node = node.getNextSibling();\n    }\n\n    return -1;\n  }\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n\n\n  getParent() {\n    const parent = this.getLatest().__parent;\n\n    if (parent === null) {\n      return null;\n    }\n\n    return $getNodeByKey(parent);\n  }\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n\n\n  getParentOrThrow() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n\n    return parent;\n  }\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n\n\n  getTopLevelElement() {\n    let node = this;\n\n    while (node !== null) {\n      const parent = node.getParent();\n\n      if ($isRootOrShadowRoot(parent)) {\n        return node;\n      }\n\n      node = parent;\n    }\n\n    return null;\n  }\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n\n\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n\n    return parent;\n  }\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n\n\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n\n    return parents;\n  }\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n\n\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n\n    return parents;\n  }\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n\n\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n\n\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return siblings;\n    }\n\n    let node = parent.getFirstChild();\n\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n\n    return siblings;\n  }\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n\n\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n\n\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n\n    return siblings;\n  }\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n\n\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n\n    const aLength = a.length;\n    const bLength = b.length;\n\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n\n    const bSet = new Set(b);\n\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n\n\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n\n    return this.__key === object.__key;\n  }\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n\n\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n\n    while (true) {\n      const parent = node.getParentOrThrow();\n\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n\n      node = parent;\n    }\n\n    node = targetNode;\n\n    while (true) {\n      const parent = node.getParentOrThrow();\n\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n\n      node = parent;\n    }\n\n    return indexA < indexB;\n  }\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n\n\n  isParentOf(targetNode) {\n    const key = this.__key;\n\n    if (key === targetNode.__key) {\n      return false;\n    }\n\n    let node = targetNode;\n\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n\n      node = node.getParent();\n    }\n\n    return false;\n  } // TO-DO: this function can be simplified a lot\n\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n\n\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n\n    while (true) {\n      const key = node.__key;\n\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n\n      if (node === targetNode) {\n        break;\n      }\n\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n\n      const parent = node.getParentOrThrow();\n\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n\n      if (parent === targetNode) {\n        break;\n      }\n\n      let parentSibling = null;\n      let ancestor = parent;\n\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        }\n      } while (parentSibling === null);\n\n      node = parentSibling;\n    }\n\n    if (!isBefore) {\n      nodes.reverse();\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n\n\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n\n\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n\n    return latest;\n  }\n  /**\n   * Returns a mutable version of the node. Will throw an error if\n   * called outside of a Lexical Editor {@link LexicalEditor.update} callback.\n   *\n   */\n\n\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key; // Ensure we get the latest node from pending state\n\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n\n    if (selection !== null) {\n      selection._cachedNodes = null;\n    }\n\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n\n    const constructor = latestNode.constructor; // @ts-expect-error\n\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n    mutableNode.__next = latestNode.__next;\n    mutableNode.__prev = latestNode.__prev;\n\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      mutableNode.__first = latestNode.__first;\n      mutableNode.__last = latestNode.__last;\n      mutableNode.__size = latestNode.__size;\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n    }\n\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode); // Update reference in node map\n\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n\n\n  getTextContent() {\n    return '';\n  }\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n\n\n  getTextContentSize() {\n    return this.getTextContent().length;\n  } // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n\n\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n\n\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n\n\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n\n\n  exportJSON() {\n    {\n      throw Error(`exportJSON: base method not extended`);\n    }\n  }\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n\n\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n\n\n  static transform() {\n    return null;\n  } // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n\n\n  remove(preserveEmptyParent) {\n    removeNode(this, true, preserveEmptyParent);\n  }\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n\n\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) selection = selection.clone();\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    removeNode(self, false, true);\n\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n\n    writableReplaceWith.__prev = prevKey;\n\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n\n    return writableReplaceWith;\n  }\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n\n\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n\n    return nodeToInsert;\n  }\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n\n\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev; // TODO: this is O(n), can we improve?\n\n    const index = this.getIndexWithinParent();\n\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n\n    return nodeToInsert;\n  }\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n\n\n  isParentRequired() {\n    return false;\n  }\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n\n\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n\n\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n\n\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n\n    if (nextSibling === null) {\n      return parent.select();\n    }\n\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n\n\n  markDirty() {\n    this.getWritable();\n  }\n\n}\n\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type); // Common error - split in its own invariant\n\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n\n  const editorKlass = registeredNode.klass;\n\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  }\n\n  getTextContent() {\n    return '\\n';\n  }\n\n  createDOM() {\n    return document.createElement('br');\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      br: node => {\n        const parentElement = node.parentElement; // If the <br> is the only child, then skip including it\n\n        let firstChild;\n        let lastChild;\n\n        if (parentElement !== null && ((firstChild = parentElement.firstChild) === node || firstChild.nextSibling === node && firstChild.nodeType === DOM_TEXT_TYPE && (firstChild.textContent || '').match(/^( |\\t|\\r?\\n)+$/) !== null) && ((lastChild = parentElement.lastChild) === node || lastChild.previousSibling === node && lastChild.nodeType === DOM_TEXT_TYPE && (lastChild.textContent || '').match(/^( |\\t|\\r?\\n)+$/) !== null)) {\n          return null;\n        }\n\n        return {\n          conversion: convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode();\n  }\n\n  exportJSON() {\n    return {\n      type: 'linebreak',\n      version: 1\n    };\n  }\n\n}\n\nfunction convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\n\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n\n  return null;\n}\n\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n\n  return 'span';\n}\n\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList; // Firstly we handle the base theme.\n\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  } // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n\n\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n\n          continue;\n        }\n\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\n\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\n\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing(); // Always add a suffix if we're composing a node\n\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        } // @ts-expect-error\n\n\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\n\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme; // Apply theme class names\n\n  const textClassNames = theme.text;\n\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\n\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n/** @noInheritDoc */\n\n\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'text';\n  }\n\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n\n\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n\n\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n\n\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n\n\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n\n\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n\n\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n\n\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n\n\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n\n\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n\n\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n\n\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n\n\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  } // View\n\n\n  createDOM(config) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n\n    if (prevTag !== nextTag) {\n      return true;\n    }\n\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n\n    let innerDOM = dom;\n\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme; // Apply theme class names\n\n    const textClassNames = theme.text;\n\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  } // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n\n\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n\n    if (!(element !== null && isHTMLElement(element))) {\n      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n\n    element.style.whiteSpace = 'pre-wrap'; // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1\n    };\n  } // Mutators\n\n\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n\n\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.togglerUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n\n\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n\n\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it is present.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n\n\n  toggleFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return this.setFormat(this.getFormat() ^ formatFlag);\n  }\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n\n\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n\n\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n\n\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n\n    if (this.__mode === mode) {\n      return this;\n    }\n\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n\n\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n\n    return selection;\n  }\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n\n\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n\n    if (index < 0) {\n      index = handledTextLength + index;\n\n      if (index < 0) {\n        index = 0;\n      }\n    }\n\n    const selection = $getSelection();\n\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n\n\n  canInsertTextBefore() {\n    return true;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n\n\n  canInsertTextAfter() {\n    return true;\n  }\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n\n\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n\n      string += textContent[i];\n    }\n\n    if (string !== '') {\n      parts.push(string);\n    }\n\n    const partsLength = parts.length;\n\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    } // Handle selection\n\n\n    const selection = $getSelection(); // Then handle all other parts\n\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    } // Insert the nodes into the parent's children\n\n\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const insertionIndex = this.getIndexWithinParent();\n\n    if (hasReplacedSelf) {\n      writableParent.splice(insertionIndex, 0, splitNodes);\n      this.remove();\n    } else {\n      writableParent.splice(insertionIndex, 1, splitNodes);\n    }\n\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n\n    return splitNodes;\n  }\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n\n\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n\n\n  isTextEntity() {\n    return false;\n  }\n\n}\n\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode; // Google Docs uses span tags + font-weight for bold text\n\n  const hasBoldFontWeight = span.style.fontWeight === '700'; // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n\n  const hasLinethroughTextDecoration = span.style.textDecoration === 'line-through'; // Google Docs uses span tags + font-style for italic text\n\n  const hasItalicFontStyle = span.style.fontStyle === 'italic'; // Google Docs uses span tags + text-decoration: underline for underline text\n\n  const hasUnderlineTextDecoration = span.style.textDecoration === 'underline'; // Google Docs uses span tags + vertical-align to specify subscript and superscript\n\n  const verticalAlign = span.style.verticalAlign;\n  return {\n    forChild: lexicalNode => {\n      if (!$isTextNode(lexicalNode)) {\n        return lexicalNode;\n      }\n\n      if (hasBoldFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n\n      if (hasLinethroughTextDecoration) {\n        lexicalNode.toggleFormat('strikethrough');\n      }\n\n      if (hasItalicFontStyle) {\n        lexicalNode.toggleFormat('italic');\n      }\n\n      if (hasUnderlineTextDecoration) {\n        lexicalNode.toggleFormat('underline');\n      }\n\n      if (verticalAlign === 'sub') {\n        lexicalNode.toggleFormat('subscript');\n      }\n\n      if (verticalAlign === 'super') {\n        lexicalNode.toggleFormat('superscript');\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode; // Google Docs wraps all copied HTML in a <b> with font-weight normal\n\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nconst preParentCache = new WeakMap();\n\nfunction isNodePre(node) {\n  return node.nodeName === 'PRE' || node.nodeType === DOM_ELEMENT_TYPE && node.style.whiteSpace.startsWith('pre');\n}\n\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n\n  const resultNode = cached === undefined ? parent : cached;\n\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n\n  return resultNode;\n}\n\nfunction convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n\n  let textContent = domNode_.textContent || ''; // No collapse and preserve segment break for pre, pre-wrap and pre-line\n\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n\n    return {\n      node: nodes\n    };\n  }\n\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n\n        isStartOfLine = false;\n        break;\n      }\n    }\n\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    node: $createTextNode(textContent)\n  };\n}\n\nconst inlineParents = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, 'i');\n\nfunction findTextInLine(text, forward) {\n  let node = text; // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    let sibling;\n\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n\n      if (parentElement === null) {\n        return null;\n      }\n\n      node = parentElement;\n    }\n\n    node = sibling;\n\n    if (node.nodeType === DOM_ELEMENT_TYPE) {\n      const display = node.style.display;\n\n      if (display === '' && node.nodeName.match(inlineParents) === null || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n\n    let descendant = node;\n\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n\n    if (node.nodeType === DOM_TEXT_TYPE) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\n\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\n\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format)) {\n        lexicalNode.toggleFormat(format);\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n\n  static clone(node) {\n    const newNode = new TabNode(node.__key); // TabNode __text can be either '\\t' or ''. insertText will remove the empty Node\n\n    newNode.__text = node.__text;\n    newNode.__format = node.__format;\n    newNode.__style = node.__style;\n    return newNode;\n  }\n\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n\n  static importDOM() {\n    return null;\n  }\n\n  static importJSON(serializedTabNode) {\n    const node = $createTabNode();\n    node.setFormat(serializedTabNode.format);\n    node.setStyle(serializedTabNode.style);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'tab',\n      version: 1\n    };\n  }\n\n  setTextContent(_text) {\n    {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n  }\n\n  setDetail(_detail) {\n    {\n      throw Error(`TabNode does not support setDetail`);\n    }\n  }\n\n  setMode(_type) {\n    {\n      throw Error(`TabNode does not support setMode`);\n    }\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  canInsertTextAfter() {\n    return false;\n  }\n\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Point {\n  constructor(key, offset, type) {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n\n    return aNode.isBefore(bNode);\n  }\n\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n\n    return node;\n  }\n\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n\n      if (selection !== null) {\n        selection._cachedNodes = null;\n        selection.dirty = true;\n      }\n    }\n  }\n\n}\n\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\n\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n\n  point.set(key, offset, type);\n}\n\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\n\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target); // Fix the end point offset if it refers to the same element as start,\n    // as we've now inserted another element before it. Note that we only\n    // do it if selection is not collapsed as otherwise it'll transfer\n    // both focus and anchor to the text node below\n\n    if (end.type === 'element' && end.key === start.key && end.offset !== start.offset) {\n      end.set(end.key, end.offset + 1, 'element');\n    }\n  } // Transfer the element point to a text point.\n\n\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n\n  start.set(textNode.__key, 0, 'text');\n}\n\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\n\nclass NodeSelection {\n  constructor(objects) {\n    this.dirty = false;\n    this._nodes = objects;\n    this._cachedNodes = null;\n  }\n\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n\n  add(key) {\n    this.dirty = true;\n\n    this._nodes.add(key);\n\n    this._cachedNodes = null;\n  }\n\n  delete(key) {\n    this.dirty = true;\n\n    this._nodes.delete(key);\n\n    this._cachedNodes = null;\n  }\n\n  clear() {\n    this.dirty = true;\n\n    this._nodes.clear();\n\n    this._cachedNodes = null;\n  }\n\n  has(key) {\n    return this._nodes.has(key);\n  }\n\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n\n  extract() {\n    return this.getNodes();\n  }\n\n  insertRawText(text) {// Do nothing?\n  }\n\n  insertText() {// Do nothing?\n  }\n\n  insertNodes(nodes, selectStart) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd; // Insert nodes\n\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n\n    selectionAtEnd.insertNodes(nodes, selectStart); // Remove selected nodes\n\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n\n    return true;\n  }\n\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n\n    const objects = this._nodes;\n    const nodes = [];\n\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n\n    return nodes;\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n\n    return textContent;\n  }\n\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nfunction DEPRECATED_$getGridCellNodeRect(GridCellNode) {\n  const [CellNode,, GridNode] = DEPRECATED_$getNodeTriplet(GridCellNode);\n  const rows = GridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length; // Create a matrix of the same size as the table to track the position of each cell\n\n  const cellMatrix = new Array(rowCount);\n\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1; // Put the cell into the corresponding position in the matrix\n\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      } // Return to the original index, row span and column span of the cell.\n\n\n      if (CellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n\n      columnIndex += colSpan;\n    }\n  }\n\n  return null;\n}\nclass GridSelection {\n  constructor(gridKey, anchor, focus) {\n    this.gridKey = gridKey;\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n\n  is(selection) {\n    if (!DEPRECATED_$isGridSelection(selection)) {\n      return false;\n    }\n\n    return this.gridKey === selection.gridKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n\n  set(gridKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.gridKey = gridKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n\n  clone() {\n    return new GridSelection(this.gridKey, this.anchor, this.focus);\n  }\n\n  isCollapsed() {\n    return false;\n  }\n\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n\n  extract() {\n    return this.getNodes();\n  }\n\n  insertRawText(text) {// Do nothing?\n  }\n\n  insertText() {// Do nothing?\n  }\n\n  insertNodes(nodes, selectStart) {\n    const focusNode = this.focus.getNode();\n    const selection = $normalizeSelection(focusNode.select(0, focusNode.getChildrenSize()));\n    return selection.insertNodes(nodes, selectStart);\n  } // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n\n\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n\n    if (!DEPRECATED_$isGridCellNode(anchorCellNode)) {\n      throw Error(`Expected GridSelection anchor to be (or a child of) GridCellNode`);\n    }\n\n    const anchorCellNodeRect = DEPRECATED_$getGridCellNodeRect(anchorCellNode);\n\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n\n    const focusCellNode = $getNodeByKey(this.focus.key);\n\n    if (!DEPRECATED_$isGridCellNode(focusCellNode)) {\n      throw Error(`Expected GridSelection focus to be (or a child of) GridCellNode`);\n    }\n\n    const focusCellNodeRect = DEPRECATED_$getGridCellNodeRect(focusCellNode);\n\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = $findMatchingParent(anchorNode, DEPRECATED_$isGridCellNode); // todo replace with triplet\n\n    const focusCell = $findMatchingParent(focusNode, DEPRECATED_$isGridCellNode);\n\n    if (!DEPRECATED_$isGridCellNode(anchorCell)) {\n      throw Error(`Expected GridSelection anchor to be (or a child of) GridCellNode`);\n    }\n\n    if (!DEPRECATED_$isGridCellNode(focusCell)) {\n      throw Error(`Expected GridSelection focus to be (or a child of) GridCellNode`);\n    }\n\n    const anchorRow = anchorCell.getParent();\n\n    if (!DEPRECATED_$isGridRowNode(anchorRow)) {\n      throw Error(`Expected anchorCell to have a parent GridRowNode`);\n    }\n\n    const gridNode = anchorRow.getParent();\n\n    if (!DEPRECATED_$isGridNode(gridNode)) {\n      throw Error(`Expected tableNode to have a parent GridNode`);\n    } // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing GridSelection and moving the logic to the plugin would make\n    // this possible.\n\n\n    const [map, cellAMap, cellBMap] = DEPRECATED_$computeGridMap(gridNode, anchorCell, focusCell);\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n\n    function expandBoundary(mapValue) {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n\n        exploredMinColumn = previousColumn;\n      }\n\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n\n        exploredMinRow = previousRow;\n      }\n\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n\n        exploredMaxColumn = nextColumn;\n      }\n\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n\n        exploredMaxRow = nextRow;\n      }\n    }\n\n    const nodes = [gridNode];\n    let lastRow = null;\n\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n\n        if (!DEPRECATED_$isGridRowNode(currentRow)) {\n          throw Error(`Expected GridCellNode parent to be a GridRowNode`);\n        }\n\n        if (currentRow !== lastRow) {\n          nodes.push(currentRow);\n        }\n\n        nodes.push(cell, ...$getChildrenRecursively(cell));\n        lastRow = currentRow;\n      }\n    }\n\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n\n    return nodes;\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n\n    return textContent;\n  }\n\n}\nfunction DEPRECATED_$isGridSelection(x) {\n  return x instanceof GridSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this.format = format;\n    this.style = style;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n\n\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n\n\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n\n\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n\n\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset); // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n\n    let nodes;\n\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n\n    return nodes;\n  }\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n\n\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n\n\n  getTextContent() {\n    const nodes = this.getNodes();\n\n    if (nodes.length === 0) {\n      return '';\n    }\n\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n\n    return textContent;\n  }\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n\n\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n\n\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n\n\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n\n\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n\n\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n\n    this.insertNodes(nodes);\n  }\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection as a new\n   * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.\n   *\n   * @param text the text to insert into the Selection\n   */\n\n\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = this.isCollapsed() || anchor.isBefore(focus);\n    const format = this.format;\n    const style = this.style;\n\n    if (isBefore && anchor.type === 'element') {\n      $transferStartingElementPointToTextPoint(anchor, focus, format, style);\n    } else if (!isBefore && focus.type === 'element') {\n      $transferStartingElementPointToTextPoint(focus, anchor, format, style);\n    }\n\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const firstPoint = isBefore ? anchor : focus;\n    const endPoint = isBefore ? focus : anchor;\n    const startOffset = firstPoint.offset;\n    const endOffset = endPoint.offset;\n    let firstNode = selectedNodes[0];\n\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n\n      prevSibling.select();\n      firstNode = prevSibling;\n\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          } // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n\n\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n\n          return;\n        }\n      }\n\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]); // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode; // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      } // Handle mutations to the last node.\n\n\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          } // root node selections only select whole nodes, so no text splice is necessary\n\n\n          if (!$isRootNode(endPoint.getNode())) {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      } // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n\n\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement); // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n\n          parent = parent.getParent();\n        }\n      } // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n\n\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      } // Remove all selected nodes that haven't already been removed.\n\n\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n\n\n  removeText() {\n    this.insertText('');\n  }\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   */\n\n\n  formatText(formatType) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType); // When changing format, we should stop composition\n\n      $setCompositionKey(null);\n      return;\n    }\n\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n\n    const selectedTextNodesLength = selectedTextNodes.length;\n\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType); // When changing format, we should stop composition\n\n      $setCompositionKey(null);\n      return;\n    }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset; // In case selection started at the end of text node use next text node\n\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n\n    if (firstNode == null) {\n      return;\n    }\n\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize(); // Single node selected\n\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n\n      if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat); // Update selection only if starts/ends on text node\n\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n\n      this.format = firstNextFormat;\n      return;\n    } // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n\n\n    if (startOffset !== 0) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat); // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize()) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      lastNode.setFormat(lastNextFormat);\n    } // Process all text nodes in between\n\n\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n\n      if (!textNode.isToken()) {\n        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n        textNode.setFormat(nextFormat);\n      }\n    } // Update selection only if starts/ends on text node\n\n\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n\n    this.format = firstNextFormat | lastNextFormat;\n  }\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accomodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   * @param selectStart - whether or not to select the start after the insertion.\n   * @returns true if the nodes were inserted successfully, false otherwise.\n   */\n\n\n  insertNodes(nodes, selectStart) {\n    // If there is a range selected remove the text in it\n    if (!this.isCollapsed()) {\n      const selectionEnd = this.isBackward() ? this.anchor : this.focus;\n      const nextSibling = selectionEnd.getNode().getNextSibling();\n      const nextSiblingKey = nextSibling ? nextSibling.getKey() : null;\n      const prevSibling = selectionEnd.getNode().getPreviousSibling();\n      const prevSiblingKey = prevSibling ? prevSibling.getKey() : null;\n      this.removeText(); // If the selection has been moved to an adjacent inline element, create\n      // a temporary text node that we can insert the nodes after.\n\n      if (this.isCollapsed() && this.focus.type === 'element') {\n        let textNode;\n\n        if (this.focus.key === nextSiblingKey && this.focus.offset === 0) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertBefore(textNode);\n        } else if (this.focus.key === prevSiblingKey && this.focus.offset === this.focus.getNode().getChildrenSize()) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertAfter(textNode);\n        }\n\n        if (textNode) {\n          this.focus.set(textNode.__key, 0, 'text');\n          this.anchor.set(textNode.__key, 0, 'text');\n        }\n      }\n    }\n\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    const anchorNode = anchor.getNode();\n    let target = anchorNode;\n\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n      const placementNode = element.getChildAtIndex(anchorOffset - 1);\n\n      if (placementNode === null) {\n        target = element;\n      } else {\n        target = placementNode;\n      }\n    }\n\n    const siblings = []; // Get all remaining text node siblings in this element so we can\n    // append them after the last node we're inserting.\n\n    const nextSiblings = anchorNode.getNextSiblings();\n    const topLevelElement = $isRootOrShadowRoot(anchorNode) ? null : anchorNode.getTopLevelElementOrThrow();\n\n    if ($isTextNode(anchorNode)) {\n      const textContent = anchorNode.getTextContent();\n      const textContentLength = textContent.length;\n\n      if (anchorOffset === 0 && textContentLength !== 0) {\n        const prevSibling = anchorNode.getPreviousSibling();\n\n        if (prevSibling !== null) {\n          target = prevSibling;\n        } else {\n          target = anchorNode.getParentOrThrow();\n        }\n\n        siblings.push(anchorNode);\n      } else if (anchorOffset === textContentLength) {\n        target = anchorNode;\n      } else if (anchorNode.isToken()) {\n        // Do nothing if we're inside a token node\n        return false;\n      } else {\n        // If we started with a range selected grab the danglingText after the\n        // end of the selection and put it on our siblings array so we can\n        // append it after the last node we're inserting\n        let danglingText;\n        [target, danglingText] = anchorNode.splitText(anchorOffset);\n        siblings.push(danglingText);\n      }\n    }\n\n    const startingNode = target;\n    siblings.push(...nextSiblings);\n    const firstNode = nodes[0];\n    let didReplaceOrMerge = false;\n    let lastNode = null; // Time to insert the nodes!\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (!$isRootOrShadowRoot(target) && !$isDecoratorNode(target) && $isElementNode(node) && !node.isInline()) {\n        // -----\n        // Heuristics for the replacement or merging of elements\n        // -----\n        // If we have an incoming element node as the first node, then we'll need\n        // see if we can merge any descendant leaf nodes into our existing target.\n        // We can do this by finding the first descendant in our node and then we can\n        // pluck it and its parent (siblings included) out and insert them directly\n        // into our target. We only do this for the first node, as we are only\n        // interested in merging with the anchor, which is our target.\n        //\n        // If we apply either the replacement or merging heuristics, we need to be\n        // careful that we're not trying to insert a non-element node into a root node,\n        // so we check if the target's parent after this logic is the root node and if\n        // so we trigger an invariant to ensure this problem is caught in development\n        // and fixed accordingly.\n        if (node.is(firstNode)) {\n          if ($isElementNode(target) && target.isEmpty() && target.canReplaceWith(node)) {\n            target.replace(node);\n            target = node;\n            didReplaceOrMerge = true;\n            continue;\n          } // We may have a node tree where there are many levels, for example with\n          // lists and tables. So let's find the first descendant to try and merge\n          // with. So if we have the target:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //\n          // and we are trying to insert:\n          //\n          // ListNode (3)\n          //   ListItemNode (4)\n          //     Text (5)\n          //   ListItemNode (6)\n          //\n          // The result would be:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //   Text (5)\n          //\n\n\n          const firstDescendant = node.getFirstDescendant();\n\n          if ($isLeafNode(firstDescendant)) {\n            let element = firstDescendant.getParentOrThrow();\n\n            while (element.isInline()) {\n              element = element.getParentOrThrow();\n            }\n\n            const children = element.getChildren();\n            const childrenLength = children.length;\n\n            if ($isElementNode(target)) {\n              let firstChild = target.getFirstChild();\n\n              for (let s = 0; s < childrenLength; s++) {\n                const child = children[s];\n\n                if (firstChild === null) {\n                  target.append(child);\n                } else {\n                  firstChild.insertAfter(child);\n                }\n\n                firstChild = child;\n              }\n            } else {\n              for (let s = childrenLength - 1; s >= 0; s--) {\n                target.insertAfter(children[s]);\n              }\n\n              target = target.getParentOrThrow();\n            }\n\n            lastNode = children[childrenLength - 1];\n            element.remove();\n            didReplaceOrMerge = true;\n\n            if (element.is(node)) {\n              continue;\n            }\n          }\n        }\n\n        if ($isTextNode(target)) {\n          if (topLevelElement === null) {\n            {\n              throw Error(`insertNode: topLevelElement is root node`);\n            }\n          }\n\n          target = topLevelElement;\n        }\n      } else if (didReplaceOrMerge && !$isElementNode(node) && !$isDecoratorNode(node) && $isRootOrShadowRoot(target.getParent())) {\n        {\n          throw Error(`insertNodes: cannot insert a non-element into a root node`);\n        }\n      }\n\n      didReplaceOrMerge = false;\n\n      if ($isElementNode(target) && !target.isInline()) {\n        lastNode = node;\n\n        if ($isDecoratorNode(node) && !node.isInline()) {\n          if (nodes.length === 1 && target.canBeEmpty() && target.isEmpty()) {\n            target = target.insertBefore(node, false);\n          } else {\n            target = target.insertAfter(node, false);\n          }\n        } else if (!$isElementNode(node)) {\n          const firstChild = target.getFirstChild();\n\n          if (firstChild !== null) {\n            firstChild.insertBefore(node);\n          } else {\n            target.append(node);\n          }\n\n          target = node;\n        } else {\n          if (!node.canBeEmpty() && node.isEmpty()) {\n            continue;\n          }\n\n          if ($isRootNode(target)) {\n            const placementNode = target.getChildAtIndex(anchorOffset);\n\n            if (placementNode !== null) {\n              placementNode.insertBefore(node);\n            } else {\n              target.append(node);\n            }\n\n            target = node;\n          } else if (node.isInline()) {\n            target.append(node);\n            target = node;\n          } else {\n            target = target.insertAfter(node, false);\n          }\n        }\n      } else if (!$isElementNode(node) || $isElementNode(node) && node.isInline() || $isDecoratorNode(target) && !target.isInline()) {\n        lastNode = node; // when pasting top level node in the middle of paragraph\n        // we need to split paragraph instead of placing it inline\n\n        if ($isRangeSelection(this) && $isDecoratorNode(node) && ($isElementNode(target) || $isTextNode(target)) && !node.isInline()) {\n          let splitNode;\n          let splitOffset;\n\n          if ($isTextNode(target)) {\n            splitNode = target.getParentOrThrow();\n            const [textNode] = target.splitText(anchorOffset);\n            splitOffset = textNode.getIndexWithinParent() + 1;\n          } else {\n            splitNode = target;\n            splitOffset = anchorOffset;\n          }\n\n          const [, rightTree] = $splitNode(splitNode, splitOffset);\n          target = rightTree.insertBefore(node);\n        } else {\n          target = target.insertAfter(node, false);\n        }\n      } else {\n        const nextTarget = target.getParentOrThrow(); // if we're inserting an Element after a LineBreak, we want to move the target to the parent\n        // and remove the LineBreak so we don't have empty space.\n\n        if ($isLineBreakNode(target)) {\n          target.remove();\n        }\n\n        target = nextTarget; // Re-try again with the target being the parent\n\n        i--;\n        continue;\n      }\n    }\n\n    if (selectStart) {\n      // Handle moving selection to start for all nodes\n      if ($isTextNode(startingNode)) {\n        startingNode.select();\n      } else {\n        const prevSibling = target.getPreviousSibling();\n\n        if ($isTextNode(prevSibling)) {\n          prevSibling.select();\n        } else {\n          const index = target.getIndexWithinParent();\n          target.getParentOrThrow().select(index, index);\n        }\n      }\n    }\n\n    if ($isElementNode(target)) {\n      // If the last node to be inserted was a text node,\n      // then we should attempt to move selection to that.\n      const lastChild = $isTextNode(lastNode) ? lastNode : $isElementNode(lastNode) && lastNode.isInline() ? lastNode.getLastDescendant() : target.getLastDescendant();\n\n      if (!selectStart) {\n        // Handle moving selection to end for elements\n        if (lastChild === null) {\n          target.select();\n        } else if ($isTextNode(lastChild)) {\n          if (lastChild.getTextContent() === '') {\n            lastChild.selectPrevious();\n          } else {\n            lastChild.select();\n          }\n        } else {\n          lastChild.selectNext();\n        }\n      }\n\n      if (siblings.length !== 0) {\n        const originalTarget = target;\n\n        for (let i = siblings.length - 1; i >= 0; i--) {\n          const sibling = siblings[i];\n          const prevParent = sibling.getParentOrThrow();\n\n          if ($isElementNode(target) && !$isBlockElementNode(sibling) && !($isDecoratorNode(sibling) && ( // Note: We are only looking for decorators that are inline and not isolated.\n          !sibling.isInline() || sibling.isIsolated()))) {\n            if (originalTarget === target) {\n              target.append(sibling);\n            } else {\n              target.insertBefore(sibling);\n            }\n\n            target = sibling;\n          } else if (!$isElementNode(target) && !$isBlockElementNode(sibling)) {\n            target.insertBefore(sibling);\n            target = sibling;\n          } else {\n            if ($isElementNode(sibling) && !sibling.canInsertAfter(target)) {\n              // @ts-ignore The clone method does exist on the constructor.\n              const prevParentClone = prevParent.constructor.clone(prevParent);\n\n              if (!$isElementNode(prevParentClone)) {\n                {\n                  throw Error(`insertNodes: cloned parent clone is not an element`);\n                }\n              }\n\n              prevParentClone.append(sibling);\n              target.insertAfter(prevParentClone);\n            } else {\n              target.insertAfter(sibling);\n            }\n          } // Check if the prev parent is empty, as it might need\n          // removing.\n\n\n          if (prevParent.isEmpty() && !prevParent.canBeEmpty()) {\n            prevParent.remove();\n          }\n        }\n      }\n    } else if (!selectStart) {\n      // Handle moving selection to end for other nodes\n      if ($isTextNode(target)) {\n        target.select();\n      } else {\n        const element = target.getParentOrThrow();\n        const index = target.getIndexWithinParent() + 1;\n        element.select(index, index);\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   */\n\n\n  insertParagraph() {\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    let currentElement;\n    let nodesToMove = [];\n    let siblingsToMove = [];\n\n    if (anchor.type === 'text') {\n      const anchorNode = anchor.getNode();\n      nodesToMove = anchorNode.getNextSiblings().reverse();\n      currentElement = anchorNode.getParentOrThrow();\n      const isInline = currentElement.isInline();\n      const textContentLength = isInline ? currentElement.getTextContentSize() : anchorNode.getTextContentSize();\n\n      if (anchorOffset === 0) {\n        nodesToMove.push(anchorNode);\n      } else {\n        if (isInline) {\n          // For inline nodes, we want to move all the siblings to the new paragraph\n          // if selection is at the end, we just move the siblings. Otherwise, we also\n          // split the text node and add that and it's siblings below.\n          siblingsToMove = currentElement.getNextSiblings();\n        }\n\n        if (anchorOffset !== textContentLength) {\n          if (!isInline || anchorOffset !== anchorNode.getTextContentSize()) {\n            const [, splitNode] = anchorNode.splitText(anchorOffset);\n            nodesToMove.push(splitNode);\n          }\n        }\n      }\n    } else {\n      currentElement = anchor.getNode();\n\n      if ($isRootOrShadowRoot(currentElement)) {\n        const paragraph = $createParagraphNode();\n        const child = currentElement.getChildAtIndex(anchorOffset);\n        paragraph.select();\n\n        if (child !== null) {\n          child.insertBefore(paragraph, false);\n        } else {\n          currentElement.append(paragraph);\n        }\n\n        return;\n      }\n\n      nodesToMove = currentElement.getChildren().slice(anchorOffset).reverse();\n    }\n\n    const nodesToMoveLength = nodesToMove.length;\n\n    if (anchorOffset === 0 && nodesToMoveLength > 0 && currentElement.isInline()) {\n      const parent = currentElement.getParentOrThrow();\n      const newElement = parent.insertNewAfter(this, false);\n\n      if ($isElementNode(newElement)) {\n        const children = parent.getChildren();\n\n        for (let i = 0; i < children.length; i++) {\n          newElement.append(children[i]);\n        }\n      }\n\n      return;\n    }\n\n    const newElement = currentElement.insertNewAfter(this, false);\n\n    if (newElement === null) {\n      // Handle as a line break insertion\n      this.insertLineBreak();\n    } else if ($isElementNode(newElement)) {\n      // If we're at the beginning of the current element, move the new element to be before the current element\n      const currentElementFirstChild = currentElement.getFirstChild();\n      const isBeginning = anchorOffset === 0 && (currentElement.is(anchor.getNode()) || currentElementFirstChild && currentElementFirstChild.is(anchor.getNode()));\n\n      if (isBeginning && nodesToMoveLength > 0) {\n        currentElement.insertBefore(newElement);\n        return;\n      }\n\n      let firstChild = null;\n      const siblingsToMoveLength = siblingsToMove.length;\n      const parent = newElement.getParentOrThrow(); // For inline elements, we append the siblings to the parent.\n\n      if (siblingsToMoveLength > 0) {\n        for (let i = 0; i < siblingsToMoveLength; i++) {\n          const siblingToMove = siblingsToMove[i];\n          parent.append(siblingToMove);\n        }\n      }\n\n      if (nodesToMoveLength !== 0) {\n        for (let i = 0; i < nodesToMoveLength; i++) {\n          const nodeToMove = nodesToMove[i];\n\n          if (firstChild === null) {\n            newElement.append(nodeToMove);\n          } else {\n            firstChild.insertBefore(nodeToMove);\n          }\n\n          firstChild = nodeToMove;\n        }\n      }\n\n      if (!newElement.canBeEmpty() && newElement.getChildrenSize() === 0) {\n        newElement.selectPrevious();\n        newElement.remove();\n      } else {\n        newElement.selectStart();\n      }\n    }\n  }\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   *\n   * @param selectStart whether or not to select the start of the insertion range after the operation completes.\n   */\n\n\n  insertLineBreak(selectStart) {\n    const lineBreakNode = $createLineBreakNode();\n    const anchor = this.anchor;\n\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n\n      if ($isRootNode(element)) {\n        this.insertParagraph();\n      }\n    }\n\n    if (selectStart) {\n      this.insertNodes([lineBreakNode], true);\n    } else {\n      if (this.insertNodes([lineBreakNode])) {\n        lineBreakNode.selectNext(0, 0);\n      }\n    }\n  }\n  /**\n   * Returns the character-based offsets of the Selection, accounting for non-text Points\n   * by using the children size or text content.\n   *\n   * @returns the character offsets for the Selection\n   */\n\n\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n\n\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n\n      return [firstNode];\n    }\n\n    const isBefore = anchor.isBefore(focus);\n\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n\n    return selectedNodes;\n  }\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n\n\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move'; // Handle the selection movement around decorators.\n\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n\n          if (!isBackward) {\n            offset++;\n          }\n        }\n\n        focus.set(elementKey, offset, 'element');\n\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n\n        return;\n      }\n    }\n\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n\n    if (!domSelection) {\n      return;\n    }\n\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement; // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    } // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n\n\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity); // Guard against no ranges\n\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0); // Apply the DOM selection to our Lexical selection.\n\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        } // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n\n\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const focus = this.focus;\n      let anchorNode = anchor.getNode();\n\n      if (!isBackward && ( // Delete forward handle case\n      anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n        const parent = anchorNode.getParent();\n        const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n\n        if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n          return;\n        }\n      } // Handle the deletion around decorators.\n\n\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n\n      this.modify('extend', isBackward, 'character');\n\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n\n    this.removeText();\n\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      if (this.anchor.type === 'text') {\n        this.modify('extend', isBackward, 'lineboundary');\n      } // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n\n\n      const endPoint = isBackward ? this.focus : this.anchor;\n\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n    }\n\n    this.removeText();\n  }\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify('extend', isBackward, 'word');\n    }\n\n    this.removeText();\n  }\n\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\n\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n\n  if (point.type === 'text') {\n    return offset;\n  }\n\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\n\nfunction getCharacterOffsets(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\n\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\n\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\n\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\n\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n\n      break;\n    }\n  }\n\n  const nextTextContent = split.join('').trim();\n\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\n\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\n\nfunction internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode; // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false; // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length; // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n\n    if (childDOM === editor._blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (editor._blockCursorElement !== null) {\n      resolvedOffset--;\n    }\n\n    resolvedNode = getNodeFromDOM(childDOM);\n\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = getNodeFromDOM(dom); // Ensure resolvedElement is actually a element.\n\n      if (resolvedElement === null) {\n        return null;\n      }\n\n      if ($isElementNode(resolvedElement)) {\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n\n          if (descendant === null) {\n            resolvedElement = child;\n            resolvedOffset = 0;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n        }\n\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent(); // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = getNodeFromDOM(dom);\n  }\n\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\n\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize(); // @ts-expect-error: intentional\n\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0; // @ts-expect-error: intentional\n\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\n\nfunction normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus); // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n\n    const editor = getActiveEditor();\n\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\n\nfunction internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n\n  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n\n  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = getNodeFromDOM(anchorDOM);\n    const focusNode = getNodeFromDOM(focusDOM); // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  } // Handle normalization of selection when it is at the boundaries.\n\n\n  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\n\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n} // This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction DEPRECATED_$createGridSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new GridSelection('root', anchor, focus);\n}\nfunction internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n\n  if ($isNodeSelection(lastSelection) || DEPRECATED_$isGridSelection(lastSelection)) {\n    return lastSelection.clone();\n  }\n\n  return internalCreateRangeSelection(lastSelection, domSelection, editor);\n}\nfunction internalCreateRangeSelection(lastSelection, domSelection, editor) {\n  const windowObj = editor._window;\n\n  if (windowObj === null) {\n    return null;\n  } // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n\n  const windowEvent = windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcesssingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  } // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n\n\n  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n\n  const parentKey = parentNode.__key; // Single node. We shift selection but never redimension it\n\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element'); // The new selection might point to text nodes, try to resolve them\n\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  } // The new selection might point to text nodes, try to resolve them\n\n\n  $updateSelectionResolveTextNodes(selection);\n}\n\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n\n    return;\n  }\n\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\n\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement; // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n\n    return;\n  }\n\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  } // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n\n\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  } // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n\n\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n\n    if (anchor.type !== 'element') {\n      return;\n    }\n  } // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n\n\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  } catch (error) {// If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n  }\n\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n\n    if (selectionTarget !== null) {\n      let selectionRect;\n\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes, selectStart) {\n  let selection = $getSelection() || $getPreviousSelection();\n\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n\n  return selection.insertNodes(nodes, selectStart);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n\n  if (selection === null) {\n    return '';\n  }\n\n  return selection.getTextContent();\n}\nfunction DEPRECATED_$computeGridMap(grid, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n\n  function write(startRow, startColumn, cell) {\n    const value = {\n      cell,\n      startColumn,\n      startRow\n    };\n    const rowSpan = cell.__rowSpan;\n    const colSpan = cell.__colSpan;\n\n    for (let i = 0; i < rowSpan; i++) {\n      if (tableMap[startRow + i] === undefined) {\n        tableMap[startRow + i] = [];\n      }\n\n      for (let j = 0; j < colSpan; j++) {\n        tableMap[startRow + i][startColumn + j] = value;\n      }\n    }\n\n    if (cellA.is(cell)) {\n      cellAValue = value;\n    }\n\n    if (cellB.is(cell)) {\n      cellBValue = value;\n    }\n  }\n\n  function isEmpty(row, column) {\n    return tableMap[row] === undefined || tableMap[row][column] === undefined;\n  }\n\n  const gridChildren = grid.getChildren();\n\n  for (let i = 0; i < gridChildren.length; i++) {\n    const row = gridChildren[i];\n\n    if (!DEPRECATED_$isGridRowNode(row)) {\n      throw Error(`Expected GridNode children to be GridRowNode`);\n    }\n\n    const rowChildren = row.getChildren();\n    let j = 0;\n\n    for (const cell of rowChildren) {\n      if (!DEPRECATED_$isGridCellNode(cell)) {\n        throw Error(`Expected GridRowNode children to be GridCellNode`);\n      }\n\n      while (!isEmpty(i, j)) {\n        j++;\n      }\n\n      write(i, j, cell);\n      j += cell.__colSpan;\n    }\n  }\n\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Grid`);\n  }\n\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Grid`);\n  }\n\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction DEPRECATED_$getNodeTriplet(source) {\n  let cell;\n\n  if (source instanceof DEPRECATED_GridCellNode) {\n    cell = source;\n  } else if (source instanceof LexicalNode) {\n    const cell_ = $findMatchingParent(source, DEPRECATED_$isGridCellNode);\n\n    if (!DEPRECATED_$isGridCellNode(cell_)) {\n      throw Error(`Expected to find a parent GridCellNode`);\n    }\n\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), DEPRECATED_$isGridCellNode);\n\n    if (!DEPRECATED_$isGridCellNode(cell_)) {\n      throw Error(`Expected to find a parent GridCellNode`);\n    }\n\n    cell = cell_;\n  }\n\n  const row = cell.getParent();\n\n  if (!DEPRECATED_$isGridRowNode(row)) {\n    throw Error(`Expected GridCellNode to have a parent GridRowNode`);\n  }\n\n  const grid = row.getParent();\n\n  if (!DEPRECATED_$isGridNode(grid)) {\n    throw Error(`Expected GridRowNode to have a parent GridNode`);\n  }\n\n  return [cell, row, grid];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n\n  return activeEditor;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n\n  const transformsArrLength = transformsArr.length;\n\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\n\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined && // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\n\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\n\n\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n\n        dirtyLeaves.add(nodeKey);\n      }\n\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size; // We want to prioritize node transforms over element transforms\n\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    } // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n\n\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n\n      const node = nodeMap.get(nodeKey);\n\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\n\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\n\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n\n  const nodeClass = registeredNode.klass;\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n\n  return node;\n}\n\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n\n    if (updateFn) {\n      updateFn();\n    } // Make the editorState immutable\n\n\n    editorState._readOnly = true;\n\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n\n  return editorState;\n} // This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\n\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\n\nfunction commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n\n  if (pendingEditorState === null) {\n    return;\n  } // ======\n  // Reconciliation has started.\n  // ======\n\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false; // We don't want updates to sync block the reconciliation.\n\n    editor._updating = true;\n\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      } // Reset editor and restore incoming editor state to the DOM\n\n\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n\n      Object.freeze(pendingSelection);\n    }\n  }\n\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n\n    editor._cloneNotNeeded.clear();\n\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n\n  $garbageCollectDetachedDecorators(editor, pendingEditorState); // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window); // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n\n  if (editor._editable && // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n\n\n  const pendingDecorators = editor._pendingDecorators;\n\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  } // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n\n\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  triggerEnqueuedUpdates(editor);\n}\n\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\n\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\n\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n\n  const editors = getEditorsToPropagate(editor);\n\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      beginUpdate(editor, updateFn, options);\n    }\n  }\n}\n\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\n\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false; // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      let tag;\n\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n\n      nextUpdateFn();\n    }\n  }\n\n  return skipTransforms;\n}\n\nfunction beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection != null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = internalCreateSelection(editor);\n      }\n    }\n\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n\n    const endingCompositionKey = editor._compositionKey;\n\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n\n    const pendingSelection = pendingEditorState._selection;\n\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    } // Restore existing editor state to the DOM\n\n\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n\n    editor._cloneNotNeeded.clear();\n\n    editor._dirtyLeaves = new Set();\n\n    editor._dirtyElements.clear();\n\n    commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);\n\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\n\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\n\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n  }\n\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n\n  isIsolated() {\n    return false;\n  }\n\n  isInline() {\n    return true;\n  }\n\n  isKeyboardSelectable() {\n    return true;\n  }\n\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n\n    return children;\n  }\n\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n\n    return children;\n  }\n\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n\n      child = child.getNextSibling();\n    }\n\n    return textNodes;\n  }\n\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getFirstChild();\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      break;\n    }\n\n    return node;\n  }\n\n  getLastDescendant() {\n    let node = this.getLastChild();\n\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getLastChild();\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      break;\n    }\n\n    return node;\n  }\n\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length; // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n\n    return firstChild;\n  }\n\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n\n    return lastChild;\n  }\n\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n\n        node = node.getNextSibling();\n        i++;\n      }\n\n      return null;\n    }\n\n    node = this.getLastChild();\n    i = size - 1;\n\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n\n      node = node.getPreviousSibling();\n      i--;\n    }\n\n    return null;\n  }\n\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n\n    return textContent;\n  }\n\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n\n    return textContentSize;\n  }\n\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n\n    return false;\n  } // Mutators\n\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n\n    const key = this.__key;\n\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n\n    return selection;\n  }\n\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n\n    if ($isElementNode(firstNode) || $isTextNode(firstNode)) {\n      return firstNode.select(0, 0);\n    } // Decorator or LineBreak\n\n\n    if (firstNode !== null) {\n      return firstNode.selectPrevious();\n    }\n\n    return this.select(0, 0);\n  }\n\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      return lastNode.select();\n    } // Decorator or LineBreak\n\n\n    if (lastNode !== null) {\n      return lastNode.selectNext();\n    }\n\n    return this.select();\n  }\n\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n\n    let prevNode = nodeBeforeRange;\n\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n\n      const writableNodeToInsert = nodeToInsert.getWritable();\n\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      } // Set child parent to self\n\n\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n\n    writableSelf.__size = newSize; // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        } // Cleanup if node can't be empty\n\n\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n\n    return writableSelf;\n  } // JSON serialization\n\n\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1\n    };\n  } // These are intended to be extends for specific element heuristics.\n\n\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n\n\n  collapseAtStart(selection) {\n    return false;\n  }\n\n  excludeFromCopy(destination) {\n    return false;\n  } // TODO 0.10 deprecate\n\n\n  canExtractContents() {\n    return true;\n  }\n\n  canReplaceWith(replacement) {\n    return true;\n  }\n\n  canInsertAfter(node) {\n    return true;\n  }\n\n  canBeEmpty() {\n    return true;\n  }\n\n  canInsertTextBefore() {\n    return true;\n  }\n\n  canInsertTextAfter() {\n    return true;\n  }\n\n  isInline() {\n    return false;\n  } // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n\n\n  isShadowRoot() {\n    return false;\n  }\n\n  canMergeWith(node) {\n    return false;\n  }\n\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\n\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n\n  while (node) {\n    const nodeKey = node.__key;\n\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n\n    node = node.getParent();\n  }\n\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n  static getType() {\n    return 'root';\n  }\n\n  static clone() {\n    return new RootNode();\n  }\n\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n\n  getTextContent() {\n    const cachedText = this.__cachedText;\n\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n\n    return super.getTextContent();\n  }\n\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  } // View\n\n\n  updateDOM(prevNode, dom) {\n    return false;\n  } // Mutate\n\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n\n    return super.append(...nodesToAppend);\n  }\n\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1\n    };\n  }\n\n  collapseAtStart() {\n    return true;\n  }\n\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n\n  const pendingSelection = editorState._selection; // Check if we need to update because of changes in selection\n\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\n\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n\n  const serializedChildren = serializedNode.children;\n\n  if ($isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  } // @ts-expect-error\n\n\n  return serializedNode;\n}\n\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n\n  toJSON() {\n    return readEditorState(this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  } // View\n\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) element.append(document.createElement('br'));\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n\n      if (direction) {\n        element.dir = direction;\n      }\n\n      const indent = this.getIndent();\n\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'paragraph',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(_, restoreSelection) {\n    const newElement = $createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart() {\n    const children = this.getChildren(); // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n\n      const prevSibling = this.getPreviousSibling();\n\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nfunction convertParagraphElement(element) {\n  const node = $createParagraphNode();\n\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n\n  return {\n    node\n  };\n}\n\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n\n  editor._cloneNotNeeded.clear();\n\n  editor._dirtyLeaves = new Set();\n\n  editor._dirtyElements.clear();\n\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  } // Remove all the DOM nodes from the root element\n\n\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\n\nfunction initializeConversionCache(nodes) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM != null ? node.klass.importDOM.bind(node.klass) : null;\n\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n\n    handledConversions.add(importDOM);\n    const map = importDOM();\n\n    if (map !== null) {\n      Object.keys(map).forEach(key => {\n        let currentCache = conversionCache.get(key);\n\n        if (currentCache === undefined) {\n          currentCache = [];\n          conversionCache.set(key, currentCache);\n        }\n\n        currentCache.push(map[key]);\n      });\n    }\n  });\n  return conversionCache;\n}\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\n\n\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ...(config.nodes || [])];\n  const onError = config.onError;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replacementClass = null;\n      let replacementKlass = null;\n\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replacementClass = options.with;\n        replacementKlass = options.withKlass ? options.withKlass : null;\n      } // Ensure custom nodes implement required methods.\n\n\n      {\n        const name = klass.name;\n\n        if (name !== 'RootNode') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n\n          if ( // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') && // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n\n          if ( // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n\n          if ( // eslint-disable-next-line no-prototype-builtins\n          !proto.hasOwnProperty('exportJSON')) {\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n\n      registeredNodes.set(type, {\n        klass,\n        replace: replacementClass,\n        replaceWithKlass: replacementKlass,\n        transforms\n      });\n    }\n  }\n\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes), isEditable);\n\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n\n  return editor;\n}\nclass LexicalEditor {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor; // The root element associated with this editor\n\n    this._rootElement = null; // The current editor state\n\n    this._editorState = editorState; // Handling of drafts and updates\n\n    this._pendingEditorState = null; // Used to help co-ordinate selection and events\n\n    this._compositionKey = null;\n    this._deferred = []; // Used during reconciliation\n\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false; // Listeners\n\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    }; // Commands\n\n    this._commands = new Map(); // Editor configuration for theme/context.\n\n    this._config = config; // Mapping of types to their nodes\n\n    this._nodes = nodes; // React node decorators for portals\n\n    this._decorators = {};\n    this._pendingDecorators = null; // Used to optimize reconciliation\n\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set(); // Handling of DOM mutations\n\n    this._observer = null; // Used for identifying owning editors\n\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n\n\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched, subject to priority. Listeners that run at a higher priority can \"intercept\"\n   * commands and prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners registered at the same priority level will run deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n\n    const commandsMap = this._commands;\n\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n\n    const listenersInPriorityOrder = commandsMap.get(command);\n\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerMutationListener(klass, listener) {\n    const registeredNode = this._nodes.get(klass.getType());\n\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klass);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n  /** @internal */\n\n\n  registerNodeTransformToKlass(klass, listener) {\n    const type = klass.getType();\n\n    const registeredNode = this._nodes.get(type);\n\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    return registeredNode;\n  }\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n\n\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n\n\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload.\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n\n\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n\n\n  getDecorators() {\n    return this._decorators;\n  }\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n\n\n  getRootElement() {\n    return this._rootElement;\n  }\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n\n\n  getKey() {\n    return this._key;\n  }\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n\n\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n\n        this._updateTags.add('history-merge');\n\n        commitPendingUpdates(this); // TODO: remove this flag once we no longer use UEv2 internally\n\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        // If content editable is unmounted we'll reset editor state back to original\n        // (or pending) editor state since there will be no reconciliation\n        this._editorState = pendingEditorState;\n        this._pendingEditorState = null;\n        this._window = null;\n      }\n\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n\n\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n\n\n  getEditorState() {\n    return this._editorState;\n  }\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n\n\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n\n      commitPendingUpdates(this);\n    }\n\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n\n    this._dirtyElements.set('root', false);\n\n    this._compositionKey = null;\n\n    if (tag != null) {\n      tags.add(tag);\n    }\n\n    commitPendingUpdates(this);\n  }\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserliazation from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n\n\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n\n\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n\n\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n\n          if (callbackFn) {\n            callbackFn();\n          }\n        },\n        tag: 'focus'\n      }); // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n  /**\n   * Removes focus from the editor.\n   */\n\n\n  blur() {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n\n    const domSelection = getDOMSelection(this._window);\n\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n\n\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n\n\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n\n\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass DEPRECATED_GridCellNode extends ElementNode {\n  /** @internal */\n  constructor(colSpan, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      colSpan: this.__colSpan,\n      rowSpan: this.__rowSpan\n    };\n  }\n\n  getColSpan() {\n    return this.__colSpan;\n  }\n\n  setColSpan(colSpan) {\n    this.getWritable().__colSpan = colSpan;\n    return this;\n  }\n\n  getRowSpan() {\n    return this.__rowSpan;\n  }\n\n  setRowSpan(rowSpan) {\n    this.getWritable().__rowSpan = rowSpan;\n    return this;\n  }\n\n}\nfunction DEPRECATED_$isGridCellNode(node) {\n  return node instanceof DEPRECATED_GridCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridNode extends ElementNode {}\nfunction DEPRECATED_$isGridNode(node) {\n  return node instanceof DEPRECATED_GridNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridRowNode extends ElementNode {}\nfunction DEPRECATED_$isGridRowNode(node) {\n  return node instanceof DEPRECATED_GridRowNode;\n}\n\nexports.$addUpdateTag = $addUpdateTag;\nexports.$applyNodeReplacement = $applyNodeReplacement;\nexports.$copyNode = $copyNode;\nexports.$createLineBreakNode = $createLineBreakNode;\nexports.$createNodeSelection = $createNodeSelection;\nexports.$createParagraphNode = $createParagraphNode;\nexports.$createRangeSelection = $createRangeSelection;\nexports.$createTabNode = $createTabNode;\nexports.$createTextNode = $createTextNode;\nexports.$getAdjacentNode = $getAdjacentNode;\nexports.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;\nexports.$getNearestRootOrShadowRoot = $getNearestRootOrShadowRoot;\nexports.$getNodeByKey = $getNodeByKey;\nexports.$getPreviousSelection = $getPreviousSelection;\nexports.$getRoot = $getRoot;\nexports.$getSelection = $getSelection;\nexports.$getTextContent = $getTextContent;\nexports.$hasAncestor = $hasAncestor;\nexports.$hasUpdateTag = $hasUpdateTag;\nexports.$insertNodes = $insertNodes;\nexports.$isBlockElementNode = $isBlockElementNode;\nexports.$isDecoratorNode = $isDecoratorNode;\nexports.$isElementNode = $isElementNode;\nexports.$isInlineElementOrDecoratorNode = $isInlineElementOrDecoratorNode;\nexports.$isLeafNode = $isLeafNode;\nexports.$isLineBreakNode = $isLineBreakNode;\nexports.$isNodeSelection = $isNodeSelection;\nexports.$isParagraphNode = $isParagraphNode;\nexports.$isRangeSelection = $isRangeSelection;\nexports.$isRootNode = $isRootNode;\nexports.$isRootOrShadowRoot = $isRootOrShadowRoot;\nexports.$isTabNode = $isTabNode;\nexports.$isTextNode = $isTextNode;\nexports.$nodesOfType = $nodesOfType;\nexports.$normalizeSelection__EXPERIMENTAL = $normalizeSelection;\nexports.$parseSerializedNode = $parseSerializedNode;\nexports.$selectAll = $selectAll;\nexports.$setCompositionKey = $setCompositionKey;\nexports.$setSelection = $setSelection;\nexports.$splitNode = $splitNode;\nexports.BLUR_COMMAND = BLUR_COMMAND;\nexports.CAN_REDO_COMMAND = CAN_REDO_COMMAND;\nexports.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;\nexports.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;\nexports.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;\nexports.CLICK_COMMAND = CLICK_COMMAND;\nexports.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL;\nexports.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;\nexports.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;\nexports.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW;\nexports.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;\nexports.CONTROLLED_TEXT_INSERTION_COMMAND = CONTROLLED_TEXT_INSERTION_COMMAND;\nexports.COPY_COMMAND = COPY_COMMAND;\nexports.CUT_COMMAND = CUT_COMMAND;\nexports.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;\nexports.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;\nexports.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;\nexports.DEPRECATED_$computeGridMap = DEPRECATED_$computeGridMap;\nexports.DEPRECATED_$createGridSelection = DEPRECATED_$createGridSelection;\nexports.DEPRECATED_$getGridCellNodeRect = DEPRECATED_$getGridCellNodeRect;\nexports.DEPRECATED_$getNodeTriplet = DEPRECATED_$getNodeTriplet;\nexports.DEPRECATED_$isGridCellNode = DEPRECATED_$isGridCellNode;\nexports.DEPRECATED_$isGridNode = DEPRECATED_$isGridNode;\nexports.DEPRECATED_$isGridRowNode = DEPRECATED_$isGridRowNode;\nexports.DEPRECATED_$isGridSelection = DEPRECATED_$isGridSelection;\nexports.DEPRECATED_GridCellNode = DEPRECATED_GridCellNode;\nexports.DEPRECATED_GridNode = DEPRECATED_GridNode;\nexports.DEPRECATED_GridRowNode = DEPRECATED_GridRowNode;\nexports.DRAGEND_COMMAND = DRAGEND_COMMAND;\nexports.DRAGOVER_COMMAND = DRAGOVER_COMMAND;\nexports.DRAGSTART_COMMAND = DRAGSTART_COMMAND;\nexports.DROP_COMMAND = DROP_COMMAND;\nexports.DecoratorNode = DecoratorNode;\nexports.ElementNode = ElementNode;\nexports.FOCUS_COMMAND = FOCUS_COMMAND;\nexports.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;\nexports.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND;\nexports.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;\nexports.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;\nexports.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND;\nexports.INSERT_TAB_COMMAND = INSERT_TAB_COMMAND;\nexports.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;\nexports.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;\nexports.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;\nexports.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;\nexports.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;\nexports.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;\nexports.KEY_DOWN_COMMAND = KEY_DOWN_COMMAND;\nexports.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;\nexports.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;\nexports.KEY_MODIFIER_COMMAND = KEY_MODIFIER_COMMAND;\nexports.KEY_SPACE_COMMAND = KEY_SPACE_COMMAND;\nexports.KEY_TAB_COMMAND = KEY_TAB_COMMAND;\nexports.LineBreakNode = LineBreakNode;\nexports.MOVE_TO_END = MOVE_TO_END;\nexports.MOVE_TO_START = MOVE_TO_START;\nexports.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;\nexports.PASTE_COMMAND = PASTE_COMMAND;\nexports.ParagraphNode = ParagraphNode;\nexports.REDO_COMMAND = REDO_COMMAND;\nexports.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;\nexports.RootNode = RootNode;\nexports.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND;\nexports.SELECT_ALL_COMMAND = SELECT_ALL_COMMAND;\nexports.TabNode = TabNode;\nexports.TextNode = TextNode;\nexports.UNDO_COMMAND = UNDO_COMMAND;\nexports.createCommand = createCommand;\nexports.createEditor = createEditor;\nexports.getNearestEditorFromDOMNode = getNearestEditorFromDOMNode;\nexports.isHTMLAnchorElement = isHTMLAnchorElement;\nexports.isHTMLElement = isHTMLElement;\nexports.isSelectionCapturedInDecoratorInput = isSelectionCapturedInDecoratorInput;\nexports.isSelectionWithinEditor = isSelectionWithinEditor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}